{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MsgPHP Documentation \u00b6 MsgPHP is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.","title":"Home"},{"location":"#msgphp-documentation","text":"MsgPHP is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.","title":"MsgPHP Documentation"},{"location":"cookbook/configuring-doctrine-orm/","text":"Configuring Doctrine ORM \u00b6 To be able to fetch and persist entities using repositories provided by MsgPHP an ORM must be configured. In this article is explained how to setup Doctrine ORM infrastructure . Installation \u00b6 composer install doctrine/orm doctrine/doctrine-bundle # with Symfony Flex composer install orm Configuration \u00b6 See the recipe configuration for the minimal configuration to put in config/packages/doctrine.yaml . Although the examples use annotation based mappings, you are not required to do so. Read more . Info The configuration is automatically added with Symfony Flex Configure a Database \u00b6 # .env # sqlite DATABASE_URL = sqlite:///%kernel.project_dir%/var/db.sqlite # mysql / mariadb DATABASE_URL = \"mysql://user:pass@host:3306/db_name?charset=utf8mb4&serverVersion=5.7\" Create the database: bin/console doctrine:database:create bin/console doctrine:schema:update Configure an Entity Manager \u00b6 MsgPHP uses the doctrine.orm.entity_manager entity manager service by default. To use another entity manager instead configure the entity manager alias service: # config/services.yaml services : # ... msgphp.doctrine.entity_manager : '@doctrine.orm.other_entity_manager' Overriding Mapping Configuration \u00b6 Use a fixed max key length: # config/services.yaml parameters : msgphp.doctrine.mapping_config : key_max_length : 191 By default MsgPHPs built-in mapping files can be overridden by putting a modified version in %kernel.project_dir%/config/msgphp/doctrine . To specify a different location, use: # config/services.yaml parameters : msgphp.doctrine.mapping_config : mapping_dir : /some/path","title":"Configuring Doctrine ORM"},{"location":"cookbook/configuring-doctrine-orm/#configuring-doctrine-orm","text":"To be able to fetch and persist entities using repositories provided by MsgPHP an ORM must be configured. In this article is explained how to setup Doctrine ORM infrastructure .","title":"Configuring Doctrine ORM"},{"location":"cookbook/configuring-doctrine-orm/#installation","text":"composer install doctrine/orm doctrine/doctrine-bundle # with Symfony Flex composer install orm","title":"Installation"},{"location":"cookbook/configuring-doctrine-orm/#configuration","text":"See the recipe configuration for the minimal configuration to put in config/packages/doctrine.yaml . Although the examples use annotation based mappings, you are not required to do so. Read more . Info The configuration is automatically added with Symfony Flex","title":"Configuration"},{"location":"cookbook/configuring-doctrine-orm/#configure-a-database","text":"# .env # sqlite DATABASE_URL = sqlite:///%kernel.project_dir%/var/db.sqlite # mysql / mariadb DATABASE_URL = \"mysql://user:pass@host:3306/db_name?charset=utf8mb4&serverVersion=5.7\" Create the database: bin/console doctrine:database:create bin/console doctrine:schema:update","title":"Configure a Database"},{"location":"cookbook/configuring-doctrine-orm/#configure-an-entity-manager","text":"MsgPHP uses the doctrine.orm.entity_manager entity manager service by default. To use another entity manager instead configure the entity manager alias service: # config/services.yaml services : # ... msgphp.doctrine.entity_manager : '@doctrine.orm.other_entity_manager'","title":"Configure an Entity Manager"},{"location":"cookbook/configuring-doctrine-orm/#overriding-mapping-configuration","text":"Use a fixed max key length: # config/services.yaml parameters : msgphp.doctrine.mapping_config : key_max_length : 191 By default MsgPHPs built-in mapping files can be overridden by putting a modified version in %kernel.project_dir%/config/msgphp/doctrine . To specify a different location, use: # config/services.yaml parameters : msgphp.doctrine.mapping_config : mapping_dir : /some/path","title":"Overriding Mapping Configuration"},{"location":"cookbook/configuring-symfony-messenger/","text":"Configuring Symfony Messenger \u00b6 To be able to dispatch messages provided by MsgPHP a domain message bus must be configured. In this article is explained how to setup Symfony Messenger infrastructure . Installation \u00b6 composer install symfony/messenger # with Symfony Flex composer install messenger Configuration \u00b6 See the recipe configuration for the minimal configuration to put in config/packages/messenger.yaml . Info The configuration is automatically added with Symfony Flex Configure a Command and Event Bus \u00b6 # config/packages/messenger.yaml framework : messenger : # ... default_bus : command_bus buses : command_bus : middleware : - msgphp.messenger.console_message_receiver event_bus : default_middleware : allow_no_handlers middleware : - msgphp.messenger.console_message_receiver By adding the msgphp.messenger.console_message_receiver middleware MsgPHP console commands are able to receive back a dispatched message. This is recommended to provide better output in CLI. Enable the Command and Event Bus \u00b6 MsgPHP uses the bus configured with framework.messenger.default_bus for both command and event messages by default. To use your custom buses instead configure the bus aliases: # config/services.yaml services : # ... msgphp.messenger.command_bus : '@command_bus' msgphp.messenger.event_bus : '@event_bus'","title":"Configuring Symfony Messenger"},{"location":"cookbook/configuring-symfony-messenger/#configuring-symfony-messenger","text":"To be able to dispatch messages provided by MsgPHP a domain message bus must be configured. In this article is explained how to setup Symfony Messenger infrastructure .","title":"Configuring Symfony Messenger"},{"location":"cookbook/configuring-symfony-messenger/#installation","text":"composer install symfony/messenger # with Symfony Flex composer install messenger","title":"Installation"},{"location":"cookbook/configuring-symfony-messenger/#configuration","text":"See the recipe configuration for the minimal configuration to put in config/packages/messenger.yaml . Info The configuration is automatically added with Symfony Flex","title":"Configuration"},{"location":"cookbook/configuring-symfony-messenger/#configure-a-command-and-event-bus","text":"# config/packages/messenger.yaml framework : messenger : # ... default_bus : command_bus buses : command_bus : middleware : - msgphp.messenger.console_message_receiver event_bus : default_middleware : allow_no_handlers middleware : - msgphp.messenger.console_message_receiver By adding the msgphp.messenger.console_message_receiver middleware MsgPHP console commands are able to receive back a dispatched message. This is recommended to provide better output in CLI.","title":"Configure a Command and Event Bus"},{"location":"cookbook/configuring-symfony-messenger/#enable-the-command-and-event-bus","text":"MsgPHP uses the bus configured with framework.messenger.default_bus for both command and event messages by default. To use your custom buses instead configure the bus aliases: # config/services.yaml services : # ... msgphp.messenger.command_bus : '@command_bus' msgphp.messenger.event_bus : '@event_bus'","title":"Enable the Command and Event Bus"},{"location":"cookbook/user-bundle/creating-a-user/","text":"Creating a User \u00b6 Users can be created by dispatching the CreateUserCommand message with a data array that contains values for the User constructor arguments. <?php use MsgPhp\\User\\Command\\CreateUserCommand ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUserCommand ([])); The handler will automatically add an id element to the data array holding an instance of MsgPhp\\User\\UserIdInterface . Alternatively it can be passed upfront: <?php use MsgPhp\\User\\UserId ; use MsgPhp\\User\\Command\\CreateUserCommand ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUserCommand ([ 'id' => new UserId (), ])); To programmatically factorize an identifier , use the object factory : <?php use MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface ; use MsgPhp\\User\\UserIdInterface ; use MsgPhp\\User\\Command\\CreateUserCommand ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var DomainObjectFactoryInterface $factory */ /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUserCommand ([ 'id' => $factory -> create ( UserIdInterface :: class ), ])); Adding Custom Fields \u00b6 Define the custom fields: <?php // src/Entity/User/User.php // ... class User extends BaseUser { // ... private $requiredField ; private $optionalField ; public function __construct ( UserIdInterface $id , $requiredField , $optionalField = null ) { $this -> id = $id ; $this -> requiredField = $requiredField ; $this -> optionalField = $optionalField ; } // ... } Specify the fields during dispatch: <?php use MsgPhp\\User\\Command\\CreateUserCommand ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUserCommand ([ 'requiredField' => 'value' , ])); // alternatively: $bus -> dispatch ( new CreateUserCommand ([ 'requiredField' => 'value' , 'optionalField' => 'value' , ]));","title":"Creating a User"},{"location":"cookbook/user-bundle/creating-a-user/#creating-a-user","text":"Users can be created by dispatching the CreateUserCommand message with a data array that contains values for the User constructor arguments. <?php use MsgPhp\\User\\Command\\CreateUserCommand ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUserCommand ([])); The handler will automatically add an id element to the data array holding an instance of MsgPhp\\User\\UserIdInterface . Alternatively it can be passed upfront: <?php use MsgPhp\\User\\UserId ; use MsgPhp\\User\\Command\\CreateUserCommand ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUserCommand ([ 'id' => new UserId (), ])); To programmatically factorize an identifier , use the object factory : <?php use MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface ; use MsgPhp\\User\\UserIdInterface ; use MsgPhp\\User\\Command\\CreateUserCommand ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var DomainObjectFactoryInterface $factory */ /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUserCommand ([ 'id' => $factory -> create ( UserIdInterface :: class ), ]));","title":"Creating a User"},{"location":"cookbook/user-bundle/creating-a-user/#adding-custom-fields","text":"Define the custom fields: <?php // src/Entity/User/User.php // ... class User extends BaseUser { // ... private $requiredField ; private $optionalField ; public function __construct ( UserIdInterface $id , $requiredField , $optionalField = null ) { $this -> id = $id ; $this -> requiredField = $requiredField ; $this -> optionalField = $optionalField ; } // ... } Specify the fields during dispatch: <?php use MsgPhp\\User\\Command\\CreateUserCommand ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUserCommand ([ 'requiredField' => 'value' , ])); // alternatively: $bus -> dispatch ( new CreateUserCommand ([ 'requiredField' => 'value' , 'optionalField' => 'value' , ]));","title":"Adding Custom Fields"},{"location":"cookbook/user-bundle/installation/","text":"User Bundle Installation \u00b6 Install the bundle using Composer : composer require msgphp/user-bundle Info When using Symfony Flex to manage your application the minimal bundle recipe configuration is applied automatically upon installation Configure the User Entity \u00b6 <?php // src/Entity/User/User.php namespace App\\Entity\\User ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\User\\Entity\\User as BaseUser ; use MsgPhp\\User\\UserIdInterface ; /** * @ORM\\Entity() */ class User extends BaseUser { /** @ORM\\Id() @ORM\\GeneratedValue() @ORM\\Column(type=\"msgphp_user_id\", length=191) */ private $id ; public function __construct ( UserIdInterface $id ) { $this -> id = $id ; } public function getId () : UserIdInterface { return $this -> id ; } } # config/packages/msgphp_user.yaml msgphp_user : class_mapping : MsgPhp\\User\\Entity\\User : App\\Entity\\User\\User Note The extra /User/ layer specifies the domain the entity is bound to and can be left out depending on the complexity of your application Disable Required Constructor Argument \u00b6 The required constructor argument enables to provide an identifier upfront, so the user does not have to be queried for it after. To disable it, use: <?php // ... public function __construct () { $this -> id = new MsgPhp\\User\\UserId (); // represents an \"empty\" ID (i.e. \"new\") } Disable Automatic Identifier Hydration \u00b6 Using the built-in msgphp_user_id Doctrine type enables decoupling between your entity and its identifier. To disable it, use: <?php // ... /** @ORM\\Id() @ORM\\GeneratedValue() @ORM\\Column(type=\"integer\") */ private $id ; // ... public function getId () : UserIdInterface { return MsgPhp\\User\\UserId :: fromValue ( $this -> id ); } Override Mapping Configuration \u00b6 If for some reason the default mapping needs to be customized, create the file config/msgphp/doctrine/User.Entity.User.orm.xml : <doctrine-mapping> <mapped-superclass name= \"MsgPhp\\User\\Entity\\User\" > <!-- ... --> </mapped-superclass> </doctrine-mapping> Info See default mapping files Configure the User Identity \u00b6 The user is identified by a built-in domain identifier of type MsgPhp\\User\\UserIdInterface . The default data type is considered integer using a default implementation of type: MsgPhp\\User\\UserId . Optionally change the data type and implementation used by MsgPHP: # config/packages/msgphp_user.yaml msgphp_user : id_type_mapping : MsgPhp\\User\\UserIdInterface : bigint class_mapping : MsgPhp\\User\\UserIdInterface : App\\Entity\\User\\UserId Using a UUID identifier \u00b6 # config/packages/msgphp_user.yaml msgphp_user : id_type_mapping : MsgPhp\\User\\UserIdInterface : uuid # uuid_binary, uuid_binary_ordered_time This changes the default implementation used by MsgPHP to MsgPhp\\User\\Infra\\Uuid\\UserId , a sub class of the default UUID domain identifier .","title":"Installation"},{"location":"cookbook/user-bundle/installation/#user-bundle-installation","text":"Install the bundle using Composer : composer require msgphp/user-bundle Info When using Symfony Flex to manage your application the minimal bundle recipe configuration is applied automatically upon installation","title":"User Bundle Installation"},{"location":"cookbook/user-bundle/installation/#configure-the-user-entity","text":"<?php // src/Entity/User/User.php namespace App\\Entity\\User ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\User\\Entity\\User as BaseUser ; use MsgPhp\\User\\UserIdInterface ; /** * @ORM\\Entity() */ class User extends BaseUser { /** @ORM\\Id() @ORM\\GeneratedValue() @ORM\\Column(type=\"msgphp_user_id\", length=191) */ private $id ; public function __construct ( UserIdInterface $id ) { $this -> id = $id ; } public function getId () : UserIdInterface { return $this -> id ; } } # config/packages/msgphp_user.yaml msgphp_user : class_mapping : MsgPhp\\User\\Entity\\User : App\\Entity\\User\\User Note The extra /User/ layer specifies the domain the entity is bound to and can be left out depending on the complexity of your application","title":"Configure the User Entity"},{"location":"cookbook/user-bundle/installation/#disable-required-constructor-argument","text":"The required constructor argument enables to provide an identifier upfront, so the user does not have to be queried for it after. To disable it, use: <?php // ... public function __construct () { $this -> id = new MsgPhp\\User\\UserId (); // represents an \"empty\" ID (i.e. \"new\") }","title":"Disable Required Constructor Argument"},{"location":"cookbook/user-bundle/installation/#disable-automatic-identifier-hydration","text":"Using the built-in msgphp_user_id Doctrine type enables decoupling between your entity and its identifier. To disable it, use: <?php // ... /** @ORM\\Id() @ORM\\GeneratedValue() @ORM\\Column(type=\"integer\") */ private $id ; // ... public function getId () : UserIdInterface { return MsgPhp\\User\\UserId :: fromValue ( $this -> id ); }","title":"Disable Automatic Identifier Hydration"},{"location":"cookbook/user-bundle/installation/#override-mapping-configuration","text":"If for some reason the default mapping needs to be customized, create the file config/msgphp/doctrine/User.Entity.User.orm.xml : <doctrine-mapping> <mapped-superclass name= \"MsgPhp\\User\\Entity\\User\" > <!-- ... --> </mapped-superclass> </doctrine-mapping> Info See default mapping files","title":"Override Mapping Configuration"},{"location":"cookbook/user-bundle/installation/#configure-the-user-identity","text":"The user is identified by a built-in domain identifier of type MsgPhp\\User\\UserIdInterface . The default data type is considered integer using a default implementation of type: MsgPhp\\User\\UserId . Optionally change the data type and implementation used by MsgPHP: # config/packages/msgphp_user.yaml msgphp_user : id_type_mapping : MsgPhp\\User\\UserIdInterface : bigint class_mapping : MsgPhp\\User\\UserIdInterface : App\\Entity\\User\\UserId","title":"Configure the User Identity"},{"location":"cookbook/user-bundle/installation/#using-a-uuid-identifier","text":"# config/packages/msgphp_user.yaml msgphp_user : id_type_mapping : MsgPhp\\User\\UserIdInterface : uuid # uuid_binary, uuid_binary_ordered_time This changes the default implementation used by MsgPHP to MsgPhp\\User\\Infra\\Uuid\\UserId , a sub class of the default UUID domain identifier .","title":"Using a UUID identifier"},{"location":"ddd/collections/","text":"Collections \u00b6 A domain collection is a traversable and bound to MsgPhp\\Domain\\DomainCollectionInterface . Its purpose is to utilize a primitive iterable value. It may hold any type of element values. API \u00b6 Extends \u00b6 \\Countable \\IteratorAggregate static fromValue(?iterable $value): DomainCollectionInterface \u00b6 Returns a factorized collection from any primitive iterable. Using null implies an empty collection. isEmpty(): bool \u00b6 Tells if a collection is considered empty, i.e. contains zero elements. contains($element): bool \u00b6 Tells if a collection contains the given element. Comparison is done strictly. containsKey($key): bool \u00b6 Tells if a collection contains an element at the given key. first(): mixed \u00b6 Returns the first element from a collection. last(): mixed \u00b6 Returns the last element from a collection. get($key): mixed \u00b6 Returns the element at the given key from a collection. filter(callable $filter): DomainCollectionInterface \u00b6 Returns a new collection containing only elements for which $filter returns true . Keys are preserved. slice(int $offset, int $limit = 0): DomainCollectionInterface \u00b6 Returns a new collection containing a slice of elements. By default the slice has no limit, implied by integer 0 . Keys are preserved. map(callable $mapper): DomainCollectionInterface \u00b6 Returns a new collection containing each collection element as returned by $mapper . Keys are preserved. Pagination API \u00b6 A collection that is part of a paginated result set is bound to MsgPhp\\Domain\\PaginatedDomainCollectionInterface . Its purpose is to expose the current pagination. Extends \u00b6 DomainCollectionInterface getOffset(): float \u00b6 Get the current page offset. getLimit(): float \u00b6 Get the current page limit (e.g. items per page). getCurrentPage(): float \u00b6 Get the current page number. getLastPage(): float \u00b6 Get the last page number. getTotalCount(): float \u00b6 Get the total no. of items in the full result set. Note count() should return the no. of items on the current page Implementations \u00b6 MsgPhp\\Domain\\DomainCollection \u00b6 A first class citizen domain collection. Basic Example \u00b6 <?php use MsgPhp\\Domain\\DomainCollection ; // --- SETUP --- $collection = new DomainCollection ([ 'a' , 'b' , 'c' , 1 , 2 , 3 , 'key' => 'value' ]); // --- USAGE --- $collection -> isEmpty (); // false count ( $collection ); // int(7) $collection -> contains ( 2 ); // true $collection -> contains ( '2' ); // false $collection -> containsKey ( 0 ); // true $collection -> containsKey ( '0' ); // true $collection -> first (); // \"a\" $collection -> last (); // int(3) $collection -> get ( '0' ); // \"a\" $collection -> get ( 3 ); // int(1) $collection -> get ( 'key' ); // \"value\" $onlyInts = $collection -> filter ( function ( $value ) : bool { return is_int ( $value ); }); $firstTwoInts = $onlyInts -> slice ( 0 , 2 ); $firstTwoIntsPlussed = $firstTwoInts -> map ( function ( int $value ) : int { return ++ $value ; }); MsgPhp\\Domain\\PaginatedDomainCollection \u00b6 A first class citizen paginated domain collection to transform any collection into a paginated collection. MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection \u00b6 A Doctrine tailored domain collection. Read more","title":"Collections"},{"location":"ddd/collections/#collections","text":"A domain collection is a traversable and bound to MsgPhp\\Domain\\DomainCollectionInterface . Its purpose is to utilize a primitive iterable value. It may hold any type of element values.","title":"Collections"},{"location":"ddd/collections/#api","text":"","title":"API"},{"location":"ddd/collections/#extends","text":"\\Countable \\IteratorAggregate","title":"Extends"},{"location":"ddd/collections/#static-fromvalueiterable-value-domaincollectioninterface","text":"Returns a factorized collection from any primitive iterable. Using null implies an empty collection.","title":"static fromValue(?iterable $value): DomainCollectionInterface"},{"location":"ddd/collections/#isempty-bool","text":"Tells if a collection is considered empty, i.e. contains zero elements.","title":"isEmpty(): bool"},{"location":"ddd/collections/#containselement-bool","text":"Tells if a collection contains the given element. Comparison is done strictly.","title":"contains($element): bool"},{"location":"ddd/collections/#containskeykey-bool","text":"Tells if a collection contains an element at the given key.","title":"containsKey($key): bool"},{"location":"ddd/collections/#first-mixed","text":"Returns the first element from a collection.","title":"first(): mixed"},{"location":"ddd/collections/#last-mixed","text":"Returns the last element from a collection.","title":"last(): mixed"},{"location":"ddd/collections/#getkey-mixed","text":"Returns the element at the given key from a collection.","title":"get($key): mixed"},{"location":"ddd/collections/#filtercallable-filter-domaincollectioninterface","text":"Returns a new collection containing only elements for which $filter returns true . Keys are preserved.","title":"filter(callable $filter): DomainCollectionInterface"},{"location":"ddd/collections/#sliceint-offset-int-limit-0-domaincollectioninterface","text":"Returns a new collection containing a slice of elements. By default the slice has no limit, implied by integer 0 . Keys are preserved.","title":"slice(int $offset, int $limit = 0): DomainCollectionInterface"},{"location":"ddd/collections/#mapcallable-mapper-domaincollectioninterface","text":"Returns a new collection containing each collection element as returned by $mapper . Keys are preserved.","title":"map(callable $mapper): DomainCollectionInterface"},{"location":"ddd/collections/#pagination-api","text":"A collection that is part of a paginated result set is bound to MsgPhp\\Domain\\PaginatedDomainCollectionInterface . Its purpose is to expose the current pagination.","title":"Pagination API"},{"location":"ddd/collections/#extends_1","text":"DomainCollectionInterface","title":"Extends"},{"location":"ddd/collections/#getoffset-float","text":"Get the current page offset.","title":"getOffset(): float"},{"location":"ddd/collections/#getlimit-float","text":"Get the current page limit (e.g. items per page).","title":"getLimit(): float"},{"location":"ddd/collections/#getcurrentpage-float","text":"Get the current page number.","title":"getCurrentPage(): float"},{"location":"ddd/collections/#getlastpage-float","text":"Get the last page number.","title":"getLastPage(): float"},{"location":"ddd/collections/#gettotalcount-float","text":"Get the total no. of items in the full result set. Note count() should return the no. of items on the current page","title":"getTotalCount(): float"},{"location":"ddd/collections/#implementations","text":"","title":"Implementations"},{"location":"ddd/collections/#msgphpdomaindomaincollection","text":"A first class citizen domain collection.","title":"MsgPhp\\Domain\\DomainCollection"},{"location":"ddd/collections/#basic-example","text":"<?php use MsgPhp\\Domain\\DomainCollection ; // --- SETUP --- $collection = new DomainCollection ([ 'a' , 'b' , 'c' , 1 , 2 , 3 , 'key' => 'value' ]); // --- USAGE --- $collection -> isEmpty (); // false count ( $collection ); // int(7) $collection -> contains ( 2 ); // true $collection -> contains ( '2' ); // false $collection -> containsKey ( 0 ); // true $collection -> containsKey ( '0' ); // true $collection -> first (); // \"a\" $collection -> last (); // int(3) $collection -> get ( '0' ); // \"a\" $collection -> get ( 3 ); // int(1) $collection -> get ( 'key' ); // \"value\" $onlyInts = $collection -> filter ( function ( $value ) : bool { return is_int ( $value ); }); $firstTwoInts = $onlyInts -> slice ( 0 , 2 ); $firstTwoIntsPlussed = $firstTwoInts -> map ( function ( int $value ) : int { return ++ $value ; });","title":"Basic Example"},{"location":"ddd/collections/#msgphpdomainpaginateddomaincollection","text":"A first class citizen paginated domain collection to transform any collection into a paginated collection.","title":"MsgPhp\\Domain\\PaginatedDomainCollection"},{"location":"ddd/collections/#msgphpdomaininfradoctrinedomaincollection","text":"A Doctrine tailored domain collection. Read more","title":"MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection"},{"location":"ddd/entities/","text":"Entities \u00b6 Domain entities are \" vanilla PHP objects\" owned by the user. To simplify its definition common fields and features are provided in the form of PHP traits . Entity Fields \u00b6 Use entity fields to provide read operations for common entity fields. Built-in fields are: Msgphp\\Domain\\Entity\\Fields\\CreatedAtField Msgphp\\Domain\\Entity\\Fields\\EnabledField Msgphp\\Domain\\Entity\\Fields\\LastUpdatedAtField Entity Features \u00b6 Use entity features to provide write operations for common entity fields. Built-in features are: MsgPhp\\Domain\\Entity\\Features\\CanBeConfirmed MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled Basic Example \u00b6 <?php use MsgPhp\\Domain\\Entity\\Fields\\CreatedAtField ; use MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled ; // --- SETUP --- class MyEntity { use CreatedAtField ; use CanBeEnabled ; public function __construct () { $this -> createdAt = new \\DateTimeImmutable (); } } // --- USAGE --- $entity = new MyEntity (); $createdAt = $entity -> getCreatedAt (); if ( ! $entity -> isEnabled ()) { $entity -> enable (); }","title":"Entities"},{"location":"ddd/entities/#entities","text":"Domain entities are \" vanilla PHP objects\" owned by the user. To simplify its definition common fields and features are provided in the form of PHP traits .","title":"Entities"},{"location":"ddd/entities/#entity-fields","text":"Use entity fields to provide read operations for common entity fields. Built-in fields are: Msgphp\\Domain\\Entity\\Fields\\CreatedAtField Msgphp\\Domain\\Entity\\Fields\\EnabledField Msgphp\\Domain\\Entity\\Fields\\LastUpdatedAtField","title":"Entity Fields"},{"location":"ddd/entities/#entity-features","text":"Use entity features to provide write operations for common entity fields. Built-in features are: MsgPhp\\Domain\\Entity\\Features\\CanBeConfirmed MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled","title":"Entity Features"},{"location":"ddd/entities/#basic-example","text":"<?php use MsgPhp\\Domain\\Entity\\Fields\\CreatedAtField ; use MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled ; // --- SETUP --- class MyEntity { use CreatedAtField ; use CanBeEnabled ; public function __construct () { $this -> createdAt = new \\DateTimeImmutable (); } } // --- USAGE --- $entity = new MyEntity (); $createdAt = $entity -> getCreatedAt (); if ( ! $entity -> isEnabled ()) { $entity -> enable (); }","title":"Basic Example"},{"location":"ddd/identifiers/","text":"Identifiers \u00b6 A domain identifier is a value object and bound to MsgPhp\\Domain\\DomainIdInterface . Its purpose is to utilize a primitive identifier value, usually used to identity an entity with. API \u00b6 static fromValue($value): DomainIdInterface \u00b6 Returns a factorized identifier from any primitive value. Using null might imply an empty identifier. isEmpty(): bool \u00b6 Tells if an identifier value is considered empty, thus has no known primitive value. equals(DomainIdInterface $id): bool \u00b6 Tells if an identifier strictly equals another identifier. toString(): string / __toString(): string \u00b6 Returns the identifier its primitive string value. If the identifier is empty (see isEmpty() ) an empty string should be returned. Implementations \u00b6 MsgPhp\\Domain\\DomainIdTrait \u00b6 A first class citizen domain identifier trait. Basic Example \u00b6 <?php use MsgPhp\\Domain\\ { DomainIdInterface , DomainIdTrait }; // --- SETUP --- final class MyDomainId implements DomainIdInterface { use DomainIdTrait ; } $id = new MyDomainId ( '1' ); $emptyId = new MyDomainId (); // --- USAGE --- $id -> isEmpty (); // false $emptyId -> isEmpty (); // true $id -> equals ( new MyDomainId ( '1' )); // true $emptyId -> equals ( new MyDomainId ()); // false $emptyId -> equals ( $emptyId ); // true $id -> toString (); // \"1\" $emptyId -> toString (); // \"\" MsgPhp\\Domain\\Infra\\Uuid\\DomainIdTrait \u00b6 A UUID tailored domain identifier trait. Read more","title":"Identifiers"},{"location":"ddd/identifiers/#identifiers","text":"A domain identifier is a value object and bound to MsgPhp\\Domain\\DomainIdInterface . Its purpose is to utilize a primitive identifier value, usually used to identity an entity with.","title":"Identifiers"},{"location":"ddd/identifiers/#api","text":"","title":"API"},{"location":"ddd/identifiers/#static-fromvaluevalue-domainidinterface","text":"Returns a factorized identifier from any primitive value. Using null might imply an empty identifier.","title":"static fromValue($value): DomainIdInterface"},{"location":"ddd/identifiers/#isempty-bool","text":"Tells if an identifier value is considered empty, thus has no known primitive value.","title":"isEmpty(): bool"},{"location":"ddd/identifiers/#equalsdomainidinterface-id-bool","text":"Tells if an identifier strictly equals another identifier.","title":"equals(DomainIdInterface $id): bool"},{"location":"ddd/identifiers/#tostring-string-__tostring-string","text":"Returns the identifier its primitive string value. If the identifier is empty (see isEmpty() ) an empty string should be returned.","title":"toString(): string / __toString(): string"},{"location":"ddd/identifiers/#implementations","text":"","title":"Implementations"},{"location":"ddd/identifiers/#msgphpdomaindomainidtrait","text":"A first class citizen domain identifier trait.","title":"MsgPhp\\Domain\\DomainIdTrait"},{"location":"ddd/identifiers/#basic-example","text":"<?php use MsgPhp\\Domain\\ { DomainIdInterface , DomainIdTrait }; // --- SETUP --- final class MyDomainId implements DomainIdInterface { use DomainIdTrait ; } $id = new MyDomainId ( '1' ); $emptyId = new MyDomainId (); // --- USAGE --- $id -> isEmpty (); // false $emptyId -> isEmpty (); // true $id -> equals ( new MyDomainId ( '1' )); // true $emptyId -> equals ( new MyDomainId ()); // false $emptyId -> equals ( $emptyId ); // true $id -> toString (); // \"1\" $emptyId -> toString (); // \"\"","title":"Basic Example"},{"location":"ddd/identifiers/#msgphpdomaininfrauuiddomainidtrait","text":"A UUID tailored domain identifier trait. Read more","title":"MsgPhp\\Domain\\Infra\\Uuid\\DomainIdTrait"},{"location":"ddd/object-factory/","text":"Object Factory \u00b6 A domain object factory is bound to MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface . Its purpose is to initialize any domain object based on a given class name and context. API \u00b6 create(string $class, array $context = []): object \u00b6 Returns a factorized domain object by class name. Optionally a context can be provided for the factory to act upon. reference(string $class, array $context = []): object \u00b6 Returns a factorized domain reference object by class name. Optionally a context can be provided for the factory to act upon. Info Factorizing a reference should not trigger its constructor to be called, nor trigger any form of external loading getClass(string $class, array $context = []): string \u00b6 Returns the actual class name the factory uses for a given class name. Implementations \u00b6 MsgPhp\\Domain\\Factory\\DomainObjectFactory \u00b6 A generic object factory. It initializes a class by reading its constructor arguments. If the class is a sub class of MsgPhp\\Domain\\DomainIdInterface or MsgPhp\\Domain\\DomainCollectionInterface its static fromValue constructor will be used instead. Context elements mapped by argument name will be used as argument value. In case of a type-hinted object argument a nested context may be provided to initialize the object with. To map interfaces and abstract classes to concrete classes a global class mapping can be provided. __construct(array $classMapping = []) $classMapping : The class mapping ( ['SourceType' => 'TargetType'] )` setNestedFactory(?DomainObjectFactoryInterface $factory): void $factory : The factory to use for creating nested objects, or null to use the current instance Basic example \u00b6 <?php use MsgPhp\\Domain\\Factory\\DomainObjectFactory ; // --- SETUP --- interface KnownInterface { } class Some implements KnownInterface { public function __construct ( int $a , ? int $b , ? int $c ) { } } class Subject { public function __construct ( string $argument , KnownInterface $some , Subject $otherSubject = null ) { } } $factory = new DomainObjectFactory ([ KnownInterface :: class => Some :: class , ]); // --- USAGE --- /** @var Some $object */ $object = $factory -> create ( KnownInterface :: class , [ 'a' => 1 ]); $factory -> getClass ( KnownInterface :: class ); // \"Some\" /** @var Subject $object */ $object = $factory -> create ( Subject :: class , [ 'argument' => 'value' , 'some' => [ 'a' => 1 , 'b' => 2 ], 'otherSubject' => [ 'argument' => 'other value' , 'some' => [ 'a' => 1 ], ], ]); /** @var Subject $object */ $object = $factory -> reference ( Subject :: class ); Note DomainObjectFactory::reference() requires symfony/var-exporter MsgPhp\\Domain\\Infra\\Doctrine\\DomainObjectFactory \u00b6 A Doctrine tailored object factory. Read more","title":"Object Factory"},{"location":"ddd/object-factory/#object-factory","text":"A domain object factory is bound to MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface . Its purpose is to initialize any domain object based on a given class name and context.","title":"Object Factory"},{"location":"ddd/object-factory/#api","text":"","title":"API"},{"location":"ddd/object-factory/#createstring-class-array-context-object","text":"Returns a factorized domain object by class name. Optionally a context can be provided for the factory to act upon.","title":"create(string $class, array $context = []): object"},{"location":"ddd/object-factory/#referencestring-class-array-context-object","text":"Returns a factorized domain reference object by class name. Optionally a context can be provided for the factory to act upon. Info Factorizing a reference should not trigger its constructor to be called, nor trigger any form of external loading","title":"reference(string $class, array $context = []): object"},{"location":"ddd/object-factory/#getclassstring-class-array-context-string","text":"Returns the actual class name the factory uses for a given class name.","title":"getClass(string $class, array $context = []): string"},{"location":"ddd/object-factory/#implementations","text":"","title":"Implementations"},{"location":"ddd/object-factory/#msgphpdomainfactorydomainobjectfactory","text":"A generic object factory. It initializes a class by reading its constructor arguments. If the class is a sub class of MsgPhp\\Domain\\DomainIdInterface or MsgPhp\\Domain\\DomainCollectionInterface its static fromValue constructor will be used instead. Context elements mapped by argument name will be used as argument value. In case of a type-hinted object argument a nested context may be provided to initialize the object with. To map interfaces and abstract classes to concrete classes a global class mapping can be provided. __construct(array $classMapping = []) $classMapping : The class mapping ( ['SourceType' => 'TargetType'] )` setNestedFactory(?DomainObjectFactoryInterface $factory): void $factory : The factory to use for creating nested objects, or null to use the current instance","title":"MsgPhp\\Domain\\Factory\\DomainObjectFactory"},{"location":"ddd/object-factory/#basic-example","text":"<?php use MsgPhp\\Domain\\Factory\\DomainObjectFactory ; // --- SETUP --- interface KnownInterface { } class Some implements KnownInterface { public function __construct ( int $a , ? int $b , ? int $c ) { } } class Subject { public function __construct ( string $argument , KnownInterface $some , Subject $otherSubject = null ) { } } $factory = new DomainObjectFactory ([ KnownInterface :: class => Some :: class , ]); // --- USAGE --- /** @var Some $object */ $object = $factory -> create ( KnownInterface :: class , [ 'a' => 1 ]); $factory -> getClass ( KnownInterface :: class ); // \"Some\" /** @var Subject $object */ $object = $factory -> create ( Subject :: class , [ 'argument' => 'value' , 'some' => [ 'a' => 1 , 'b' => 2 ], 'otherSubject' => [ 'argument' => 'other value' , 'some' => [ 'a' => 1 ], ], ]); /** @var Subject $object */ $object = $factory -> reference ( Subject :: class ); Note DomainObjectFactory::reference() requires symfony/var-exporter","title":"Basic example"},{"location":"ddd/object-factory/#msgphpdomaininfradoctrinedomainobjectfactory","text":"A Doctrine tailored object factory. Read more","title":"MsgPhp\\Domain\\Infra\\Doctrine\\DomainObjectFactory"},{"location":"ddd/repositories/","text":"Repositories \u00b6 A domain repository is tied to specific domain entities . To define a repository for them you can leverage a utility trait tied to specific infrastructure (e.g. Doctrine ORM ). This page describes the API provided by default implementations . API \u00b6 doFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface \u00b6 Finds all entities available. An unlimited collection is implied by $limit set to zero. doFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface \u00b6 Finds all entities matching the specified fields. Supported field values should be null , scalar , scalar[] (i.e. one of) and object (i.e. another entity or its identifier ). An unlimited collection is implied by $limit set to zero. doFind($id): object \u00b6 Finds a single entity by its identity. Supported identity values should be scalar , array (for composite identifiers), and object (i.e. another entity or its identifier ). doFindByFields(array $fields): object \u00b6 Finds the first entity matching the specified fields. See doFindAllByFields() for supported field values. doExists($id): bool \u00b6 Verifies if an entity exists by its identity. See doFind() for supported identity values. doExistsByFields(array $fields): bool \u00b6 Verifies if an entity matching the specified fields exists. See doFindAllByFields() for supported field values. doSave(object $entity): void \u00b6 Persists an entity into the identity map. The entity will be available on any subsequent query. doDelete(object $entity): void \u00b6 Removes an entity from the identity map. The entity will be unavailable on any subsequent query. Implementations \u00b6 MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait \u00b6 A Doctrine tailored repository trait. Read more","title":"Repositories"},{"location":"ddd/repositories/#repositories","text":"A domain repository is tied to specific domain entities . To define a repository for them you can leverage a utility trait tied to specific infrastructure (e.g. Doctrine ORM ). This page describes the API provided by default implementations .","title":"Repositories"},{"location":"ddd/repositories/#api","text":"","title":"API"},{"location":"ddd/repositories/#dofindallint-offset-0-int-limit-0-domaincollectioninterface","text":"Finds all entities available. An unlimited collection is implied by $limit set to zero.","title":"doFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface"},{"location":"ddd/repositories/#dofindallbyfieldsarray-fields-int-offset-0-int-limit-0-domaincollectioninterface","text":"Finds all entities matching the specified fields. Supported field values should be null , scalar , scalar[] (i.e. one of) and object (i.e. another entity or its identifier ). An unlimited collection is implied by $limit set to zero.","title":"doFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface"},{"location":"ddd/repositories/#dofindid-object","text":"Finds a single entity by its identity. Supported identity values should be scalar , array (for composite identifiers), and object (i.e. another entity or its identifier ).","title":"doFind($id): object"},{"location":"ddd/repositories/#dofindbyfieldsarray-fields-object","text":"Finds the first entity matching the specified fields. See doFindAllByFields() for supported field values.","title":"doFindByFields(array $fields): object"},{"location":"ddd/repositories/#doexistsid-bool","text":"Verifies if an entity exists by its identity. See doFind() for supported identity values.","title":"doExists($id): bool"},{"location":"ddd/repositories/#doexistsbyfieldsarray-fields-bool","text":"Verifies if an entity matching the specified fields exists. See doFindAllByFields() for supported field values.","title":"doExistsByFields(array $fields): bool"},{"location":"ddd/repositories/#dosaveobject-entity-void","text":"Persists an entity into the identity map. The entity will be available on any subsequent query.","title":"doSave(object $entity): void"},{"location":"ddd/repositories/#dodeleteobject-entity-void","text":"Removes an entity from the identity map. The entity will be unavailable on any subsequent query.","title":"doDelete(object $entity): void"},{"location":"ddd/repositories/#implementations","text":"","title":"Implementations"},{"location":"ddd/repositories/#msgphpdomaininfradoctrinedomainentityrepositorytrait","text":"A Doctrine tailored repository trait. Read more","title":"MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait"},{"location":"event-sourcing/event-handlers/","text":"Event Handlers \u00b6 A domain event handler is bound to MsgPhp\\Domain\\Event\\DomainEventHandlerInterface . Its purpose is to implement the handling of domain events within a certain context. Usually an entity implements it in order to mutate its own state (i.e. self-handling). It enforces the entity state to be valid by design as it encapsulates all write operations. In practice domain events can be recorded on trigger, or privately within the implementation. It allows to re-play them at any point in time afterwards. Consider this a design choice to be made upfront, e.g. in case your entity design requires its history to be accessible. API \u00b6 handleEvent(DomainEventInterface $event): bool \u00b6 Handles the given domain event for a known subject. A boolean return value tells if the domain event is actually handled yes or no. Implementations \u00b6 MsgPhp\\Domain\\Event\\DomainEventHandlerTrait \u00b6 A utility trait implementing the event handler API. By convention it maps events to handle<Event_Class_Name_Without_Event_Suffix>Event() methods. Basic Example \u00b6 <?php use MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface , DomainEventHandlerTrait , DomainEventInterface }; // --- SETUP --- class MyDomainEvent implements DomainEventInterface { public $newValue ; public function __construct ( $value ) { $this -> newValue = $value ; } } class MyEntity implements DomainEventHandlerInterface { use DomainEventHandlerTrait ; public $value ; private function handleMyDomainEvent ( MyDomainEvent $event ) : bool { if ( $this -> value === $event -> newValue ) { return false ; } $this -> value = $event -> newValue ; return true ; } } // --- USAGE --- $entity = new MyEntity (); if ( $entity -> handleEvent ( new MyDomainEvent ( 'new value' ))) { // do something }","title":"Event Handlers"},{"location":"event-sourcing/event-handlers/#event-handlers","text":"A domain event handler is bound to MsgPhp\\Domain\\Event\\DomainEventHandlerInterface . Its purpose is to implement the handling of domain events within a certain context. Usually an entity implements it in order to mutate its own state (i.e. self-handling). It enforces the entity state to be valid by design as it encapsulates all write operations. In practice domain events can be recorded on trigger, or privately within the implementation. It allows to re-play them at any point in time afterwards. Consider this a design choice to be made upfront, e.g. in case your entity design requires its history to be accessible.","title":"Event Handlers"},{"location":"event-sourcing/event-handlers/#api","text":"","title":"API"},{"location":"event-sourcing/event-handlers/#handleeventdomaineventinterface-event-bool","text":"Handles the given domain event for a known subject. A boolean return value tells if the domain event is actually handled yes or no.","title":"handleEvent(DomainEventInterface $event): bool"},{"location":"event-sourcing/event-handlers/#implementations","text":"","title":"Implementations"},{"location":"event-sourcing/event-handlers/#msgphpdomaineventdomaineventhandlertrait","text":"A utility trait implementing the event handler API. By convention it maps events to handle<Event_Class_Name_Without_Event_Suffix>Event() methods.","title":"MsgPhp\\Domain\\Event\\DomainEventHandlerTrait"},{"location":"event-sourcing/event-handlers/#basic-example","text":"<?php use MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface , DomainEventHandlerTrait , DomainEventInterface }; // --- SETUP --- class MyDomainEvent implements DomainEventInterface { public $newValue ; public function __construct ( $value ) { $this -> newValue = $value ; } } class MyEntity implements DomainEventHandlerInterface { use DomainEventHandlerTrait ; public $value ; private function handleMyDomainEvent ( MyDomainEvent $event ) : bool { if ( $this -> value === $event -> newValue ) { return false ; } $this -> value = $event -> newValue ; return true ; } } // --- USAGE --- $entity = new MyEntity (); if ( $entity -> handleEvent ( new MyDomainEvent ( 'new value' ))) { // do something }","title":"Basic Example"},{"location":"event-sourcing/events/","text":"Events \u00b6 A domain event is bound to MsgPhp\\Domain\\Event\\DomainEventInterface . Its purpose is to represent any action that can happen regarding the domain. When handled it might lead to an application state change. API \u00b6 Note This is a marker interface and has no default API Implementations \u00b6 MsgPhp\\Domain\\Event\\ConfirmEvent MsgPhp\\Domain\\Event\\DisableEvent MsgPhp\\Domain\\Event\\EnableEvent Basic Example \u00b6 <?php use MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled ; use MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface , DomainEventHandlerTrait , EnableEvent }; // --- SETUP --- class MyEntity implements DomainEventHandlerInterface { use CanBeEnabled ; use DomainEventHandlerTrait ; } // --- USAGE --- $entity = new MyEntity (); $entity -> isEnabled (); // false $entity -> handleEvent ( new EnableEvent ()); // true $entity -> handleEvent ( new EnableEvent ()); // false $entity -> isEnabled (); // true Note Because CanBeEnabled defines handleEnableEvent(EnableEvent $event) it's detected in DomainEventHandlerTrait::handleEvent() by convention","title":"Events"},{"location":"event-sourcing/events/#events","text":"A domain event is bound to MsgPhp\\Domain\\Event\\DomainEventInterface . Its purpose is to represent any action that can happen regarding the domain. When handled it might lead to an application state change.","title":"Events"},{"location":"event-sourcing/events/#api","text":"Note This is a marker interface and has no default API","title":"API"},{"location":"event-sourcing/events/#implementations","text":"MsgPhp\\Domain\\Event\\ConfirmEvent MsgPhp\\Domain\\Event\\DisableEvent MsgPhp\\Domain\\Event\\EnableEvent","title":"Implementations"},{"location":"event-sourcing/events/#basic-example","text":"<?php use MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled ; use MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface , DomainEventHandlerTrait , EnableEvent }; // --- SETUP --- class MyEntity implements DomainEventHandlerInterface { use CanBeEnabled ; use DomainEventHandlerTrait ; } // --- USAGE --- $entity = new MyEntity (); $entity -> isEnabled (); // false $entity -> handleEvent ( new EnableEvent ()); // true $entity -> handleEvent ( new EnableEvent ()); // false $entity -> isEnabled (); // true Note Because CanBeEnabled defines handleEnableEvent(EnableEvent $event) it's detected in DomainEventHandlerTrait::handleEvent() by convention","title":"Basic Example"},{"location":"infrastructure/api-platform/","text":"API Platform \u00b6 An overview of available infrastructural code when using API Platform . Requires api-platform/core Projection Data Provider \u00b6 When working with projections an API Data Provider is provided by MsgPhp\\Domain\\Infra\\ApiPlatform\\ProjectionDataProvider . It uses any projection repository in an effort to provide API resources. Minimal Configuration \u00b6 api_platform : # ... resource_class_directories : - '%kernel.project_dir%/src/Api/Projection' services : # .. . MsgPhp\\Domain\\Infra\\ApiPlatform\\ProjectionDataProvider : tags : [ api_platform.collection_data_provider ] autowire : true Note See also API Platform Configuration documentation Basic Example \u00b6 <?php namespace App\\Api\\Projection ; use ApiPlatform\\Core\\Annotation\\ApiProperty ; use ApiPlatform\\Core\\Annotation\\ApiResource ; use MsgPhp\\Domain\\Projection\\ProjectionInterface ; /** * @ApiResource(shortName=\"Some\") */ class SomeProjection implements ProjectionInterface { /** * @ApiProperty(identifier=true) */ public $id ; public static function fromDocument ( array $document ) : ProjectionInterface { $projection = new self (); $projection -> id = $document [ 'id' ] ?? null ; return $projection ; } }","title":"API Platform"},{"location":"infrastructure/api-platform/#api-platform","text":"An overview of available infrastructural code when using API Platform . Requires api-platform/core","title":"API Platform"},{"location":"infrastructure/api-platform/#projection-data-provider","text":"When working with projections an API Data Provider is provided by MsgPhp\\Domain\\Infra\\ApiPlatform\\ProjectionDataProvider . It uses any projection repository in an effort to provide API resources.","title":"Projection Data Provider"},{"location":"infrastructure/api-platform/#minimal-configuration","text":"api_platform : # ... resource_class_directories : - '%kernel.project_dir%/src/Api/Projection' services : # .. . MsgPhp\\Domain\\Infra\\ApiPlatform\\ProjectionDataProvider : tags : [ api_platform.collection_data_provider ] autowire : true Note See also API Platform Configuration documentation","title":"Minimal Configuration"},{"location":"infrastructure/api-platform/#basic-example","text":"<?php namespace App\\Api\\Projection ; use ApiPlatform\\Core\\Annotation\\ApiProperty ; use ApiPlatform\\Core\\Annotation\\ApiResource ; use MsgPhp\\Domain\\Projection\\ProjectionInterface ; /** * @ApiResource(shortName=\"Some\") */ class SomeProjection implements ProjectionInterface { /** * @ApiProperty(identifier=true) */ public $id ; public static function fromDocument ( array $document ) : ProjectionInterface { $projection = new self (); $projection -> id = $document [ 'id' ] ?? null ; return $projection ; } }","title":"Basic Example"},{"location":"infrastructure/doctrine-collections/","text":"Doctrine Collections \u00b6 An overview of available infrastructural code when using Doctrine's Collections . Requires doctrine/collections Domain Collection \u00b6 A Doctrine tailored domain collection is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection . Basic Example \u00b6 <?php use Doctrine\\Common\\Collections\\ArrayCollection ; use MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection ; // --- SETUP --- $collection = new DomainCollection ( new ArrayCollection ([ 1 , 2 , 3 ]));","title":"Doctrine Collections"},{"location":"infrastructure/doctrine-collections/#doctrine-collections","text":"An overview of available infrastructural code when using Doctrine's Collections . Requires doctrine/collections","title":"Doctrine Collections"},{"location":"infrastructure/doctrine-collections/#domain-collection","text":"A Doctrine tailored domain collection is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection .","title":"Domain Collection"},{"location":"infrastructure/doctrine-collections/#basic-example","text":"<?php use Doctrine\\Common\\Collections\\ArrayCollection ; use MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection ; // --- SETUP --- $collection = new DomainCollection ( new ArrayCollection ([ 1 , 2 , 3 ]));","title":"Basic Example"},{"location":"infrastructure/doctrine-dbal/","text":"Doctrine Database Abstraction Layer \u00b6 An overview of available infrastructural code when using Doctrine's Database Abstraction Layer . Requires doctrine/dbal Domain Identifier Type \u00b6 A translation between the database type and an identifier type in PHP is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdType . Basic Example \u00b6 <?php use Doctrine\\DBAL\\Types\\Type ; use MsgPhp\\Domain\\DomainId ; use MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdType ; // --- SETUP --- class MyDomainId extends DomainId { } class MyDomainIdType extends DomainIdType { public const NAME = 'my_domain_id' ; } // --- USAGE --- MyDomainIdType :: setClass ( MyDomainId :: class ); MyDomainIdType :: setDataType ( Type :: GUID ); Type :: addType ( MyDomainIdType :: NAME , MyDomainIdType :: class ); To leverage the tailored UUID identifier use a data type from ramsey/uuid-doctrine instead. <?php use MsgPhp\\Domain\\Infra\\Uuid\\DomainId as DomainUuid ; use Ramsey\\Uuid\\Doctrine\\UuidType ; MyDomainIdType :: setClass ( DomainUuid :: class ); MyDomainIdType :: setDataType ( UuidType :: NAME );","title":"Doctrine DBAL"},{"location":"infrastructure/doctrine-dbal/#doctrine-database-abstraction-layer","text":"An overview of available infrastructural code when using Doctrine's Database Abstraction Layer . Requires doctrine/dbal","title":"Doctrine Database Abstraction Layer"},{"location":"infrastructure/doctrine-dbal/#domain-identifier-type","text":"A translation between the database type and an identifier type in PHP is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdType .","title":"Domain Identifier Type"},{"location":"infrastructure/doctrine-dbal/#basic-example","text":"<?php use Doctrine\\DBAL\\Types\\Type ; use MsgPhp\\Domain\\DomainId ; use MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdType ; // --- SETUP --- class MyDomainId extends DomainId { } class MyDomainIdType extends DomainIdType { public const NAME = 'my_domain_id' ; } // --- USAGE --- MyDomainIdType :: setClass ( MyDomainId :: class ); MyDomainIdType :: setDataType ( Type :: GUID ); Type :: addType ( MyDomainIdType :: NAME , MyDomainIdType :: class ); To leverage the tailored UUID identifier use a data type from ramsey/uuid-doctrine instead. <?php use MsgPhp\\Domain\\Infra\\Uuid\\DomainId as DomainUuid ; use Ramsey\\Uuid\\Doctrine\\UuidType ; MyDomainIdType :: setClass ( DomainUuid :: class ); MyDomainIdType :: setDataType ( UuidType :: NAME );","title":"Basic Example"},{"location":"infrastructure/doctrine-orm/","text":"Doctrine Object Relational Mapper \u00b6 An overview of available infrastructural code when using Doctrine's Object Relational Mapper . Requires doctrine/orm Domain Repository \u00b6 A Doctrine tailored repository trait is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait . Basic Example \u00b6 <?php use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait ; // --- SETUP --- /** @ORM\\Entity() */ class MyEntity { /** @ORM\\Id() @ORM\\Column(type=\"string\") */ public $name ; /** @ORM\\Id() @ORM\\Column(type=\"integer\") */ public $year ; } class MyEntityRepository { use DomainEntityRepositoryTrait { doFind as public find ; doExists as public exists ; doSave as public save ; } } /** @var EntityManagerInterface $em */ $em = ... ; $repository = new MyEntityRepository ( MyEntity :: class , $em ); // --- USAGE --- if ( $repository -> exists ( $id = [ 'name' => ... , 'year' => ... ])) { $entity = $repository -> find ( $id ); } else { $entity = new MyEntity (); $entity -> name = ... ; $entity -> year = ... ; $repository -> save ( $entity ); } Domain Object Factory \u00b6 A Doctrine tailored object factory is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainObjectFactory . When working with ORM inheritance the discriminator field can be provided to factorize a specific entity type. Basic Example \u00b6 <?php use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Factory\\DomainObjectFactory as BaseDomainObjectFactory ; use MsgPhp\\Domain\\Infra\\Doctrine\\ { DomainIdentityMapping , DomainObjectFactory }; // --- SETUP --- /** * @ORM\\Entity() * @ORM\\InheritanceType(\"JOINED\") * @ORM\\DiscriminatorColumn(name=\"discriminator\", type=\"string\") * @ORM\\DiscriminatorMap({\"self\" = \"MyEntity\", \"other\" = \"MyOtherEntity\"}) */ class MyEntity { public const TYPE_SELF = 'self' ; public const TYPE_OTHER = 'other' ; /** @ORM\\Id() @ORM\\Column(type=\"integer\") */ public $id ; } /** @ORM\\Entity */ class MyOtherEntity extends MyEntity { } /** @var EntityManagerInterface $em */ $em = ... ; $factory = new DomainObjectFactory ( new BaseDomainObjectFactory (), $em ); // --- USAGE --- /** @var MyOtherEntity $otherEntity */ $otherEntity = $factory -> create ( MyEntity :: class , [ 'discriminator' => MyEntity :: TYPE_OTHER , ]); Domain Identifier Hydration \u00b6 When working with domain identifiers and its corresponding type a problem can occur when hydrating scalar values, e.g. with Query::getScalarResult() . It would use instances of MsgPhp\\Domain\\DomainIdInterface that can only be casted to string as its (true) scalar value (due to __toString() ). In case the underlying data type is e.g. integer it will be lost. To overcome, two hydration modes are available to hydrate the primitive identifier value instead. Basic Example \u00b6 <?php use Doctrine\\DBAL\\Types\\Type ; use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\DomainId ; use MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdType ; use MsgPhp\\Domain\\Infra\\Doctrine\\Hydration\\ { ScalarHydrator , SingleScalarHydrator }; // --- SETUP --- /** @ORM\\Entity() */ class MyEntity { /** @var DomainId @ORM\\Id() @ORM\\Column(type=\"msgphp_domain_id\") */ public $id ; } DomainIdType :: setClass ( DomainId :: class ); DomainIdType :: setDataType ( Type :: INTEGER ); Type :: addType ( DomainIdType :: NAME , DomainIdType :: class ); /** @var EntityManagerInterface $em */ $em = ... ; $config = $em -> getConfiguration (); $config -> addCustomHydrationMode ( ScalarHydrator :: NAME , ScalarHydrator :: class ); $config -> addCustomHydrationMode ( SingleScalarHydrator :: NAME , SingleScalarHydrator :: class ); // --- USAGE --- $query = $em -> createQuery ( 'SELECT entity.id FROM MyEntity entity' ); $query -> getScalarResult ()[ 0 ][ 'id' ]; // \"1\" $query -> getResult ( ScalarHydrator :: NAME )[ 0 ][ 'id' ]; // int(1) $query -> getSingleScalarResult (); // \"1\" $query -> getSingleResult ( SingleScalarHydrator :: NAME ); // int(1)","title":"Doctrine ORM"},{"location":"infrastructure/doctrine-orm/#doctrine-object-relational-mapper","text":"An overview of available infrastructural code when using Doctrine's Object Relational Mapper . Requires doctrine/orm","title":"Doctrine Object Relational Mapper"},{"location":"infrastructure/doctrine-orm/#domain-repository","text":"A Doctrine tailored repository trait is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait .","title":"Domain Repository"},{"location":"infrastructure/doctrine-orm/#basic-example","text":"<?php use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait ; // --- SETUP --- /** @ORM\\Entity() */ class MyEntity { /** @ORM\\Id() @ORM\\Column(type=\"string\") */ public $name ; /** @ORM\\Id() @ORM\\Column(type=\"integer\") */ public $year ; } class MyEntityRepository { use DomainEntityRepositoryTrait { doFind as public find ; doExists as public exists ; doSave as public save ; } } /** @var EntityManagerInterface $em */ $em = ... ; $repository = new MyEntityRepository ( MyEntity :: class , $em ); // --- USAGE --- if ( $repository -> exists ( $id = [ 'name' => ... , 'year' => ... ])) { $entity = $repository -> find ( $id ); } else { $entity = new MyEntity (); $entity -> name = ... ; $entity -> year = ... ; $repository -> save ( $entity ); }","title":"Basic Example"},{"location":"infrastructure/doctrine-orm/#domain-object-factory","text":"A Doctrine tailored object factory is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainObjectFactory . When working with ORM inheritance the discriminator field can be provided to factorize a specific entity type.","title":"Domain Object Factory"},{"location":"infrastructure/doctrine-orm/#basic-example_1","text":"<?php use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Factory\\DomainObjectFactory as BaseDomainObjectFactory ; use MsgPhp\\Domain\\Infra\\Doctrine\\ { DomainIdentityMapping , DomainObjectFactory }; // --- SETUP --- /** * @ORM\\Entity() * @ORM\\InheritanceType(\"JOINED\") * @ORM\\DiscriminatorColumn(name=\"discriminator\", type=\"string\") * @ORM\\DiscriminatorMap({\"self\" = \"MyEntity\", \"other\" = \"MyOtherEntity\"}) */ class MyEntity { public const TYPE_SELF = 'self' ; public const TYPE_OTHER = 'other' ; /** @ORM\\Id() @ORM\\Column(type=\"integer\") */ public $id ; } /** @ORM\\Entity */ class MyOtherEntity extends MyEntity { } /** @var EntityManagerInterface $em */ $em = ... ; $factory = new DomainObjectFactory ( new BaseDomainObjectFactory (), $em ); // --- USAGE --- /** @var MyOtherEntity $otherEntity */ $otherEntity = $factory -> create ( MyEntity :: class , [ 'discriminator' => MyEntity :: TYPE_OTHER , ]);","title":"Basic Example"},{"location":"infrastructure/doctrine-orm/#domain-identifier-hydration","text":"When working with domain identifiers and its corresponding type a problem can occur when hydrating scalar values, e.g. with Query::getScalarResult() . It would use instances of MsgPhp\\Domain\\DomainIdInterface that can only be casted to string as its (true) scalar value (due to __toString() ). In case the underlying data type is e.g. integer it will be lost. To overcome, two hydration modes are available to hydrate the primitive identifier value instead.","title":"Domain Identifier Hydration"},{"location":"infrastructure/doctrine-orm/#basic-example_2","text":"<?php use Doctrine\\DBAL\\Types\\Type ; use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\DomainId ; use MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdType ; use MsgPhp\\Domain\\Infra\\Doctrine\\Hydration\\ { ScalarHydrator , SingleScalarHydrator }; // --- SETUP --- /** @ORM\\Entity() */ class MyEntity { /** @var DomainId @ORM\\Id() @ORM\\Column(type=\"msgphp_domain_id\") */ public $id ; } DomainIdType :: setClass ( DomainId :: class ); DomainIdType :: setDataType ( Type :: INTEGER ); Type :: addType ( DomainIdType :: NAME , DomainIdType :: class ); /** @var EntityManagerInterface $em */ $em = ... ; $config = $em -> getConfiguration (); $config -> addCustomHydrationMode ( ScalarHydrator :: NAME , ScalarHydrator :: class ); $config -> addCustomHydrationMode ( SingleScalarHydrator :: NAME , SingleScalarHydrator :: class ); // --- USAGE --- $query = $em -> createQuery ( 'SELECT entity.id FROM MyEntity entity' ); $query -> getScalarResult ()[ 0 ][ 'id' ]; // \"1\" $query -> getResult ( ScalarHydrator :: NAME )[ 0 ][ 'id' ]; // int(1) $query -> getSingleScalarResult (); // \"1\" $query -> getSingleResult ( SingleScalarHydrator :: NAME ); // int(1)","title":"Basic Example"},{"location":"infrastructure/elasticsearch/","text":"Elasticsearch \u00b6 An overview of available infrastructural code when using Elasticsearch's PHP Api . Requires elasticsearch/elasticsearch Projection Type Registry \u00b6 An Elasticsearch tailored projection type registry is provided by MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionTypeRegistry . It works directly with any Client and a known configuration of type information. __construct(Client $client, string $index, array $mappings, array $settings = [], LoggerInterface $logger = null) $client : The client to work with $index : The index to use $mappings / $settings : Index management information. Read more . $logger : An optional PSR logger Basic Example \u00b6 <?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionTypeRegistry ; use MsgPhp\\Domain\\Projection\\ProjectionInterface ; // --- SETUP --- class MyProjection implements ProjectionInterface { public $someField ; public $otherField ; public static function fromDocument ( array $document ) : ProjectionInterface { $projection = new static (); $projection -> someField = $document [ 'some_field' ] ?? null ; $projection -> otherField = $document [ 'other_field' ] ?? null ; return $projection ; } } /** @var Client $client */ $client = ... ; $typeRegistry = new ProjectionTypeRegistry ( $client , 'some_index' , [ MyProjection :: class => [ 'some_field' => 'some_type' , // defaults to ['type' => 'some_type'] 'other_field' => [ // defaults to ['type' => 'text', ...] // ... ], ], ]); Advanced Mapping Example \u00b6 <?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infra\\Elasticsearch\\ { DocumentMappingProviderInterface , ProjectionTypeRegistry }; use MsgPhp\\Domain\\Projection\\ProjectionInterface ; // --- SETUP --- class MyProjection implements ProjectionInterface , DocumentMappingProviderInterface { // ... public static function fromDocument ( array $document ) : ProjectionInterface { // ... } public static function provideDocumentMappings () : iterable { yield static :: class => [ 'some_field' => 'some_type' , 'other_field' => [ // ... ], ]; } } /** @var Client $client */ $client = ... ; $typeRegistry = new ProjectionTypeRegistry ( $client , 'some_index' , [ MyProjection :: class , ]); Projection Repository \u00b6 An Elasticsearch tailored projection repository is provided by MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionRepository . It works directly with any Client . __construct(Client $client, string $index) $client : The Client to work with $index : The index to use Basic Example \u00b6 <?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionRepository ; // --- SETUP --- /** @var Client $client */ $client = ... ; $repository = new ProjectionRepository ( $client , 'some_index' );","title":"Elasticsearch"},{"location":"infrastructure/elasticsearch/#elasticsearch","text":"An overview of available infrastructural code when using Elasticsearch's PHP Api . Requires elasticsearch/elasticsearch","title":"Elasticsearch"},{"location":"infrastructure/elasticsearch/#projection-type-registry","text":"An Elasticsearch tailored projection type registry is provided by MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionTypeRegistry . It works directly with any Client and a known configuration of type information. __construct(Client $client, string $index, array $mappings, array $settings = [], LoggerInterface $logger = null) $client : The client to work with $index : The index to use $mappings / $settings : Index management information. Read more . $logger : An optional PSR logger","title":"Projection Type Registry"},{"location":"infrastructure/elasticsearch/#basic-example","text":"<?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionTypeRegistry ; use MsgPhp\\Domain\\Projection\\ProjectionInterface ; // --- SETUP --- class MyProjection implements ProjectionInterface { public $someField ; public $otherField ; public static function fromDocument ( array $document ) : ProjectionInterface { $projection = new static (); $projection -> someField = $document [ 'some_field' ] ?? null ; $projection -> otherField = $document [ 'other_field' ] ?? null ; return $projection ; } } /** @var Client $client */ $client = ... ; $typeRegistry = new ProjectionTypeRegistry ( $client , 'some_index' , [ MyProjection :: class => [ 'some_field' => 'some_type' , // defaults to ['type' => 'some_type'] 'other_field' => [ // defaults to ['type' => 'text', ...] // ... ], ], ]);","title":"Basic Example"},{"location":"infrastructure/elasticsearch/#advanced-mapping-example","text":"<?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infra\\Elasticsearch\\ { DocumentMappingProviderInterface , ProjectionTypeRegistry }; use MsgPhp\\Domain\\Projection\\ProjectionInterface ; // --- SETUP --- class MyProjection implements ProjectionInterface , DocumentMappingProviderInterface { // ... public static function fromDocument ( array $document ) : ProjectionInterface { // ... } public static function provideDocumentMappings () : iterable { yield static :: class => [ 'some_field' => 'some_type' , 'other_field' => [ // ... ], ]; } } /** @var Client $client */ $client = ... ; $typeRegistry = new ProjectionTypeRegistry ( $client , 'some_index' , [ MyProjection :: class , ]);","title":"Advanced Mapping Example"},{"location":"infrastructure/elasticsearch/#projection-repository","text":"An Elasticsearch tailored projection repository is provided by MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionRepository . It works directly with any Client . __construct(Client $client, string $index) $client : The Client to work with $index : The index to use","title":"Projection Repository"},{"location":"infrastructure/elasticsearch/#basic-example_1","text":"<?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionRepository ; // --- SETUP --- /** @var Client $client */ $client = ... ; $repository = new ProjectionRepository ( $client , 'some_index' );","title":"Basic Example"},{"location":"infrastructure/symfony-console/","text":"Symfony Console \u00b6 An overview of available infrastructural code when using Symfony Console . Requires symfony/console Commands \u00b6 Various standard console commands are available and can be used depending on implemented domain infrastructure. They are defined in the MsgPhp\\Domain\\Infra\\Console\\Command\\ namespace. InitializeProjectionTypesCommand \u00b6 Initializes the projection type registry . bin/console projection:initialize-types [ --force ] SynchronizeProjectionsCommand \u00b6 Synchronizes domain objects and their projections using the projection synchronization utility service. bin/console projection:synchronize Context Factory \u00b6 A context factory is bound to MsgPhp\\Domain\\Infra\\Console\\Context\\ContextFactoryInterface . Its purpose is to leverage a CLI command in an effort to interactively built an arbitrary array value (the context). API \u00b6 configure(InputDefinition $definition): void \u00b6 Configures a command input definition. See also InputDefinition . Should be called before using getContext() . getContext(InputInterface $input, StyleInterface $io, array $values = []): array \u00b6 Resolves the actual context from the console IO. See also InputInterface and StyleInterface . Any element value provided by $values takes precedence and should be used as-is. Implementations \u00b6 MsgPhp\\Domain\\Infra\\Console\\Context\\ClassContextFactory \u00b6 Factorizes a context based on any class method signature. It configures the CLI signature by mapping required class method arguments to command arguments, whereas optional ones are mapped to command options. bin/console command --optional-argument [ -- ] required-argument In both cases a value is optional, if the actual class method argument is required and no value is given it will be asked interactively. If interaction is not possible an exception will be thrown instead. __construct(string $class, string $method, array $classMapping = [], int $flags = 0, ClassContextElementFactoryInterface $elementFactory = null) $class / $method : The class method to resolve $classMapping : Global class mapping. Usually used to map abstracts to concretes. $flags : A bit mask value to toggle various flags ClassContextBuilder::ALWAYS_OPTIONAL : Always map class method arguments to command options ClassContextBuilder::NO_DEFAULTS : Leave out default values when calling getContext() ClassContextBuilder::REUSE_DEFINITION : Reuse the original input definition for matching class method arguments $elementFactory : A custom element factory to use. See also Customizing context elements . Customizing Context Elements \u00b6 Per-element configuration can be provided by implementing a MsgPhp\\Domain\\Infra\\Console\\Context\\ClassContextElementFactoryInterface . getElement(string $class, string $method, string $argument): ContextElement Get a custom ContextElement to apply to a specific class/method/argument pair A default implementation is provided by MsgPhp\\Domain\\Infra\\Console\\Context\\ClassContextElementFactory which simply transforms argument names to human readable values so that $argumentName becomes Argument Name . Basic Example \u00b6 <?php use MsgPhp\\Domain\\Infra\\Console\\Context\\ClassContextFactory ; use Symfony\\Component\\Console\\Command\\Command ; use Symfony\\Component\\Console\\Input\\InputInterface ; use Symfony\\Component\\Console\\Output\\OutputInterface ; use Symfony\\Component\\Console\\Style\\SymfonyStyle ; // --- SETUP --- class MyObject { public function __construct ( string $argument , $option = null ) { } } class MyCommand extends Command { private $contextFactory ; public function __construct () { $this -> contextFactory = new ClassContextFactory ( MyObject :: class , '__construct' ); parent :: __construct (); } protected function configure () : void { $this -> setName ( 'my-command' ); $this -> contextFactory -> configure ( $this -> getDefinition ()); } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $io = new SymfonyStyle ( $input , $output ); $context = $this -> contextFactory -> getContext ( $input , $io ); $object = new MyObject ( ... array_values ( $context )); // do something return 0 ; } } // --- USAGE --- // $ bin/console my-command [--option=OPTION] [--] [<argument>] MsgPhp\\Domain\\Infra\\Console\\Context\\DoctrineEntityContextFactory \u00b6 A Doctrine entity aware context factory. It decorates any context factory. Its purpose is to provide a discriminator value into the resulting context when working with ORM inheritance . __construct(ContextFactoryInterface $factory, EntityManagerInterface $em, string $class) $factory : The decorated context factory $em : The entity manager to use $class : The entity class to use","title":"Symfony Console"},{"location":"infrastructure/symfony-console/#symfony-console","text":"An overview of available infrastructural code when using Symfony Console . Requires symfony/console","title":"Symfony Console"},{"location":"infrastructure/symfony-console/#commands","text":"Various standard console commands are available and can be used depending on implemented domain infrastructure. They are defined in the MsgPhp\\Domain\\Infra\\Console\\Command\\ namespace.","title":"Commands"},{"location":"infrastructure/symfony-console/#initializeprojectiontypescommand","text":"Initializes the projection type registry . bin/console projection:initialize-types [ --force ]","title":"InitializeProjectionTypesCommand"},{"location":"infrastructure/symfony-console/#synchronizeprojectionscommand","text":"Synchronizes domain objects and their projections using the projection synchronization utility service. bin/console projection:synchronize","title":"SynchronizeProjectionsCommand"},{"location":"infrastructure/symfony-console/#context-factory","text":"A context factory is bound to MsgPhp\\Domain\\Infra\\Console\\Context\\ContextFactoryInterface . Its purpose is to leverage a CLI command in an effort to interactively built an arbitrary array value (the context).","title":"Context Factory"},{"location":"infrastructure/symfony-console/#api","text":"","title":"API"},{"location":"infrastructure/symfony-console/#configureinputdefinition-definition-void","text":"Configures a command input definition. See also InputDefinition . Should be called before using getContext() .","title":"configure(InputDefinition $definition): void"},{"location":"infrastructure/symfony-console/#getcontextinputinterface-input-styleinterface-io-array-values-array","text":"Resolves the actual context from the console IO. See also InputInterface and StyleInterface . Any element value provided by $values takes precedence and should be used as-is.","title":"getContext(InputInterface $input, StyleInterface $io, array $values = []): array"},{"location":"infrastructure/symfony-console/#implementations","text":"","title":"Implementations"},{"location":"infrastructure/symfony-console/#msgphpdomaininfraconsolecontextclasscontextfactory","text":"Factorizes a context based on any class method signature. It configures the CLI signature by mapping required class method arguments to command arguments, whereas optional ones are mapped to command options. bin/console command --optional-argument [ -- ] required-argument In both cases a value is optional, if the actual class method argument is required and no value is given it will be asked interactively. If interaction is not possible an exception will be thrown instead. __construct(string $class, string $method, array $classMapping = [], int $flags = 0, ClassContextElementFactoryInterface $elementFactory = null) $class / $method : The class method to resolve $classMapping : Global class mapping. Usually used to map abstracts to concretes. $flags : A bit mask value to toggle various flags ClassContextBuilder::ALWAYS_OPTIONAL : Always map class method arguments to command options ClassContextBuilder::NO_DEFAULTS : Leave out default values when calling getContext() ClassContextBuilder::REUSE_DEFINITION : Reuse the original input definition for matching class method arguments $elementFactory : A custom element factory to use. See also Customizing context elements .","title":"MsgPhp\\Domain\\Infra\\Console\\Context\\ClassContextFactory"},{"location":"infrastructure/symfony-console/#customizing-context-elements","text":"Per-element configuration can be provided by implementing a MsgPhp\\Domain\\Infra\\Console\\Context\\ClassContextElementFactoryInterface . getElement(string $class, string $method, string $argument): ContextElement Get a custom ContextElement to apply to a specific class/method/argument pair A default implementation is provided by MsgPhp\\Domain\\Infra\\Console\\Context\\ClassContextElementFactory which simply transforms argument names to human readable values so that $argumentName becomes Argument Name .","title":"Customizing Context Elements"},{"location":"infrastructure/symfony-console/#basic-example","text":"<?php use MsgPhp\\Domain\\Infra\\Console\\Context\\ClassContextFactory ; use Symfony\\Component\\Console\\Command\\Command ; use Symfony\\Component\\Console\\Input\\InputInterface ; use Symfony\\Component\\Console\\Output\\OutputInterface ; use Symfony\\Component\\Console\\Style\\SymfonyStyle ; // --- SETUP --- class MyObject { public function __construct ( string $argument , $option = null ) { } } class MyCommand extends Command { private $contextFactory ; public function __construct () { $this -> contextFactory = new ClassContextFactory ( MyObject :: class , '__construct' ); parent :: __construct (); } protected function configure () : void { $this -> setName ( 'my-command' ); $this -> contextFactory -> configure ( $this -> getDefinition ()); } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $io = new SymfonyStyle ( $input , $output ); $context = $this -> contextFactory -> getContext ( $input , $io ); $object = new MyObject ( ... array_values ( $context )); // do something return 0 ; } } // --- USAGE --- // $ bin/console my-command [--option=OPTION] [--] [<argument>]","title":"Basic Example"},{"location":"infrastructure/symfony-console/#msgphpdomaininfraconsolecontextdoctrineentitycontextfactory","text":"A Doctrine entity aware context factory. It decorates any context factory. Its purpose is to provide a discriminator value into the resulting context when working with ORM inheritance . __construct(ContextFactoryInterface $factory, EntityManagerInterface $em, string $class) $factory : The decorated context factory $em : The entity manager to use $class : The entity class to use","title":"MsgPhp\\Domain\\Infra\\Console\\Context\\DoctrineEntityContextFactory"},{"location":"infrastructure/symfony-messenger/","text":"Symfony Messenger \u00b6 An overview of available infrastructural code when using Symfony Messenger . Requires symfony/messenger Domain Message Bus \u00b6 A Symfony Messenger tailored domain message bus is provided by MsgPhp\\Domain\\Infra\\Messenger\\DomainMessageBus . Basic Example \u00b6 <?php use MsgPhp\\Domain\\Infra\\Messenger\\DomainMessageBus ; use Symfony\\Component\\Messenger\\MessageBusInterface ; // --- SETUP --- class CommandMessage { } class EventMessage { } /** @var MessageBusInterface $commandBus */ $commandBus = ... ; /** @var MessageBusInterface $commandBus */ $eventBus = ... ; $eventClasses = [ EventMessage :: class ]; $domainBus = new DomainMessageBus ( $commandBus , $eventBus , $eventClasses ); // --- USAGE --- $domainBus -> dispatch ( new CommandMessage ()); $domainBus -> dispatch ( new EventMessage ());","title":"Symfony Messenger"},{"location":"infrastructure/symfony-messenger/#symfony-messenger","text":"An overview of available infrastructural code when using Symfony Messenger . Requires symfony/messenger","title":"Symfony Messenger"},{"location":"infrastructure/symfony-messenger/#domain-message-bus","text":"A Symfony Messenger tailored domain message bus is provided by MsgPhp\\Domain\\Infra\\Messenger\\DomainMessageBus .","title":"Domain Message Bus"},{"location":"infrastructure/symfony-messenger/#basic-example","text":"<?php use MsgPhp\\Domain\\Infra\\Messenger\\DomainMessageBus ; use Symfony\\Component\\Messenger\\MessageBusInterface ; // --- SETUP --- class CommandMessage { } class EventMessage { } /** @var MessageBusInterface $commandBus */ $commandBus = ... ; /** @var MessageBusInterface $commandBus */ $eventBus = ... ; $eventClasses = [ EventMessage :: class ]; $domainBus = new DomainMessageBus ( $commandBus , $eventBus , $eventClasses ); // --- USAGE --- $domainBus -> dispatch ( new CommandMessage ()); $domainBus -> dispatch ( new EventMessage ());","title":"Basic Example"},{"location":"infrastructure/uuid/","text":"Universally Unique Identifier \u00b6 An overview of available infrastructural code when working with UUIDs . Requires ramsey/uuid Domain Identifier \u00b6 A UUID tailored domain identifier trait is provided by MsgPhp\\Domain\\Infra\\Uuid\\DomainIdTrait . Basic Example \u00b6 <?php use MsgPhp\\Domain\\DomainIdInterface ; use MsgPhp\\Domain\\Infra\\Uuid\\DomainIdTrait ; use Ramsey\\Uuid\\Uuid ; // --- SETUP --- final class MyDomainUuid implements DomainIdInterface { use DomainIdTrait ; } $id = new MyDomainUuid (); // a new UUID version 4 value $id = new MyDomainUuid ( Uuid :: uuid1 ()); $id = new MyDomainUuid ( Uuid :: fromString ( '00000000-0000-0000-0000-000000000000' ));","title":"UUID"},{"location":"infrastructure/uuid/#universally-unique-identifier","text":"An overview of available infrastructural code when working with UUIDs . Requires ramsey/uuid","title":"Universally Unique Identifier"},{"location":"infrastructure/uuid/#domain-identifier","text":"A UUID tailored domain identifier trait is provided by MsgPhp\\Domain\\Infra\\Uuid\\DomainIdTrait .","title":"Domain Identifier"},{"location":"infrastructure/uuid/#basic-example","text":"<?php use MsgPhp\\Domain\\DomainIdInterface ; use MsgPhp\\Domain\\Infra\\Uuid\\DomainIdTrait ; use Ramsey\\Uuid\\Uuid ; // --- SETUP --- final class MyDomainUuid implements DomainIdInterface { use DomainIdTrait ; } $id = new MyDomainUuid (); // a new UUID version 4 value $id = new MyDomainUuid ( Uuid :: uuid1 ()); $id = new MyDomainUuid ( Uuid :: fromString ( '00000000-0000-0000-0000-000000000000' ));","title":"Basic Example"},{"location":"message-driven/cqrs/","text":"Command Query Responsibility Segregation \u00b6 Commands are domain objects and provided per domain layer. They usually follow a POPO design. Its purpose is to describe an action to be taken. For commands being messages they can be dispatched using any message bus . Event-Sourcing Command Handler \u00b6 An event-sourcing command handler utility trait is provided by MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait . Its purpose is to ease the handling of command messages by sourcing a domain event to its event handler . handle(object $command, callable $onHandled = null): void $command : The command message to be handled $onHandled : Callable to be invoked in case the triggered domain event is handled. It receives the event handler as first argument. abstract getDomainEvent(object $command): DomainEventInterface abstract getDomainEventHandler(object $command): DomainEventHandlerInterface Basic Example \u00b6 <?php use MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait ; use MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface , DomainEventInterface }; use MsgPhp\\Domain\\Message\\DomainMessageBusInterface ; // --- SETUP --- class MyCommand { } class MyDomainEvent implements DomainEventInterface { } class MyEntity implements DomainEventHandlerInterface { public function handleEvent ( DomainEventInterface $event ) : bool { if ( $event instanceof MyDomainEvent ) { // do something return true ; } return false ; } } class MyCommandHandler { use EventSourcingCommandHandlerTrait ; public function __invoke ( MyCommand $command ) : void { $this -> handle ( $command , function ( MyEntity $entity ) : void { // do something when $command is handled }); } protected function getDomainEvent ( MyCommand $command ) : DomainEventInterface { return new MyDomainEvent (); } protected function getDomainEventHandler ( MyCommand $command ) : DomainEventHandlerInterface { return new MyEntity (); } } // --- USAGE --- /** @var DomainMessageBusInterface $bus */ $bus = ... ; $bus -> dispatch ( new MyCommand ());","title":"CQRS"},{"location":"message-driven/cqrs/#command-query-responsibility-segregation","text":"Commands are domain objects and provided per domain layer. They usually follow a POPO design. Its purpose is to describe an action to be taken. For commands being messages they can be dispatched using any message bus .","title":"Command Query Responsibility Segregation"},{"location":"message-driven/cqrs/#event-sourcing-command-handler","text":"An event-sourcing command handler utility trait is provided by MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait . Its purpose is to ease the handling of command messages by sourcing a domain event to its event handler . handle(object $command, callable $onHandled = null): void $command : The command message to be handled $onHandled : Callable to be invoked in case the triggered domain event is handled. It receives the event handler as first argument. abstract getDomainEvent(object $command): DomainEventInterface abstract getDomainEventHandler(object $command): DomainEventHandlerInterface","title":"Event-Sourcing Command Handler"},{"location":"message-driven/cqrs/#basic-example","text":"<?php use MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait ; use MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface , DomainEventInterface }; use MsgPhp\\Domain\\Message\\DomainMessageBusInterface ; // --- SETUP --- class MyCommand { } class MyDomainEvent implements DomainEventInterface { } class MyEntity implements DomainEventHandlerInterface { public function handleEvent ( DomainEventInterface $event ) : bool { if ( $event instanceof MyDomainEvent ) { // do something return true ; } return false ; } } class MyCommandHandler { use EventSourcingCommandHandlerTrait ; public function __invoke ( MyCommand $command ) : void { $this -> handle ( $command , function ( MyEntity $entity ) : void { // do something when $command is handled }); } protected function getDomainEvent ( MyCommand $command ) : DomainEventInterface { return new MyDomainEvent (); } protected function getDomainEventHandler ( MyCommand $command ) : DomainEventHandlerInterface { return new MyEntity (); } } // --- USAGE --- /** @var DomainMessageBusInterface $bus */ $bus = ... ; $bus -> dispatch ( new MyCommand ());","title":"Basic Example"},{"location":"message-driven/message-bus/","text":"Message Bus \u00b6 A domain message bus is bound to MsgPhp\\Domain\\Message\\DomainMessageBusInterface . Its purpose is to dispatch any type of message object and helps you to use CQRS and event sourcing . API \u00b6 dispatch(object $message): void \u00b6 Dispatches the given message object. Implementations \u00b6 MsgPhp\\Domain\\Infra\\Messenger\\DomainMessageBus \u00b6 A Symfony Messenger tailored domain message bus. Read more","title":"Message Bus"},{"location":"message-driven/message-bus/#message-bus","text":"A domain message bus is bound to MsgPhp\\Domain\\Message\\DomainMessageBusInterface . Its purpose is to dispatch any type of message object and helps you to use CQRS and event sourcing .","title":"Message Bus"},{"location":"message-driven/message-bus/#api","text":"","title":"API"},{"location":"message-driven/message-bus/#dispatchobject-message-void","text":"Dispatches the given message object.","title":"dispatch(object $message): void"},{"location":"message-driven/message-bus/#implementations","text":"","title":"Implementations"},{"location":"message-driven/message-bus/#msgphpdomaininframessengerdomainmessagebus","text":"A Symfony Messenger tailored domain message bus. Read more","title":"MsgPhp\\Domain\\Infra\\Messenger\\DomainMessageBus"},{"location":"message-driven/message-dispatcher/","text":"Message Dispatcher \u00b6 The domain message dispatcher is a utility trait. Its purpose is to dispatch a factorized message object using a object factory and a message bus . API \u00b6 dispatch(string $class, array $context = []): void \u00b6 Dispatches a message object factorized from $class and $context . Basic Example \u00b6 <?php use MsgPhp\\Domain\\Message\\MessageDispatchingTrait ; class MyMessage { public $argument ; public function __construct ( string $argument ) { $this -> argument = $argument ; } } class MyClass { use MessageDispatchingTrait ; public function doSomething () : void { $this -> dispatch ( MyMessage :: class , [ 'argument' => 'value' ]); } }","title":"Message Dispatcher"},{"location":"message-driven/message-dispatcher/#message-dispatcher","text":"The domain message dispatcher is a utility trait. Its purpose is to dispatch a factorized message object using a object factory and a message bus .","title":"Message Dispatcher"},{"location":"message-driven/message-dispatcher/#api","text":"","title":"API"},{"location":"message-driven/message-dispatcher/#dispatchstring-class-array-context-void","text":"Dispatches a message object factorized from $class and $context .","title":"dispatch(string $class, array $context = []): void"},{"location":"message-driven/message-dispatcher/#basic-example","text":"<?php use MsgPhp\\Domain\\Message\\MessageDispatchingTrait ; class MyMessage { public $argument ; public function __construct ( string $argument ) { $this -> argument = $argument ; } } class MyClass { use MessageDispatchingTrait ; public function doSomething () : void { $this -> dispatch ( MyMessage :: class , [ 'argument' => 'value' ]); } }","title":"Basic Example"},{"location":"projection/document-transformers/","text":"Projection Document Transformers \u00b6 A projection document transformer is bound to MsgPhp\\Domain\\Projection\\ProjectionDocumentTransformerInterface . Its purpose is to transform arbitrary objects into projection documents . API \u00b6 transform(object $object): ProjectionDocument \u00b6 Transforms the domain object into a projection document. Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ { ProjectionDocument , ProjectionDocumentTransformerInterface , ProjectionInterface }; // --- SETUP --- class MyEntity { public $id ; public $someField ; public function __construct ( $id ) { $this -> id = $id ; } } class MyProjection implements ProjectionInterface { public $id ; public $someField ; public static function fromDocument ( array $document ) : ProjectionInterface { $projection = new static (); $projection -> id = $document [ 'id' ] ?? null ; $projection -> someField = $document [ 'some_field' ] ?? null ; return $projection ; } } class MyTransformer implements ProjectionDocumentTransformerInterface { public function transform ( $object ) : ProjectionDocument { if ( $object instanceof MyEntity ) { return new ProjectionDocument ( MyProjection :: class , $object -> id , [ 'id' => $object -> id , 'some_field' => $object -> someField , ]); } throw new \\LogicException (); } } $transformer = new MyTransformer (); // --- USAGE --- $entity = new MyEntity ( 1 ); $document = $transformer -> transform ( $entity ); $projection = $document -> toProjection ();","title":"Document Transformers"},{"location":"projection/document-transformers/#projection-document-transformers","text":"A projection document transformer is bound to MsgPhp\\Domain\\Projection\\ProjectionDocumentTransformerInterface . Its purpose is to transform arbitrary objects into projection documents .","title":"Projection Document Transformers"},{"location":"projection/document-transformers/#api","text":"","title":"API"},{"location":"projection/document-transformers/#transformobject-object-projectiondocument","text":"Transforms the domain object into a projection document.","title":"transform(object $object): ProjectionDocument"},{"location":"projection/document-transformers/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ { ProjectionDocument , ProjectionDocumentTransformerInterface , ProjectionInterface }; // --- SETUP --- class MyEntity { public $id ; public $someField ; public function __construct ( $id ) { $this -> id = $id ; } } class MyProjection implements ProjectionInterface { public $id ; public $someField ; public static function fromDocument ( array $document ) : ProjectionInterface { $projection = new static (); $projection -> id = $document [ 'id' ] ?? null ; $projection -> someField = $document [ 'some_field' ] ?? null ; return $projection ; } } class MyTransformer implements ProjectionDocumentTransformerInterface { public function transform ( $object ) : ProjectionDocument { if ( $object instanceof MyEntity ) { return new ProjectionDocument ( MyProjection :: class , $object -> id , [ 'id' => $object -> id , 'some_field' => $object -> someField , ]); } throw new \\LogicException (); } } $transformer = new MyTransformer (); // --- USAGE --- $entity = new MyEntity ( 1 ); $document = $transformer -> transform ( $entity ); $projection = $document -> toProjection ();","title":"Basic example"},{"location":"projection/documents/","text":"Projection Documents \u00b6 A projection document is a value object of type MsgPhp\\Domain\\Projection\\ProjectionDocument . Its purpose is to hold a projection document its data and current state. API \u00b6 Properties \u00b6 int $status : The current document status. See also default statuses . ?\\Throwable $error : An occurred error, if any ?object $source : The source object, if any getType(): string \u00b6 Gets the projection type and refers to a projection class name. getId(): ?string \u00b6 Gets the document ID, if any. Otherwise an auto-generated value is implied. getBody(): array \u00b6 Gets the document data. toProjection(): ProjectionInterface \u00b6 Transforms the document into its projection model. Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ { ProjectionDocument , ProjectionInterface }; // --- SETUP --- class MyProjection implements ProjectionInterface { public static function fromDocument ( array $document ) : ProjectionInterface { // ... } } $document = new ProjectionDocument ( MyProjection :: class , null , [ 'some_field' => 'value' , ]); /** @var MyProjection $projection */ $projection = $document -> toProjection ();","title":"Documents"},{"location":"projection/documents/#projection-documents","text":"A projection document is a value object of type MsgPhp\\Domain\\Projection\\ProjectionDocument . Its purpose is to hold a projection document its data and current state.","title":"Projection Documents"},{"location":"projection/documents/#api","text":"","title":"API"},{"location":"projection/documents/#properties","text":"int $status : The current document status. See also default statuses . ?\\Throwable $error : An occurred error, if any ?object $source : The source object, if any","title":"Properties"},{"location":"projection/documents/#gettype-string","text":"Gets the projection type and refers to a projection class name.","title":"getType(): string"},{"location":"projection/documents/#getid-string","text":"Gets the document ID, if any. Otherwise an auto-generated value is implied.","title":"getId(): ?string"},{"location":"projection/documents/#getbody-array","text":"Gets the document data.","title":"getBody(): array"},{"location":"projection/documents/#toprojection-projectioninterface","text":"Transforms the document into its projection model.","title":"toProjection(): ProjectionInterface"},{"location":"projection/documents/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ { ProjectionDocument , ProjectionInterface }; // --- SETUP --- class MyProjection implements ProjectionInterface { public static function fromDocument ( array $document ) : ProjectionInterface { // ... } } $document = new ProjectionDocument ( MyProjection :: class , null , [ 'some_field' => 'value' , ]); /** @var MyProjection $projection */ $projection = $document -> toProjection ();","title":"Basic example"},{"location":"projection/models/","text":"Projections \u00b6 A projection is a model object and bound to MsgPhp\\Domain\\Projection\\ProjectionInterface . Its purpose is to convert raw model data (a document) into a projection. The document is usually a transformation from a domain object (e.g. an entity) and therefor projections should be considered read-only and disposable, as they can be re-created / synchronized at any time from a source of truth. A practical use case for projections are APIs, where each API resource is a so called projection from a corresponding entity. It enables decoupling and thus optimized API responses. Info For integration with API Platform see the projection data provider API \u00b6 static fromDocument(array $document): ProjectionInterface \u00b6 Creates a projection from raw document data. Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ProjectionInterface ; // --- SETUP --- class MyProjection implements ProjectionInterface { public $someField ; public static function fromDocument ( array $document ) : ProjectionInterface { $projection = new static (); $projection -> someField = $document [ 'some_field' ] ?? null ; return $projection ; } } // --- USAGE --- $projection = MyProjection :: fromDocument ([ 'some_field' => 'value' , ]);","title":"Models"},{"location":"projection/models/#projections","text":"A projection is a model object and bound to MsgPhp\\Domain\\Projection\\ProjectionInterface . Its purpose is to convert raw model data (a document) into a projection. The document is usually a transformation from a domain object (e.g. an entity) and therefor projections should be considered read-only and disposable, as they can be re-created / synchronized at any time from a source of truth. A practical use case for projections are APIs, where each API resource is a so called projection from a corresponding entity. It enables decoupling and thus optimized API responses. Info For integration with API Platform see the projection data provider","title":"Projections"},{"location":"projection/models/#api","text":"","title":"API"},{"location":"projection/models/#static-fromdocumentarray-document-projectioninterface","text":"Creates a projection from raw document data.","title":"static fromDocument(array $document): ProjectionInterface"},{"location":"projection/models/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ProjectionInterface ; // --- SETUP --- class MyProjection implements ProjectionInterface { public $someField ; public static function fromDocument ( array $document ) : ProjectionInterface { $projection = new static (); $projection -> someField = $document [ 'some_field' ] ?? null ; return $projection ; } } // --- USAGE --- $projection = MyProjection :: fromDocument ([ 'some_field' => 'value' , ]);","title":"Basic example"},{"location":"projection/repositories/","text":"Projection Repositories \u00b6 A projection repository is bound to MsgPhp\\Domain\\Projection\\ProjectionRepositoryInterface . Its purpose is to store and query projection documents . API \u00b6 findAll(string $type, int $offset = 0, int $limit = 0): ProjectionDocument[] \u00b6 Finds all projection documents by type. find(string $type, string $id): ?ProjectionDocument \u00b6 Finds a single projection document by type and ID. In case its document cannot be found null should be returned. clear(string $type): void \u00b6 Deletes all projection documents by type. save(ProjectionDocument $document): void \u00b6 Saves a projection document. The document will be available on any subsequent query. delete(string $type, string $id): void \u00b6 Deletes a projection document by type and ID. The document will be unavailable on any subsequent query. Implementations \u00b6 MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionRepository \u00b6 An Elasticsearch tailored projection repository. Read more Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ { ProjectionDocument , ProjectionInterface , ProjectionRepositoryInterface }; // --- SETUP --- class MyProjection implements ProjectionInterface { public static function fromDocument ( array $document ) : ProjectionInterface { // ... } } /** @var ProjectionRepositoryInterface $repository */ $repository = ... ; // --- USAGE --- $id = ... ; $document = $repository -> find ( MyProjection :: class , $id ); if ( null === $projection ) { $document = ProjectionDocument :: create ( MyProjection :: class , $id , [ 'some_field' => 'value' , ]); $repository -> save ( $document ); }","title":"Repositories"},{"location":"projection/repositories/#projection-repositories","text":"A projection repository is bound to MsgPhp\\Domain\\Projection\\ProjectionRepositoryInterface . Its purpose is to store and query projection documents .","title":"Projection Repositories"},{"location":"projection/repositories/#api","text":"","title":"API"},{"location":"projection/repositories/#findallstring-type-int-offset-0-int-limit-0-projectiondocument","text":"Finds all projection documents by type.","title":"findAll(string $type, int $offset = 0, int $limit = 0): ProjectionDocument[]"},{"location":"projection/repositories/#findstring-type-string-id-projectiondocument","text":"Finds a single projection document by type and ID. In case its document cannot be found null should be returned.","title":"find(string $type, string $id): ?ProjectionDocument"},{"location":"projection/repositories/#clearstring-type-void","text":"Deletes all projection documents by type.","title":"clear(string $type): void"},{"location":"projection/repositories/#saveprojectiondocument-document-void","text":"Saves a projection document. The document will be available on any subsequent query.","title":"save(ProjectionDocument $document): void"},{"location":"projection/repositories/#deletestring-type-string-id-void","text":"Deletes a projection document by type and ID. The document will be unavailable on any subsequent query.","title":"delete(string $type, string $id): void"},{"location":"projection/repositories/#implementations","text":"","title":"Implementations"},{"location":"projection/repositories/#msgphpdomaininfraelasticsearchprojectionrepository","text":"An Elasticsearch tailored projection repository. Read more","title":"MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionRepository"},{"location":"projection/repositories/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ { ProjectionDocument , ProjectionInterface , ProjectionRepositoryInterface }; // --- SETUP --- class MyProjection implements ProjectionInterface { public static function fromDocument ( array $document ) : ProjectionInterface { // ... } } /** @var ProjectionRepositoryInterface $repository */ $repository = ... ; // --- USAGE --- $id = ... ; $document = $repository -> find ( MyProjection :: class , $id ); if ( null === $projection ) { $document = ProjectionDocument :: create ( MyProjection :: class , $id , [ 'some_field' => 'value' , ]); $repository -> save ( $document ); }","title":"Basic example"},{"location":"projection/synchronization/","text":"Projection Synchronization \u00b6 MsgPhp\\Domain\\Projection\\ProjectionSynchronization is a utility domain service. Its purpose is to ease synchronizing projection documents from source objects. API \u00b6 synchronize(): iterable \u00b6 Yields all projection documents attempted to be synchronized. The actual document status can be read from ProjectionDocument::$status . Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ { ProjectionDocument , ProjectionDocumentProvider , ProjectionDocumentTransformerInterface , ProjectionRepositoryInterface , ProjectionSynchronization , ProjectionTypeRegistryInterface }; // --- SETUP --- class MyEntity { public $id ; public function __construct ( $id ) { $this -> id = $id ; } } /** @var ProjectionTypeRegistryInterface $typeRegistry */ $typeRegistry = ... ; /** @var ProjectionRepositoryInterface $repository */ $repository = ... ; /** @var ProjectionDocumentTransformerInterface $transformer */ $transformer = ... ; $provider = new ProjectionDocumentProvider ( $transformer , [ function () : iterable { yield new MyEntity ( 1 ); yield new MyEntity ( 2 ); }, ]); $synchronization = new ProjectionSynchronization ( $typeRegistry , $repository , $provider ); // --- USAGE --- foreach ( $synchronization -> synchronize () as $document ) { if ( ProjectionDocument :: STATUS_SYNCHRONIZED === $document -> status ) { echo 'Synchronized projection for ' . get_class ( $document -> source ) . ' with ID ' . $document -> source -> id . PHP_EOL ; continue ; } echo 'Invalid projection for ' . get_class ( $document -> source ) . ' with ID ' . $document -> source -> id . PHP_EOL ; if ( null !== $document -> error ) { echo 'An error occurred for ' . get_class ( $document -> source ) . ' with ID ' . $document -> source -> id . PHP_EOL ; echo $document -> error -> getMessage () . ' in ' . $document -> error -> getFile () . ' at ' . $document -> error -> getLine () . PHP_EOL ; } } Command Line Interface \u00b6 A synchronization can be ran using the CLI when working with Symfony Console. Read more","title":"Synchronization"},{"location":"projection/synchronization/#projection-synchronization","text":"MsgPhp\\Domain\\Projection\\ProjectionSynchronization is a utility domain service. Its purpose is to ease synchronizing projection documents from source objects.","title":"Projection Synchronization"},{"location":"projection/synchronization/#api","text":"","title":"API"},{"location":"projection/synchronization/#synchronize-iterable","text":"Yields all projection documents attempted to be synchronized. The actual document status can be read from ProjectionDocument::$status .","title":"synchronize(): iterable"},{"location":"projection/synchronization/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ { ProjectionDocument , ProjectionDocumentProvider , ProjectionDocumentTransformerInterface , ProjectionRepositoryInterface , ProjectionSynchronization , ProjectionTypeRegistryInterface }; // --- SETUP --- class MyEntity { public $id ; public function __construct ( $id ) { $this -> id = $id ; } } /** @var ProjectionTypeRegistryInterface $typeRegistry */ $typeRegistry = ... ; /** @var ProjectionRepositoryInterface $repository */ $repository = ... ; /** @var ProjectionDocumentTransformerInterface $transformer */ $transformer = ... ; $provider = new ProjectionDocumentProvider ( $transformer , [ function () : iterable { yield new MyEntity ( 1 ); yield new MyEntity ( 2 ); }, ]); $synchronization = new ProjectionSynchronization ( $typeRegistry , $repository , $provider ); // --- USAGE --- foreach ( $synchronization -> synchronize () as $document ) { if ( ProjectionDocument :: STATUS_SYNCHRONIZED === $document -> status ) { echo 'Synchronized projection for ' . get_class ( $document -> source ) . ' with ID ' . $document -> source -> id . PHP_EOL ; continue ; } echo 'Invalid projection for ' . get_class ( $document -> source ) . ' with ID ' . $document -> source -> id . PHP_EOL ; if ( null !== $document -> error ) { echo 'An error occurred for ' . get_class ( $document -> source ) . ' with ID ' . $document -> source -> id . PHP_EOL ; echo $document -> error -> getMessage () . ' in ' . $document -> error -> getFile () . ' at ' . $document -> error -> getLine () . PHP_EOL ; } }","title":"Basic example"},{"location":"projection/synchronization/#command-line-interface","text":"A synchronization can be ran using the CLI when working with Symfony Console. Read more","title":"Command Line Interface"},{"location":"projection/type-registry/","text":"Projection Type Registry \u00b6 A projection type registry is bound to MsgPhp\\Domain\\Projection\\ProjectionTypeRegistryInterface . Its purpose is to manage all available projection type information. API \u00b6 all(): string[] \u00b6 Returns all available projection types for this registry. initialize(): void \u00b6 Initializes the type registry. Usually needs to be called only once per environment, or after any type information has changed. destroy(): void \u00b6 Destroys the type registry and thus requires to be re-initialized after. Implementations \u00b6 MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionTypeRegistry \u00b6 An Elasticsearch tailored projection type registry. Read more Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ProjectionTypeRegistryInterface ; // --- SETUP --- /** @var ProjectionTypeRegistryInterface $typeRegistry */ $typeRegistry = ... ; // --- USAGE --- $typeRegistry -> destroy (); $typeRegistry -> initialize (); echo 'Initialized types: ' . implode ( ', ' , $typeRegistry -> all ()); Command Line Interface \u00b6 The type registry can be initialized using the CLI when working with Symfony Console. Read more","title":"Type Registry"},{"location":"projection/type-registry/#projection-type-registry","text":"A projection type registry is bound to MsgPhp\\Domain\\Projection\\ProjectionTypeRegistryInterface . Its purpose is to manage all available projection type information.","title":"Projection Type Registry"},{"location":"projection/type-registry/#api","text":"","title":"API"},{"location":"projection/type-registry/#all-string","text":"Returns all available projection types for this registry.","title":"all(): string[]"},{"location":"projection/type-registry/#initialize-void","text":"Initializes the type registry. Usually needs to be called only once per environment, or after any type information has changed.","title":"initialize(): void"},{"location":"projection/type-registry/#destroy-void","text":"Destroys the type registry and thus requires to be re-initialized after.","title":"destroy(): void"},{"location":"projection/type-registry/#implementations","text":"","title":"Implementations"},{"location":"projection/type-registry/#msgphpdomaininfraelasticsearchprojectiontyperegistry","text":"An Elasticsearch tailored projection type registry. Read more","title":"MsgPhp\\Domain\\Infra\\Elasticsearch\\ProjectionTypeRegistry"},{"location":"projection/type-registry/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ProjectionTypeRegistryInterface ; // --- SETUP --- /** @var ProjectionTypeRegistryInterface $typeRegistry */ $typeRegistry = ... ; // --- USAGE --- $typeRegistry -> destroy (); $typeRegistry -> initialize (); echo 'Initialized types: ' . implode ( ', ' , $typeRegistry -> all ());","title":"Basic example"},{"location":"projection/type-registry/#command-line-interface","text":"The type registry can be initialized using the CLI when working with Symfony Console. Read more","title":"Command Line Interface"}]}