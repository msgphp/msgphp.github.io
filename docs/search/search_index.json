{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MsgPHP Documentation \u00b6 MsgPHP is a project that aims to provide reusable domain layers for your application. It has a low development time overhead and avoids being overly opinionated.","title":"Home"},{"location":"#msgphp-documentation","text":"MsgPHP is a project that aims to provide reusable domain layers for your application. It has a low development time overhead and avoids being overly opinionated.","title":"MsgPHP Documentation"},{"location":"cookbook/configuring-doctrine-orm/","text":"Configuring Doctrine ORM \u00b6 To be able to fetch and persist entities using repositories provided by MsgPHP an ORM must be configured. In this article is explained how to setup Doctrine ORM infrastructure . Installation \u00b6 composer install doctrine/orm doctrine/doctrine-bundle # with Symfony Flex composer install orm Configuration \u00b6 See the recipe configuration for the minimal configuration to put in config/packages/doctrine.yaml . Although the examples use annotation based mappings, you are not required to do so. Read more . Info The configuration is automatically added with Symfony Flex Configure a Database \u00b6 # .env # sqlite DATABASE_URL = sqlite:///%kernel.project_dir%/var/db.sqlite # mysql / mariadb DATABASE_URL = \"mysql://user:pass@host:3306/db_name?charset=utf8mb4&serverVersion=5.7\" Create the database: bin/console doctrine:database:create bin/console doctrine:schema:update Configure an Entity Manager \u00b6 MsgPHP uses the doctrine.orm.entity_manager entity manager service by default. To use another entity manager instead configure the entity manager alias service: # config/services.yaml services : # ... msgphp.doctrine.entity_manager : '@doctrine.orm.other_entity_manager' Overriding Mapping Configuration \u00b6 Use a fixed max key length: # config/services.yaml parameters : msgphp.doctrine.mapping_config : key_max_length : 191 By default MsgPHPs built-in mapping files can be overridden by putting a modified version in %kernel.project_dir%/config/msgphp/doctrine . To specify a different location, use: # config/services.yaml parameters : msgphp.doctrine.mapping_config : mapping_dir : /some/path","title":"Configuring Doctrine ORM"},{"location":"cookbook/configuring-doctrine-orm/#configuring-doctrine-orm","text":"To be able to fetch and persist entities using repositories provided by MsgPHP an ORM must be configured. In this article is explained how to setup Doctrine ORM infrastructure .","title":"Configuring Doctrine ORM"},{"location":"cookbook/configuring-doctrine-orm/#installation","text":"composer install doctrine/orm doctrine/doctrine-bundle # with Symfony Flex composer install orm","title":"Installation"},{"location":"cookbook/configuring-doctrine-orm/#configuration","text":"See the recipe configuration for the minimal configuration to put in config/packages/doctrine.yaml . Although the examples use annotation based mappings, you are not required to do so. Read more . Info The configuration is automatically added with Symfony Flex","title":"Configuration"},{"location":"cookbook/configuring-doctrine-orm/#configure-a-database","text":"# .env # sqlite DATABASE_URL = sqlite:///%kernel.project_dir%/var/db.sqlite # mysql / mariadb DATABASE_URL = \"mysql://user:pass@host:3306/db_name?charset=utf8mb4&serverVersion=5.7\" Create the database: bin/console doctrine:database:create bin/console doctrine:schema:update","title":"Configure a Database"},{"location":"cookbook/configuring-doctrine-orm/#configure-an-entity-manager","text":"MsgPHP uses the doctrine.orm.entity_manager entity manager service by default. To use another entity manager instead configure the entity manager alias service: # config/services.yaml services : # ... msgphp.doctrine.entity_manager : '@doctrine.orm.other_entity_manager'","title":"Configure an Entity Manager"},{"location":"cookbook/configuring-doctrine-orm/#overriding-mapping-configuration","text":"Use a fixed max key length: # config/services.yaml parameters : msgphp.doctrine.mapping_config : key_max_length : 191 By default MsgPHPs built-in mapping files can be overridden by putting a modified version in %kernel.project_dir%/config/msgphp/doctrine . To specify a different location, use: # config/services.yaml parameters : msgphp.doctrine.mapping_config : mapping_dir : /some/path","title":"Overriding Mapping Configuration"},{"location":"cookbook/configuring-symfony-messenger/","text":"Configuring Symfony Messenger \u00b6 To be able to dispatch messages provided by MsgPHP a domain message bus must be configured. In this article is explained how to setup Symfony Messenger infrastructure . Installation \u00b6 composer require symfony/messenger # with Symfony Flex composer require messenger Configuration \u00b6 See the recipe configuration for the minimal configuration to put in config/packages/messenger.yaml . Info The configuration is automatically added with Symfony Flex Configure a Command and Event Bus \u00b6 # config/packages/messenger.yaml framework : messenger : # ... default_bus : command_bus buses : command_bus : ~ event_bus : default_middleware : allow_no_handlers Enable the Command and Event Bus \u00b6 MsgPHP uses the bus configured with framework.messenger.default_bus for both command and event messages by default. To use your custom buses instead configure the bus aliases: # config/services.yaml services : # ... msgphp.messenger.command_bus : '@command_bus' msgphp.messenger.event_bus : '@event_bus'","title":"Configuring Symfony Messenger"},{"location":"cookbook/configuring-symfony-messenger/#configuring-symfony-messenger","text":"To be able to dispatch messages provided by MsgPHP a domain message bus must be configured. In this article is explained how to setup Symfony Messenger infrastructure .","title":"Configuring Symfony Messenger"},{"location":"cookbook/configuring-symfony-messenger/#installation","text":"composer require symfony/messenger # with Symfony Flex composer require messenger","title":"Installation"},{"location":"cookbook/configuring-symfony-messenger/#configuration","text":"See the recipe configuration for the minimal configuration to put in config/packages/messenger.yaml . Info The configuration is automatically added with Symfony Flex","title":"Configuration"},{"location":"cookbook/configuring-symfony-messenger/#configure-a-command-and-event-bus","text":"# config/packages/messenger.yaml framework : messenger : # ... default_bus : command_bus buses : command_bus : ~ event_bus : default_middleware : allow_no_handlers","title":"Configure a Command and Event Bus"},{"location":"cookbook/configuring-symfony-messenger/#enable-the-command-and-event-bus","text":"MsgPHP uses the bus configured with framework.messenger.default_bus for both command and event messages by default. To use your custom buses instead configure the bus aliases: # config/services.yaml services : # ... msgphp.messenger.command_bus : '@command_bus' msgphp.messenger.event_bus : '@event_bus'","title":"Enable the Command and Event Bus"},{"location":"cookbook/user-bundle/creating-a-user/","text":"Creating a User \u00b6 Users can be created by dispatching the CreateUser message with a data array that contains values for the User constructor arguments. <?php use MsgPhp\\User\\Command\\CreateUser ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUser ([])); The handler will automatically add an id element to the data array holding an instance of MsgPhp\\User\\UserId . Alternatively it can be passed upfront: <?php use MsgPhp\\User\\ScalarUserId ; use MsgPhp\\User\\Command\\CreateUser ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUser ([ 'id' => new ScalarUserId (), ])); To programmatically factorize an identifier , use the object factory : <?php use MsgPhp\\Domain\\Factory\\DomainObjectFactory ; use MsgPhp\\User\\UserId ; use MsgPhp\\User\\Command\\CreateUser ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var DomainObjectFactory $factory */ /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUser ([ 'id' => $factory -> create ( UserId :: class ), ])); Adding Custom Fields \u00b6 Define the custom fields: <?php // src/Entity/User.php // ... class User extends BaseUser { // ... private $requiredField ; private $optionalField ; public function __construct ( UserId $id , $requiredField , $optionalField = null ) { $this -> id = $id ; $this -> requiredField = $requiredField ; $this -> optionalField = $optionalField ; } // ... } Specify the fields during dispatch: <?php use MsgPhp\\User\\Command\\CreateUser ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUser ([ 'requiredField' => 'value' , ])); // alternatively: $bus -> dispatch ( new CreateUser ([ 'requiredField' => 'value' , 'optionalField' => 'value' , ]));","title":"Creating a User"},{"location":"cookbook/user-bundle/creating-a-user/#creating-a-user","text":"Users can be created by dispatching the CreateUser message with a data array that contains values for the User constructor arguments. <?php use MsgPhp\\User\\Command\\CreateUser ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUser ([])); The handler will automatically add an id element to the data array holding an instance of MsgPhp\\User\\UserId . Alternatively it can be passed upfront: <?php use MsgPhp\\User\\ScalarUserId ; use MsgPhp\\User\\Command\\CreateUser ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUser ([ 'id' => new ScalarUserId (), ])); To programmatically factorize an identifier , use the object factory : <?php use MsgPhp\\Domain\\Factory\\DomainObjectFactory ; use MsgPhp\\User\\UserId ; use MsgPhp\\User\\Command\\CreateUser ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var DomainObjectFactory $factory */ /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUser ([ 'id' => $factory -> create ( UserId :: class ), ]));","title":"Creating a User"},{"location":"cookbook/user-bundle/creating-a-user/#adding-custom-fields","text":"Define the custom fields: <?php // src/Entity/User.php // ... class User extends BaseUser { // ... private $requiredField ; private $optionalField ; public function __construct ( UserId $id , $requiredField , $optionalField = null ) { $this -> id = $id ; $this -> requiredField = $requiredField ; $this -> optionalField = $optionalField ; } // ... } Specify the fields during dispatch: <?php use MsgPhp\\User\\Command\\CreateUser ; use Symfony\\Component\\Messenger\\MessageBusInterface ; /** @var MessageBusInterface $bus */ $bus -> dispatch ( new CreateUser ([ 'requiredField' => 'value' , ])); // alternatively: $bus -> dispatch ( new CreateUser ([ 'requiredField' => 'value' , 'optionalField' => 'value' , ]));","title":"Adding Custom Fields"},{"location":"cookbook/user-bundle/installation/","text":"User Bundle Installation \u00b6 Install the bundle using Composer : composer require msgphp/user-bundle Info When using Symfony Flex to manage your application the minimal bundle recipe configuration is applied automatically upon installation Configure the User Entity \u00b6 <?php // src/Entity/User.php namespace App\\Entity ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\User\\User as BaseUser ; use MsgPhp\\User\\UserId ; /** * @ORM\\Entity() */ class User extends BaseUser { /** @ORM\\Id() @ORM\\GeneratedValue() @ORM\\Column(type=\"msgphp_user_id\", length=191) */ private $id ; public function __construct ( UserId $id ) { $this -> id = $id ; } public function getId () : UserId { return $this -> id ; } } # config/packages/msgphp_user.yaml msgphp_user : class_mapping : MsgPhp\\User\\User : App\\Entity\\User Disable Required Constructor Argument \u00b6 The required constructor argument enables to provide an identifier upfront, so the user does not have to be queried for it after. To disable it, use: <?php // ... public function __construct () { $this -> id = new \\MsgPhp\\User\\ScalarUserId (); //$this->id = new \\MsgPhp\\User\\Infrastructure\\Uuid\\UserUuid(); } Disable Automatic Identifier Hydration \u00b6 Using the built-in msgphp_user_id Doctrine type enables decoupling between your entity and its identifier. To disable it, use: <?php // ... /** @ORM\\Id() @ORM\\GeneratedValue() @ORM\\Column(type=\"integer\") */ private $id ; // ... public function getId () : UserId { return \\MsgPhp\\User\\ScalarUserId :: fromValue ( $this -> id ); } Override Mapping Configuration \u00b6 If, for some reason, the default mapping needs to be customized, create the file config/msgphp/doctrine/User.User.orm.xml : <doctrine-mapping> <mapped-superclass name= \"MsgPhp\\User\\User\" > <!-- ... --> </mapped-superclass> </doctrine-mapping> Info See default mapping files Configure the User Identity \u00b6 The user is identified by a built-in domain identifier of type MsgPhp\\User\\UserId . The default data type is considered integer using a default implementation of type: MsgPhp\\User\\ScalarUserId . Optionally change the data type and implementation used by MsgPHP: # config/packages/msgphp_user.yaml msgphp_user : id_type_mapping : MsgPhp\\User\\UserId : bigint class_mapping : MsgPhp\\User\\UserId : App\\Entity\\UserId Using a UUID identifier \u00b6 # config/packages/msgphp_user.yaml msgphp_user : id_type_mapping : MsgPhp\\User\\UserId : uuid # uuid_binary, uuid_binary_ordered_time This changes the default implementation used by MsgPHP to MsgPhp\\User\\Infrastructure\\Uuid\\UserUuid .","title":"Installation"},{"location":"cookbook/user-bundle/installation/#user-bundle-installation","text":"Install the bundle using Composer : composer require msgphp/user-bundle Info When using Symfony Flex to manage your application the minimal bundle recipe configuration is applied automatically upon installation","title":"User Bundle Installation"},{"location":"cookbook/user-bundle/installation/#configure-the-user-entity","text":"<?php // src/Entity/User.php namespace App\\Entity ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\User\\User as BaseUser ; use MsgPhp\\User\\UserId ; /** * @ORM\\Entity() */ class User extends BaseUser { /** @ORM\\Id() @ORM\\GeneratedValue() @ORM\\Column(type=\"msgphp_user_id\", length=191) */ private $id ; public function __construct ( UserId $id ) { $this -> id = $id ; } public function getId () : UserId { return $this -> id ; } } # config/packages/msgphp_user.yaml msgphp_user : class_mapping : MsgPhp\\User\\User : App\\Entity\\User","title":"Configure the User Entity"},{"location":"cookbook/user-bundle/installation/#disable-required-constructor-argument","text":"The required constructor argument enables to provide an identifier upfront, so the user does not have to be queried for it after. To disable it, use: <?php // ... public function __construct () { $this -> id = new \\MsgPhp\\User\\ScalarUserId (); //$this->id = new \\MsgPhp\\User\\Infrastructure\\Uuid\\UserUuid(); }","title":"Disable Required Constructor Argument"},{"location":"cookbook/user-bundle/installation/#disable-automatic-identifier-hydration","text":"Using the built-in msgphp_user_id Doctrine type enables decoupling between your entity and its identifier. To disable it, use: <?php // ... /** @ORM\\Id() @ORM\\GeneratedValue() @ORM\\Column(type=\"integer\") */ private $id ; // ... public function getId () : UserId { return \\MsgPhp\\User\\ScalarUserId :: fromValue ( $this -> id ); }","title":"Disable Automatic Identifier Hydration"},{"location":"cookbook/user-bundle/installation/#override-mapping-configuration","text":"If, for some reason, the default mapping needs to be customized, create the file config/msgphp/doctrine/User.User.orm.xml : <doctrine-mapping> <mapped-superclass name= \"MsgPhp\\User\\User\" > <!-- ... --> </mapped-superclass> </doctrine-mapping> Info See default mapping files","title":"Override Mapping Configuration"},{"location":"cookbook/user-bundle/installation/#configure-the-user-identity","text":"The user is identified by a built-in domain identifier of type MsgPhp\\User\\UserId . The default data type is considered integer using a default implementation of type: MsgPhp\\User\\ScalarUserId . Optionally change the data type and implementation used by MsgPHP: # config/packages/msgphp_user.yaml msgphp_user : id_type_mapping : MsgPhp\\User\\UserId : bigint class_mapping : MsgPhp\\User\\UserId : App\\Entity\\UserId","title":"Configure the User Identity"},{"location":"cookbook/user-bundle/installation/#using-a-uuid-identifier","text":"# config/packages/msgphp_user.yaml msgphp_user : id_type_mapping : MsgPhp\\User\\UserId : uuid # uuid_binary, uuid_binary_ordered_time This changes the default implementation used by MsgPHP to MsgPhp\\User\\Infrastructure\\Uuid\\UserUuid .","title":"Using a UUID identifier"},{"location":"ddd/collections/","text":"Collections \u00b6 A domain collection is a traversable and bound to MsgPhp\\Domain\\DomainCollection . Its purpose is to utilize a primitive iterable value. It may hold any type of element values. API \u00b6 Extends \u00b6 \\Countable \\IteratorAggregate static fromValue(?iterable $value): DomainCollection \u00b6 Returns a factorized collection from any primitive iterable. Using null implies an empty collection. isEmpty(): bool \u00b6 Tells if a collection is considered empty, i.e. contains zero elements. contains(mixed $element): bool \u00b6 Tells if a collection contains the given element. Comparison is done strictly. containsKey(string|int $key): bool \u00b6 Tells if a collection contains an element at the given key. first(): mixed \u00b6 Returns the first element from a collection. last(): mixed \u00b6 Returns the last element from a collection. get(string|int $key): mixed \u00b6 Returns the element at the given key from a collection. filter(callable $filter): DomainCollection \u00b6 Returns a new collection containing only elements for which $filter returns true . Keys are preserved. slice(int $offset, int $limit = 0): DomainCollection \u00b6 Returns a new collection containing a slice of elements. By default the slice has no limit, implied by integer 0 . Keys are preserved. map(callable $mapper): DomainCollection \u00b6 Returns a new collection containing each collection element as returned by $mapper . Keys are preserved. Pagination API \u00b6 A collection that is part of a paginated result set is bound to MsgPhp\\Domain\\PaginatedDomainCollection . Its purpose is to expose the current pagination. Extends \u00b6 DomainCollection getOffset(): float \u00b6 Get the current page offset. getLimit(): float \u00b6 Get the current page limit (e.g. items per page). getCurrentPage(): float \u00b6 Get the current page number. getLastPage(): float \u00b6 Get the last page number. getTotalCount(): float \u00b6 Get the total no. of items in the full result set. Note count() should return the no. of items on the current page Implementations \u00b6 MsgPhp\\Domain\\GenericDomainCollection \u00b6 A first-class citizen domain collection compatible with any iterable value. Basic Example \u00b6 <?php use MsgPhp\\Domain\\GenericDomainCollection ; // --- SETUP --- $collection = new GenericDomainCollection ([ 'a' , 'b' , 'c' , 1 , 2 , 3 , 'key' => 'value' ]); // --- USAGE --- $collection -> isEmpty (); // false count ( $collection ); // int(7) $collection -> contains ( 2 ); // true $collection -> contains ( '2' ); // false $collection -> containsKey ( 0 ); // true $collection -> containsKey ( '0' ); // true $collection -> first (); // \"a\" $collection -> last (); // int(3) $collection -> get ( '0' ); // \"a\" $collection -> get ( 3 ); // int(1) $collection -> get ( 'key' ); // \"value\" $onlyInts = $collection -> filter ( function ( $value ) : bool { return is_int ( $value ); }); $firstTwoInts = $onlyInts -> slice ( 0 , 2 ); $firstTwoIntsPlussed = $firstTwoInts -> map ( function ( int $value ) : int { return ++ $value ; }); MsgPhp\\Domain\\GenericPaginatedDomainCollection \u00b6 A first-class citizen paginated domain collection compatible with any iterable value. MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainCollection \u00b6 A Doctrine tailored domain collection. Read more","title":"Collections"},{"location":"ddd/collections/#collections","text":"A domain collection is a traversable and bound to MsgPhp\\Domain\\DomainCollection . Its purpose is to utilize a primitive iterable value. It may hold any type of element values.","title":"Collections"},{"location":"ddd/collections/#api","text":"","title":"API"},{"location":"ddd/collections/#extends","text":"\\Countable \\IteratorAggregate","title":"Extends"},{"location":"ddd/collections/#static-fromvalueiterable-value-domaincollection","text":"Returns a factorized collection from any primitive iterable. Using null implies an empty collection.","title":"static fromValue(?iterable $value): DomainCollection"},{"location":"ddd/collections/#isempty-bool","text":"Tells if a collection is considered empty, i.e. contains zero elements.","title":"isEmpty(): bool"},{"location":"ddd/collections/#containsmixed-element-bool","text":"Tells if a collection contains the given element. Comparison is done strictly.","title":"contains(mixed $element): bool"},{"location":"ddd/collections/#containskeystringint-key-bool","text":"Tells if a collection contains an element at the given key.","title":"containsKey(string|int $key): bool"},{"location":"ddd/collections/#first-mixed","text":"Returns the first element from a collection.","title":"first(): mixed"},{"location":"ddd/collections/#last-mixed","text":"Returns the last element from a collection.","title":"last(): mixed"},{"location":"ddd/collections/#getstringint-key-mixed","text":"Returns the element at the given key from a collection.","title":"get(string|int $key): mixed"},{"location":"ddd/collections/#filtercallable-filter-domaincollection","text":"Returns a new collection containing only elements for which $filter returns true . Keys are preserved.","title":"filter(callable $filter): DomainCollection"},{"location":"ddd/collections/#sliceint-offset-int-limit-0-domaincollection","text":"Returns a new collection containing a slice of elements. By default the slice has no limit, implied by integer 0 . Keys are preserved.","title":"slice(int $offset, int $limit = 0): DomainCollection"},{"location":"ddd/collections/#mapcallable-mapper-domaincollection","text":"Returns a new collection containing each collection element as returned by $mapper . Keys are preserved.","title":"map(callable $mapper): DomainCollection"},{"location":"ddd/collections/#pagination-api","text":"A collection that is part of a paginated result set is bound to MsgPhp\\Domain\\PaginatedDomainCollection . Its purpose is to expose the current pagination.","title":"Pagination API"},{"location":"ddd/collections/#extends_1","text":"DomainCollection","title":"Extends"},{"location":"ddd/collections/#getoffset-float","text":"Get the current page offset.","title":"getOffset(): float"},{"location":"ddd/collections/#getlimit-float","text":"Get the current page limit (e.g. items per page).","title":"getLimit(): float"},{"location":"ddd/collections/#getcurrentpage-float","text":"Get the current page number.","title":"getCurrentPage(): float"},{"location":"ddd/collections/#getlastpage-float","text":"Get the last page number.","title":"getLastPage(): float"},{"location":"ddd/collections/#gettotalcount-float","text":"Get the total no. of items in the full result set. Note count() should return the no. of items on the current page","title":"getTotalCount(): float"},{"location":"ddd/collections/#implementations","text":"","title":"Implementations"},{"location":"ddd/collections/#msgphpdomaingenericdomaincollection","text":"A first-class citizen domain collection compatible with any iterable value.","title":"MsgPhp\\Domain\\GenericDomainCollection"},{"location":"ddd/collections/#basic-example","text":"<?php use MsgPhp\\Domain\\GenericDomainCollection ; // --- SETUP --- $collection = new GenericDomainCollection ([ 'a' , 'b' , 'c' , 1 , 2 , 3 , 'key' => 'value' ]); // --- USAGE --- $collection -> isEmpty (); // false count ( $collection ); // int(7) $collection -> contains ( 2 ); // true $collection -> contains ( '2' ); // false $collection -> containsKey ( 0 ); // true $collection -> containsKey ( '0' ); // true $collection -> first (); // \"a\" $collection -> last (); // int(3) $collection -> get ( '0' ); // \"a\" $collection -> get ( 3 ); // int(1) $collection -> get ( 'key' ); // \"value\" $onlyInts = $collection -> filter ( function ( $value ) : bool { return is_int ( $value ); }); $firstTwoInts = $onlyInts -> slice ( 0 , 2 ); $firstTwoIntsPlussed = $firstTwoInts -> map ( function ( int $value ) : int { return ++ $value ; });","title":"Basic Example"},{"location":"ddd/collections/#msgphpdomaingenericpaginateddomaincollection","text":"A first-class citizen paginated domain collection compatible with any iterable value.","title":"MsgPhp\\Domain\\GenericPaginatedDomainCollection"},{"location":"ddd/collections/#msgphpdomaininfrastructuredoctrinedomaincollection","text":"A Doctrine tailored domain collection. Read more","title":"MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainCollection"},{"location":"ddd/entities/","text":"Entities \u00b6 Domain entities are \" vanilla PHP objects\". To simplify its model definition common fields and features are provided in the form of traits . Entity Fields \u00b6 Use entity fields to provide read operations for common entity fields. Built-in fields are: Msgphp\\Domain\\Model\\CreatedAtField Msgphp\\Domain\\Model\\LastUpdatedAtField Entity Features \u00b6 Use entity features to provide write operations for common entity fields. Built-in features are: MsgPhp\\Domain\\Model\\CanBeConfirmed MsgPhp\\Domain\\Model\\CanBeEnabled Basic Example \u00b6 <?php use MsgPhp\\Domain\\Model\\CreatedAtField ; use MsgPhp\\Domain\\Model\\CanBeEnabled ; // --- SETUP --- class MyEntity { use CreatedAtField ; use CanBeEnabled ; public function __construct () { $this -> createdAt = new \\DateTimeImmutable (); } } // --- USAGE --- $entity = new MyEntity (); $createdAt = $entity -> getCreatedAt (); if ( ! $entity -> isEnabled ()) { $entity -> enable (); }","title":"Entities"},{"location":"ddd/entities/#entities","text":"Domain entities are \" vanilla PHP objects\". To simplify its model definition common fields and features are provided in the form of traits .","title":"Entities"},{"location":"ddd/entities/#entity-fields","text":"Use entity fields to provide read operations for common entity fields. Built-in fields are: Msgphp\\Domain\\Model\\CreatedAtField Msgphp\\Domain\\Model\\LastUpdatedAtField","title":"Entity Fields"},{"location":"ddd/entities/#entity-features","text":"Use entity features to provide write operations for common entity fields. Built-in features are: MsgPhp\\Domain\\Model\\CanBeConfirmed MsgPhp\\Domain\\Model\\CanBeEnabled","title":"Entity Features"},{"location":"ddd/entities/#basic-example","text":"<?php use MsgPhp\\Domain\\Model\\CreatedAtField ; use MsgPhp\\Domain\\Model\\CanBeEnabled ; // --- SETUP --- class MyEntity { use CreatedAtField ; use CanBeEnabled ; public function __construct () { $this -> createdAt = new \\DateTimeImmutable (); } } // --- USAGE --- $entity = new MyEntity (); $createdAt = $entity -> getCreatedAt (); if ( ! $entity -> isEnabled ()) { $entity -> enable (); }","title":"Basic Example"},{"location":"ddd/identifiers/","text":"Identifiers \u00b6 A domain identifier is a value object and bound to MsgPhp\\Domain\\DomainId . Its purpose is to utilize a primitive identifier value, usually used to identity an entity with. API \u00b6 static fromValue(mixed $value): DomainId \u00b6 Returns a factorized identifier from any primitive value. Using null might imply an empty identifier. isEmpty(): bool \u00b6 Tells if an identifier value is considered empty, thus has no known primitive value. equals(DomainId $id): bool \u00b6 Tells if an identifier strictly equals another identifier. toString(): string \u00b6 Returns the identifier its primitive string value. If the identifier is empty (see isEmpty() ) an empty string should be returned. Implementations \u00b6 MsgPhp\\Domain\\DomainIdTrait \u00b6 A first-class citizen domain identifier trait compatible with any scalar value. Basic Example \u00b6 <?php use MsgPhp\\Domain\\DomainId ; use MsgPhp\\Domain\\DomainIdTrait ; // --- SETUP --- class MyDomainId implements DomainId { use DomainIdTrait ; } $id = new MyDomainId ( '1' ); $emptyId = new MyDomainId (); // --- USAGE --- $id -> isEmpty (); // false $emptyId -> isEmpty (); // true $id -> equals ( new MyDomainId ( '1' )); // true $emptyId -> equals ( new MyDomainId ()); // false $emptyId -> equals ( $emptyId ); // true $id -> toString (); // \"1\" $emptyId -> toString (); // \"\" MsgPhp\\Domain\\Infrastructure\\Uuid\\DomainIdTrait \u00b6 A UUID tailored domain identifier trait. Read more","title":"Identifiers"},{"location":"ddd/identifiers/#identifiers","text":"A domain identifier is a value object and bound to MsgPhp\\Domain\\DomainId . Its purpose is to utilize a primitive identifier value, usually used to identity an entity with.","title":"Identifiers"},{"location":"ddd/identifiers/#api","text":"","title":"API"},{"location":"ddd/identifiers/#static-fromvaluemixed-value-domainid","text":"Returns a factorized identifier from any primitive value. Using null might imply an empty identifier.","title":"static fromValue(mixed $value): DomainId"},{"location":"ddd/identifiers/#isempty-bool","text":"Tells if an identifier value is considered empty, thus has no known primitive value.","title":"isEmpty(): bool"},{"location":"ddd/identifiers/#equalsdomainid-id-bool","text":"Tells if an identifier strictly equals another identifier.","title":"equals(DomainId $id): bool"},{"location":"ddd/identifiers/#tostring-string","text":"Returns the identifier its primitive string value. If the identifier is empty (see isEmpty() ) an empty string should be returned.","title":"toString(): string"},{"location":"ddd/identifiers/#implementations","text":"","title":"Implementations"},{"location":"ddd/identifiers/#msgphpdomaindomainidtrait","text":"A first-class citizen domain identifier trait compatible with any scalar value.","title":"MsgPhp\\Domain\\DomainIdTrait"},{"location":"ddd/identifiers/#basic-example","text":"<?php use MsgPhp\\Domain\\DomainId ; use MsgPhp\\Domain\\DomainIdTrait ; // --- SETUP --- class MyDomainId implements DomainId { use DomainIdTrait ; } $id = new MyDomainId ( '1' ); $emptyId = new MyDomainId (); // --- USAGE --- $id -> isEmpty (); // false $emptyId -> isEmpty (); // true $id -> equals ( new MyDomainId ( '1' )); // true $emptyId -> equals ( new MyDomainId ()); // false $emptyId -> equals ( $emptyId ); // true $id -> toString (); // \"1\" $emptyId -> toString (); // \"\"","title":"Basic Example"},{"location":"ddd/identifiers/#msgphpdomaininfrastructureuuiddomainidtrait","text":"A UUID tailored domain identifier trait. Read more","title":"MsgPhp\\Domain\\Infrastructure\\Uuid\\DomainIdTrait"},{"location":"ddd/message-bus/","text":"Message Bus \u00b6 A domain message bus is bound to MsgPhp\\Domain\\DomainMessageBus . Its purpose is to dispatch any type of message object either synchronously or asynchronously. A message object is considered domain-specific language (DSL) and can be listened for using so called \"message handlers\" (a PHP callable ). Command Query Responsibility Segregation \u00b6 Commands are a specific type of messages, typically used for \"commanding\" the domain, thus describing actions to be taken. Typically commands require exactly one \"command handler\" listening. API \u00b6 dispatch(object $message): void \u00b6 Dispatches the given message object. Implementations \u00b6 MsgPhp\\Domain\\Infrastructure\\Messenger\\DomainMessageBus \u00b6 A Symfony Messenger tailored domain message bus. Read more","title":"Message Bus"},{"location":"ddd/message-bus/#message-bus","text":"A domain message bus is bound to MsgPhp\\Domain\\DomainMessageBus . Its purpose is to dispatch any type of message object either synchronously or asynchronously. A message object is considered domain-specific language (DSL) and can be listened for using so called \"message handlers\" (a PHP callable ).","title":"Message Bus"},{"location":"ddd/message-bus/#command-query-responsibility-segregation","text":"Commands are a specific type of messages, typically used for \"commanding\" the domain, thus describing actions to be taken. Typically commands require exactly one \"command handler\" listening.","title":"Command Query Responsibility Segregation"},{"location":"ddd/message-bus/#api","text":"","title":"API"},{"location":"ddd/message-bus/#dispatchobject-message-void","text":"Dispatches the given message object.","title":"dispatch(object $message): void"},{"location":"ddd/message-bus/#implementations","text":"","title":"Implementations"},{"location":"ddd/message-bus/#msgphpdomaininfrastructuremessengerdomainmessagebus","text":"A Symfony Messenger tailored domain message bus. Read more","title":"MsgPhp\\Domain\\Infrastructure\\Messenger\\DomainMessageBus"},{"location":"ddd/object-factory/","text":"Object Factory \u00b6 A domain object factory is bound to MsgPhp\\Domain\\Factory\\DomainObjectFactory . Its purpose is to initialize any domain object based on a given class name and context. API \u00b6 create(string $class, array $context = []): object \u00b6 Returns a factorized domain object by class name. Optionally a context can be provided for the factory to act upon. reference(string $class, array $context = []): object \u00b6 Returns a factorized domain reference object by class name. Optionally a context can be provided for the factory to act upon. Info Factorizing a reference should not trigger its constructor to be called, nor trigger any form of external loading getClass(string $class, array $context = []): string \u00b6 Returns the actual class name the factory uses for a given class name. Implementations \u00b6 MsgPhp\\Domain\\Factory\\GenericDomainObjectFactory \u00b6 A generic object factory. It initializes a class by reading its constructor arguments. If the class is a sub class of MsgPhp\\Domain\\DomainId or MsgPhp\\Domain\\DomainCollection its static fromValue constructor will be used instead. Context elements mapped by argument name will be used as argument value. In case of a type-hinted object argument a nested context may be provided to initialize the object with. To map interfaces and abstract classes to concrete classes a global class mapping can be provided. Basic example \u00b6 <?php use MsgPhp\\Domain\\Factory\\GenericDomainObjectFactory ; // --- SETUP --- interface Known { } class Some implements Known { public function __construct ( int $a , ? int $b , ? int $c ) { } } class Subject { public function __construct ( string $argument , Known $some , Subject $otherSubject = null ) { } } $factory = new GenericDomainObjectFactory ([ Known :: class => Some :: class , ]); // Optionally set the factory to use for nested objects, or use the current factory by default. // $factory->setNestedFactory(...); // --- USAGE --- /** @var Some $object */ $object = $factory -> create ( Known :: class , [ 'a' => 1 ]); $factory -> getClass ( Known :: class ); // \"Some\" /** @var Subject $object */ $object = $factory -> create ( Subject :: class , [ 'argument' => 'value' , 'some' => [ 'a' => 1 , 'b' => 2 ], 'otherSubject' => [ 'argument' => 'other value' , 'some' => [ 'a' => 1 ], ], ]); /** @var Subject $object */ $object = $factory -> reference ( Subject :: class ); Note GenericDomainObjectFactory::reference() requires symfony/var-exporter MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainObjectFactory \u00b6 A Doctrine tailored object factory. Read more","title":"Object Factory"},{"location":"ddd/object-factory/#object-factory","text":"A domain object factory is bound to MsgPhp\\Domain\\Factory\\DomainObjectFactory . Its purpose is to initialize any domain object based on a given class name and context.","title":"Object Factory"},{"location":"ddd/object-factory/#api","text":"","title":"API"},{"location":"ddd/object-factory/#createstring-class-array-context-object","text":"Returns a factorized domain object by class name. Optionally a context can be provided for the factory to act upon.","title":"create(string $class, array $context = []): object"},{"location":"ddd/object-factory/#referencestring-class-array-context-object","text":"Returns a factorized domain reference object by class name. Optionally a context can be provided for the factory to act upon. Info Factorizing a reference should not trigger its constructor to be called, nor trigger any form of external loading","title":"reference(string $class, array $context = []): object"},{"location":"ddd/object-factory/#getclassstring-class-array-context-string","text":"Returns the actual class name the factory uses for a given class name.","title":"getClass(string $class, array $context = []): string"},{"location":"ddd/object-factory/#implementations","text":"","title":"Implementations"},{"location":"ddd/object-factory/#msgphpdomainfactorygenericdomainobjectfactory","text":"A generic object factory. It initializes a class by reading its constructor arguments. If the class is a sub class of MsgPhp\\Domain\\DomainId or MsgPhp\\Domain\\DomainCollection its static fromValue constructor will be used instead. Context elements mapped by argument name will be used as argument value. In case of a type-hinted object argument a nested context may be provided to initialize the object with. To map interfaces and abstract classes to concrete classes a global class mapping can be provided.","title":"MsgPhp\\Domain\\Factory\\GenericDomainObjectFactory"},{"location":"ddd/object-factory/#basic-example","text":"<?php use MsgPhp\\Domain\\Factory\\GenericDomainObjectFactory ; // --- SETUP --- interface Known { } class Some implements Known { public function __construct ( int $a , ? int $b , ? int $c ) { } } class Subject { public function __construct ( string $argument , Known $some , Subject $otherSubject = null ) { } } $factory = new GenericDomainObjectFactory ([ Known :: class => Some :: class , ]); // Optionally set the factory to use for nested objects, or use the current factory by default. // $factory->setNestedFactory(...); // --- USAGE --- /** @var Some $object */ $object = $factory -> create ( Known :: class , [ 'a' => 1 ]); $factory -> getClass ( Known :: class ); // \"Some\" /** @var Subject $object */ $object = $factory -> create ( Subject :: class , [ 'argument' => 'value' , 'some' => [ 'a' => 1 , 'b' => 2 ], 'otherSubject' => [ 'argument' => 'other value' , 'some' => [ 'a' => 1 ], ], ]); /** @var Subject $object */ $object = $factory -> reference ( Subject :: class ); Note GenericDomainObjectFactory::reference() requires symfony/var-exporter","title":"Basic example"},{"location":"ddd/object-factory/#msgphpdomaininfrastructuredoctrinedomainobjectfactory","text":"A Doctrine tailored object factory. Read more","title":"MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainObjectFactory"},{"location":"ddd/repositories/","text":"Repositories \u00b6 A domain repository is tied to specific domain entities . To define a repository for them you can leverage a utility trait tied to specific infrastructure (e.g. Doctrine ORM ). This page describes the API provided by default implementations . API \u00b6 doFindAll(int $offset = 0, int $limit = 0): DomainCollection \u00b6 Finds all entities available. An unlimited collection is implied by $limit set to zero. doFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollection \u00b6 Finds all entities matching the specified fields. Supported field values should be null , scalar , scalar[] (i.e. one of) and object (i.e. another entity or its identifier ). An unlimited collection is implied by $limit set to zero. doFind(mixed $id): object \u00b6 Finds a single entity by its identity. Supported identity values should be scalar , array (for composite identifiers), and object (i.e. another entity or its identifier ). doFindByFields(array $fields): object \u00b6 Finds the first entity matching the specified fields. See doFindAllByFields() for supported field values. doExists(mixed $id): bool \u00b6 Verifies if an entity exists by its identity. See doFind() for supported identity values. doExistsByFields(array $fields): bool \u00b6 Verifies if an entity matching the specified fields exists. See doFindAllByFields() for supported field values. doSave(object $entity): void \u00b6 Persists an entity into the identity map. The entity will be available on any subsequent query. doDelete(object $entity): void \u00b6 Removes an entity from the identity map. The entity will be unavailable on any subsequent query. Implementations \u00b6 MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainEntityRepositoryTrait \u00b6 A Doctrine tailored repository trait. Read more","title":"Repositories"},{"location":"ddd/repositories/#repositories","text":"A domain repository is tied to specific domain entities . To define a repository for them you can leverage a utility trait tied to specific infrastructure (e.g. Doctrine ORM ). This page describes the API provided by default implementations .","title":"Repositories"},{"location":"ddd/repositories/#api","text":"","title":"API"},{"location":"ddd/repositories/#dofindallint-offset-0-int-limit-0-domaincollection","text":"Finds all entities available. An unlimited collection is implied by $limit set to zero.","title":"doFindAll(int $offset = 0, int $limit = 0): DomainCollection"},{"location":"ddd/repositories/#dofindallbyfieldsarray-fields-int-offset-0-int-limit-0-domaincollection","text":"Finds all entities matching the specified fields. Supported field values should be null , scalar , scalar[] (i.e. one of) and object (i.e. another entity or its identifier ). An unlimited collection is implied by $limit set to zero.","title":"doFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollection"},{"location":"ddd/repositories/#dofindmixed-id-object","text":"Finds a single entity by its identity. Supported identity values should be scalar , array (for composite identifiers), and object (i.e. another entity or its identifier ).","title":"doFind(mixed $id): object"},{"location":"ddd/repositories/#dofindbyfieldsarray-fields-object","text":"Finds the first entity matching the specified fields. See doFindAllByFields() for supported field values.","title":"doFindByFields(array $fields): object"},{"location":"ddd/repositories/#doexistsmixed-id-bool","text":"Verifies if an entity exists by its identity. See doFind() for supported identity values.","title":"doExists(mixed $id): bool"},{"location":"ddd/repositories/#doexistsbyfieldsarray-fields-bool","text":"Verifies if an entity matching the specified fields exists. See doFindAllByFields() for supported field values.","title":"doExistsByFields(array $fields): bool"},{"location":"ddd/repositories/#dosaveobject-entity-void","text":"Persists an entity into the identity map. The entity will be available on any subsequent query.","title":"doSave(object $entity): void"},{"location":"ddd/repositories/#dodeleteobject-entity-void","text":"Removes an entity from the identity map. The entity will be unavailable on any subsequent query.","title":"doDelete(object $entity): void"},{"location":"ddd/repositories/#implementations","text":"","title":"Implementations"},{"location":"ddd/repositories/#msgphpdomaininfrastructuredoctrinedomainentityrepositorytrait","text":"A Doctrine tailored repository trait. Read more","title":"MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainEntityRepositoryTrait"},{"location":"event-sourcing/event-handlers/","text":"Event Handlers \u00b6 A domain event handler is bound to MsgPhp\\Domain\\Event\\DomainEventHandler . Its purpose is to implement the handling of domain events within a certain context. Usually an entity implements it in order to mutate its own state (i.e. self-handling). It enforces the entity state to be valid by design as it encapsulates all write operations. In practice domain events can be recorded on trigger, or privately within the implementation. It allows to re-play them at any point in time afterwards. Consider this a design choice to be made upfront, e.g. in case your entity design requires its history to be accessible. API \u00b6 handleEvent(DomainEvent $event): bool \u00b6 Handles the given domain event for a known subject. A boolean return value tells if the domain event is actually handled yes or no. Implementations \u00b6 MsgPhp\\Domain\\Event\\DomainEventHandlerTrait \u00b6 A utility trait implementing the event handler API. By convention it maps events to methods named on<EventClassName>Event() . Basic Example \u00b6 <?php use MsgPhp\\Domain\\Event\\DomainEvent ; use MsgPhp\\Domain\\Event\\DomainEventHandler ; use MsgPhp\\Domain\\Event\\DomainEventHandlerTrait ; // --- SETUP --- class ChangeValue implements DomainEvent { public $newValue ; public function __construct ( $value ) { $this -> newValue = $value ; } } class MyEntity implements DomainEventHandler { use DomainEventHandlerTrait ; public $value ; private function onChangeValueEvent ( ChangeValue $event ) : bool { if ( $this -> value === $event -> newValue ) { return false ; } $this -> value = $event -> newValue ; return true ; } } // --- USAGE --- $entity = new MyEntity (); if ( $entity -> handleEvent ( new ChangeValue ( 'new value' ))) { // do something }","title":"Event Handlers"},{"location":"event-sourcing/event-handlers/#event-handlers","text":"A domain event handler is bound to MsgPhp\\Domain\\Event\\DomainEventHandler . Its purpose is to implement the handling of domain events within a certain context. Usually an entity implements it in order to mutate its own state (i.e. self-handling). It enforces the entity state to be valid by design as it encapsulates all write operations. In practice domain events can be recorded on trigger, or privately within the implementation. It allows to re-play them at any point in time afterwards. Consider this a design choice to be made upfront, e.g. in case your entity design requires its history to be accessible.","title":"Event Handlers"},{"location":"event-sourcing/event-handlers/#api","text":"","title":"API"},{"location":"event-sourcing/event-handlers/#handleeventdomainevent-event-bool","text":"Handles the given domain event for a known subject. A boolean return value tells if the domain event is actually handled yes or no.","title":"handleEvent(DomainEvent $event): bool"},{"location":"event-sourcing/event-handlers/#implementations","text":"","title":"Implementations"},{"location":"event-sourcing/event-handlers/#msgphpdomaineventdomaineventhandlertrait","text":"A utility trait implementing the event handler API. By convention it maps events to methods named on<EventClassName>Event() .","title":"MsgPhp\\Domain\\Event\\DomainEventHandlerTrait"},{"location":"event-sourcing/event-handlers/#basic-example","text":"<?php use MsgPhp\\Domain\\Event\\DomainEvent ; use MsgPhp\\Domain\\Event\\DomainEventHandler ; use MsgPhp\\Domain\\Event\\DomainEventHandlerTrait ; // --- SETUP --- class ChangeValue implements DomainEvent { public $newValue ; public function __construct ( $value ) { $this -> newValue = $value ; } } class MyEntity implements DomainEventHandler { use DomainEventHandlerTrait ; public $value ; private function onChangeValueEvent ( ChangeValue $event ) : bool { if ( $this -> value === $event -> newValue ) { return false ; } $this -> value = $event -> newValue ; return true ; } } // --- USAGE --- $entity = new MyEntity (); if ( $entity -> handleEvent ( new ChangeValue ( 'new value' ))) { // do something }","title":"Basic Example"},{"location":"event-sourcing/events/","text":"Events \u00b6 A domain event is considered domain-specific language (DSL) and is bound to MsgPhp\\Domain\\Event\\DomainEvent . Its purpose is to represent any action that can happen regarding the domain. When handled it might lead to an application state change. API \u00b6 Note This is a marker interface and has no default API Implementations \u00b6 MsgPhp\\Domain\\Event\\Confirm MsgPhp\\Domain\\Event\\Disable MsgPhp\\Domain\\Event\\Enable Basic Example \u00b6 <?php use MsgPhp\\Domain\\Model\\CanBeEnabled ; use MsgPhp\\Domain\\Event\\Enable ; use MsgPhp\\Domain\\Event\\DomainEventHandler ; use MsgPhp\\Domain\\Event\\DomainEventHandlerTrait ; // --- SETUP --- class MyEntity implements DomainEventHandler { use CanBeEnabled ; use DomainEventHandlerTrait ; } // --- USAGE --- $entity = new MyEntity (); $entity -> isEnabled (); // false $entity -> handleEvent ( new Enable ()); // true $entity -> handleEvent ( new Enable ()); // false $entity -> isEnabled (); // true Note Because CanBeEnabled defines onEnableEvent(Enable $event) it's detected in DomainEventHandlerTrait::handleEvent() by convention","title":"Events"},{"location":"event-sourcing/events/#events","text":"A domain event is considered domain-specific language (DSL) and is bound to MsgPhp\\Domain\\Event\\DomainEvent . Its purpose is to represent any action that can happen regarding the domain. When handled it might lead to an application state change.","title":"Events"},{"location":"event-sourcing/events/#api","text":"Note This is a marker interface and has no default API","title":"API"},{"location":"event-sourcing/events/#implementations","text":"MsgPhp\\Domain\\Event\\Confirm MsgPhp\\Domain\\Event\\Disable MsgPhp\\Domain\\Event\\Enable","title":"Implementations"},{"location":"event-sourcing/events/#basic-example","text":"<?php use MsgPhp\\Domain\\Model\\CanBeEnabled ; use MsgPhp\\Domain\\Event\\Enable ; use MsgPhp\\Domain\\Event\\DomainEventHandler ; use MsgPhp\\Domain\\Event\\DomainEventHandlerTrait ; // --- SETUP --- class MyEntity implements DomainEventHandler { use CanBeEnabled ; use DomainEventHandlerTrait ; } // --- USAGE --- $entity = new MyEntity (); $entity -> isEnabled (); // false $entity -> handleEvent ( new Enable ()); // true $entity -> handleEvent ( new Enable ()); // false $entity -> isEnabled (); // true Note Because CanBeEnabled defines onEnableEvent(Enable $event) it's detected in DomainEventHandlerTrait::handleEvent() by convention","title":"Basic Example"},{"location":"infrastructure/doctrine-collections/","text":"Doctrine Collections \u00b6 An overview of available infrastructural code when using Doctrine's Collections . Requires doctrine/collections Domain Collection \u00b6 A Doctrine tailored domain collection is provided by MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainCollection . Basic Example \u00b6 <?php use Doctrine\\Common\\Collections\\ArrayCollection ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainCollection ; // --- SETUP --- $collection = new DomainCollection ( new ArrayCollection ([ 1 , 2 , 3 ]));","title":"Doctrine Collections"},{"location":"infrastructure/doctrine-collections/#doctrine-collections","text":"An overview of available infrastructural code when using Doctrine's Collections . Requires doctrine/collections","title":"Doctrine Collections"},{"location":"infrastructure/doctrine-collections/#domain-collection","text":"A Doctrine tailored domain collection is provided by MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainCollection .","title":"Domain Collection"},{"location":"infrastructure/doctrine-collections/#basic-example","text":"<?php use Doctrine\\Common\\Collections\\ArrayCollection ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainCollection ; // --- SETUP --- $collection = new DomainCollection ( new ArrayCollection ([ 1 , 2 , 3 ]));","title":"Basic Example"},{"location":"infrastructure/doctrine-dbal/","text":"Doctrine Database Abstraction Layer \u00b6 An overview of available infrastructural code when using Doctrine's Database Abstraction Layer . Requires doctrine/dbal Domain Identifier Type \u00b6 A translation between the database type and an identifier type in PHP is provided by MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainIdType . Basic Example \u00b6 <?php use Doctrine\\DBAL\\Types\\Type ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainIdType ; // --- SETUP --- class MyDomainIdType extends DomainIdType { public const NAME = 'my_domain_id' ; } // --- USAGE --- MyDomainIdType :: setClass ( MyDomainId :: class ); MyDomainIdType :: setDataType ( Type :: GUID ); Type :: addType ( MyDomainIdType :: NAME , MyDomainIdType :: class ); To leverage a tailored UUID identifier use one of the UUID data types provided by ramsey/uuid-doctrine . <?php use Ramsey\\Uuid\\Doctrine\\UuidType ; MyDomainIdType :: setClass ( MyDomainUuid :: class ); MyDomainIdType :: setDataType ( UuidType :: NAME );","title":"Doctrine DBAL"},{"location":"infrastructure/doctrine-dbal/#doctrine-database-abstraction-layer","text":"An overview of available infrastructural code when using Doctrine's Database Abstraction Layer . Requires doctrine/dbal","title":"Doctrine Database Abstraction Layer"},{"location":"infrastructure/doctrine-dbal/#domain-identifier-type","text":"A translation between the database type and an identifier type in PHP is provided by MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainIdType .","title":"Domain Identifier Type"},{"location":"infrastructure/doctrine-dbal/#basic-example","text":"<?php use Doctrine\\DBAL\\Types\\Type ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainIdType ; // --- SETUP --- class MyDomainIdType extends DomainIdType { public const NAME = 'my_domain_id' ; } // --- USAGE --- MyDomainIdType :: setClass ( MyDomainId :: class ); MyDomainIdType :: setDataType ( Type :: GUID ); Type :: addType ( MyDomainIdType :: NAME , MyDomainIdType :: class ); To leverage a tailored UUID identifier use one of the UUID data types provided by ramsey/uuid-doctrine . <?php use Ramsey\\Uuid\\Doctrine\\UuidType ; MyDomainIdType :: setClass ( MyDomainUuid :: class ); MyDomainIdType :: setDataType ( UuidType :: NAME );","title":"Basic Example"},{"location":"infrastructure/doctrine-orm/","text":"Doctrine Object Relational Mapper \u00b6 An overview of available infrastructural code when using Doctrine's Object Relational Mapper . Requires doctrine/orm Domain Repository \u00b6 A Doctrine tailored repository trait is provided by MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainEntityRepositoryTrait . Basic Example \u00b6 <?php use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainEntityRepositoryTrait ; // --- SETUP --- /** * @ORM\\Entity() */ class MyEntity { /** @ORM\\Id() @ORM\\Column(type=\"string\") */ public $name ; /** @ORM\\Id() @ORM\\Column(type=\"integer\") */ public $year ; } class MyEntityRepository { use DomainEntityRepositoryTrait { doFind as public find ; doExists as public exists ; doSave as public save ; } } /** @var EntityManagerInterface $em */ $repository = new MyEntityRepository ( MyEntity :: class , $em ); // --- USAGE --- if ( $repository -> exists ( $id = [ 'name' => '...' , 'year' => date ( 'Y' )])) { $entity = $repository -> find ( $id ); } else { $entity = new MyEntity (); $entity -> name = '...' ; $entity -> year = date ( 'Y' ); $repository -> save ( $entity ); } Domain Object Factory \u00b6 A Doctrine tailored object factory is provided by MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainObjectFactory . When working with ORM inheritance the discriminator field can be provided to factorize a specific entity type. Basic Example \u00b6 <?php use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Factory\\DomainObjectFactory as BaseDomainObjectFactory ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainObjectFactory ; // --- SETUP --- /** * @ORM\\Entity() * @ORM\\InheritanceType(\"JOINED\") * @ORM\\DiscriminatorColumn(name=\"discriminator\", type=\"string\") * @ORM\\DiscriminatorMap({\"self\" = \"MyEntity\", \"other\" = \"MyOtherEntity\"}) */ class MyEntity { public const TYPE_SELF = 'self' ; public const TYPE_OTHER = 'other' ; /** @ORM\\Id() @ORM\\Column(type=\"integer\") */ public $id ; } /** * @ORM\\Entity() */ class MyOtherEntity extends MyEntity { } /** @var EntityManagerInterface $em */ $factory = new DomainObjectFactory ( new BaseDomainObjectFactory (), $em ); // --- USAGE --- /** @var MyOtherEntity $otherEntity */ $otherEntity = $factory -> create ( MyEntity :: class , [ 'discriminator' => MyEntity :: TYPE_OTHER , ]); Domain Identifier Hydration \u00b6 When working with domain identifiers and its corresponding type a problem can occur when hydrating scalar values, e.g. with Query::getScalarResult() . It would use instances of MsgPhp\\Domain\\DomainId that can only be casted to string as its (true) scalar value (due to __toString() ). In case the underlying data type is e.g. integer it will be lost. To overcome, two hydration modes are available to hydrate the primitive identifier value instead. Basic Example \u00b6 <?php use Doctrine\\DBAL\\Types\\Type ; use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\Hydration\\ScalarHydrator ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\Hydration\\SingleScalarHydrator ; // --- SETUP --- /** * @ORM\\Entity() */ class MyEntity { /** * @var MyDomainId|null * @ORM\\Id() @ORM\\Column(type=\"my_domain_id\") */ public $id ; } MyDomainIdType :: setClass ( MyDomainId :: class ); MyDomainIdType :: setDataType ( Type :: INTEGER ); Type :: addType ( MyDomainIdType :: NAME , MyDomainIdType :: class ); /** @var EntityManagerInterface $em */ $config = $em -> getConfiguration (); $config -> addCustomHydrationMode ( ScalarHydrator :: NAME , ScalarHydrator :: class ); $config -> addCustomHydrationMode ( SingleScalarHydrator :: NAME , SingleScalarHydrator :: class ); // --- USAGE --- $query = $em -> createQuery ( 'SELECT entity.id FROM MyEntity entity' ); $query -> getScalarResult ()[ 0 ][ 'id' ]; // \"1\" $query -> getResult ( ScalarHydrator :: NAME )[ 0 ][ 'id' ]; // int(1) $query -> getSingleScalarResult (); // \"1\" $query -> getSingleResult ( SingleScalarHydrator :: NAME ); // int(1)","title":"Doctrine ORM"},{"location":"infrastructure/doctrine-orm/#doctrine-object-relational-mapper","text":"An overview of available infrastructural code when using Doctrine's Object Relational Mapper . Requires doctrine/orm","title":"Doctrine Object Relational Mapper"},{"location":"infrastructure/doctrine-orm/#domain-repository","text":"A Doctrine tailored repository trait is provided by MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainEntityRepositoryTrait .","title":"Domain Repository"},{"location":"infrastructure/doctrine-orm/#basic-example","text":"<?php use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainEntityRepositoryTrait ; // --- SETUP --- /** * @ORM\\Entity() */ class MyEntity { /** @ORM\\Id() @ORM\\Column(type=\"string\") */ public $name ; /** @ORM\\Id() @ORM\\Column(type=\"integer\") */ public $year ; } class MyEntityRepository { use DomainEntityRepositoryTrait { doFind as public find ; doExists as public exists ; doSave as public save ; } } /** @var EntityManagerInterface $em */ $repository = new MyEntityRepository ( MyEntity :: class , $em ); // --- USAGE --- if ( $repository -> exists ( $id = [ 'name' => '...' , 'year' => date ( 'Y' )])) { $entity = $repository -> find ( $id ); } else { $entity = new MyEntity (); $entity -> name = '...' ; $entity -> year = date ( 'Y' ); $repository -> save ( $entity ); }","title":"Basic Example"},{"location":"infrastructure/doctrine-orm/#domain-object-factory","text":"A Doctrine tailored object factory is provided by MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainObjectFactory . When working with ORM inheritance the discriminator field can be provided to factorize a specific entity type.","title":"Domain Object Factory"},{"location":"infrastructure/doctrine-orm/#basic-example_1","text":"<?php use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Factory\\DomainObjectFactory as BaseDomainObjectFactory ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\DomainObjectFactory ; // --- SETUP --- /** * @ORM\\Entity() * @ORM\\InheritanceType(\"JOINED\") * @ORM\\DiscriminatorColumn(name=\"discriminator\", type=\"string\") * @ORM\\DiscriminatorMap({\"self\" = \"MyEntity\", \"other\" = \"MyOtherEntity\"}) */ class MyEntity { public const TYPE_SELF = 'self' ; public const TYPE_OTHER = 'other' ; /** @ORM\\Id() @ORM\\Column(type=\"integer\") */ public $id ; } /** * @ORM\\Entity() */ class MyOtherEntity extends MyEntity { } /** @var EntityManagerInterface $em */ $factory = new DomainObjectFactory ( new BaseDomainObjectFactory (), $em ); // --- USAGE --- /** @var MyOtherEntity $otherEntity */ $otherEntity = $factory -> create ( MyEntity :: class , [ 'discriminator' => MyEntity :: TYPE_OTHER , ]);","title":"Basic Example"},{"location":"infrastructure/doctrine-orm/#domain-identifier-hydration","text":"When working with domain identifiers and its corresponding type a problem can occur when hydrating scalar values, e.g. with Query::getScalarResult() . It would use instances of MsgPhp\\Domain\\DomainId that can only be casted to string as its (true) scalar value (due to __toString() ). In case the underlying data type is e.g. integer it will be lost. To overcome, two hydration modes are available to hydrate the primitive identifier value instead.","title":"Domain Identifier Hydration"},{"location":"infrastructure/doctrine-orm/#basic-example_2","text":"<?php use Doctrine\\DBAL\\Types\\Type ; use Doctrine\\ORM\\EntityManagerInterface ; use Doctrine\\ORM\\Mapping as ORM ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\Hydration\\ScalarHydrator ; use MsgPhp\\Domain\\Infrastructure\\Doctrine\\Hydration\\SingleScalarHydrator ; // --- SETUP --- /** * @ORM\\Entity() */ class MyEntity { /** * @var MyDomainId|null * @ORM\\Id() @ORM\\Column(type=\"my_domain_id\") */ public $id ; } MyDomainIdType :: setClass ( MyDomainId :: class ); MyDomainIdType :: setDataType ( Type :: INTEGER ); Type :: addType ( MyDomainIdType :: NAME , MyDomainIdType :: class ); /** @var EntityManagerInterface $em */ $config = $em -> getConfiguration (); $config -> addCustomHydrationMode ( ScalarHydrator :: NAME , ScalarHydrator :: class ); $config -> addCustomHydrationMode ( SingleScalarHydrator :: NAME , SingleScalarHydrator :: class ); // --- USAGE --- $query = $em -> createQuery ( 'SELECT entity.id FROM MyEntity entity' ); $query -> getScalarResult ()[ 0 ][ 'id' ]; // \"1\" $query -> getResult ( ScalarHydrator :: NAME )[ 0 ][ 'id' ]; // int(1) $query -> getSingleScalarResult (); // \"1\" $query -> getSingleResult ( SingleScalarHydrator :: NAME ); // int(1)","title":"Basic Example"},{"location":"infrastructure/elasticsearch/","text":"Elasticsearch \u00b6 An overview of available infrastructural code when using Elasticsearch's PHP Api . Requires elasticsearch/elasticsearch Projection Type Registry \u00b6 An Elasticsearch tailored projection type registry is provided by MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionTypeRegistry . It works directly with any Client and a known configuration of type information. __construct(Client $client, string $prefix, array $mappings, array $settings = [], LoggerInterface $logger = null) $client : The client to work with $prefix : The index prefix $mappings : Index mappings keyed by type $settings : Index settings keyed by type (use '*' => [...] for default settings) $logger : An optional PSR logger Basic Example \u00b6 <?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionTypeRegistry ; // --- SETUP --- /** @var Client $client */ $typeRegistry = new ProjectionTypeRegistry ( $client , 'app_dev-' , [ 'my_projection' => [ 'some_field' => 'some_type' , // defaults to ['type' => 'some_type'] 'other_field' => [ // defaults to ['type' => 'text', ...] // ... ], ], ]); Projection Repository \u00b6 An Elasticsearch tailored projection repository is provided by MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionRepository . It works directly with any Client . __construct(Client $client, string $prefix) $client : The Client to work with $prefix : The index prefix Basic Example \u00b6 <?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionRepository ; // --- SETUP --- /** @var Client $client */ $repository = new ProjectionRepository ( $client , 'app_dev-' );","title":"Elasticsearch"},{"location":"infrastructure/elasticsearch/#elasticsearch","text":"An overview of available infrastructural code when using Elasticsearch's PHP Api . Requires elasticsearch/elasticsearch","title":"Elasticsearch"},{"location":"infrastructure/elasticsearch/#projection-type-registry","text":"An Elasticsearch tailored projection type registry is provided by MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionTypeRegistry . It works directly with any Client and a known configuration of type information. __construct(Client $client, string $prefix, array $mappings, array $settings = [], LoggerInterface $logger = null) $client : The client to work with $prefix : The index prefix $mappings : Index mappings keyed by type $settings : Index settings keyed by type (use '*' => [...] for default settings) $logger : An optional PSR logger","title":"Projection Type Registry"},{"location":"infrastructure/elasticsearch/#basic-example","text":"<?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionTypeRegistry ; // --- SETUP --- /** @var Client $client */ $typeRegistry = new ProjectionTypeRegistry ( $client , 'app_dev-' , [ 'my_projection' => [ 'some_field' => 'some_type' , // defaults to ['type' => 'some_type'] 'other_field' => [ // defaults to ['type' => 'text', ...] // ... ], ], ]);","title":"Basic Example"},{"location":"infrastructure/elasticsearch/#projection-repository","text":"An Elasticsearch tailored projection repository is provided by MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionRepository . It works directly with any Client . __construct(Client $client, string $prefix) $client : The Client to work with $prefix : The index prefix","title":"Projection Repository"},{"location":"infrastructure/elasticsearch/#basic-example_1","text":"<?php use Elasticsearch\\Client ; use MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionRepository ; // --- SETUP --- /** @var Client $client */ $repository = new ProjectionRepository ( $client , 'app_dev-' );","title":"Basic Example"},{"location":"infrastructure/symfony-console/","text":"Symfony Console \u00b6 An overview of available infrastructural code when using Symfony Console . Requires symfony/console Commands \u00b6 Various standard console commands are available and can be used depending on implemented domain infrastructure. They are defined in the MsgPhp\\Domain\\Infrastructure\\Console\\Command\\ namespace. SynchronizeProjectionsCommand \u00b6 Synchronizes domain objects and their projections using the projection synchronization utility service. bin/console projection:synchronize Context Definition \u00b6 A context definition is bound to MsgPhp\\Domain\\Infrastructure\\Console\\Definition\\DomainContextDefinition . Its purpose is to (interactively) build a context array using the CLI . API \u00b6 configure(InputDefinition $definition): void \u00b6 Configures a command input definition. See also InputDefinition . Should be called before using getContext() . getContext(InputInterface $input, StyleInterface $io, array $values = []): array \u00b6 Resolves the actual context from the console IO. See also InputInterface and StyleInterface . Any element value provided by $values takes precedence and should be used as-is. Implementations \u00b6 MsgPhp\\Domain\\Infrastructure\\Console\\Definition\\ClassContextDefinition \u00b6 Creates a context based on any class method signature. It configures the CLI signature by mapping required method arguments to command arguments, whereas optional ones are mapped to command options. In both cases a value is optional, if the actual class method argument is required and no value is given it will be asked interactively. If interaction is not possible an exception will be thrown instead. __construct(string $class, string $method, array $classMapping = [], int $flags = 0, ClassContextElementFactory $elementFactory = null) $class / $method : The class method to resolve $classMapping : Global class mapping. Usually used to map abstracts to concretes. $flags : A bit mask value to toggle various flags ClassContextBuilder::ALWAYS_OPTIONAL : Always map class method arguments to command options ClassContextBuilder::NO_DEFAULTS : Leave out default values when calling getContext() ClassContextBuilder::REUSE_DEFINITION : Reuse the original input definition for matching class method arguments $elementFactory : A custom element factory to use. See also Customizing context elements . Customizing Context Elements \u00b6 Per-element configuration can be provided by implementing a MsgPhp\\Domain\\Infrastructure\\Console\\Context\\ClassContextElementFactory . getElement(string $class, string $method, string $argument): ContextElement Get a custom ContextElement to apply to a specific class/method/argument pair A default implementation is provided by MsgPhp\\Domain\\Infrastructure\\Console\\Context\\ClassContextElementFactory which simply transforms argument names to human readable values so that $argumentName becomes Argument Name . Basic Example \u00b6 <?php use MsgPhp\\Domain\\Infrastructure\\Console\\Definition\\ClassContextDefinition ; use Symfony\\Component\\Console\\Command\\Command ; use Symfony\\Component\\Console\\Input\\InputInterface ; use Symfony\\Component\\Console\\Output\\OutputInterface ; use Symfony\\Component\\Console\\Style\\SymfonyStyle ; // --- SETUP --- class MyObject { public function __construct ( string $argument , $option = null ) { } } class MyCommand extends Command { private $definition ; public function __construct () { $this -> definition = new ClassContextDefinition ( MyObject :: class , '__construct' ); parent :: __construct (); } protected function configure () : void { $this -> setName ( 'my-command' ); $this -> definition -> configure ( $this -> getDefinition ()); } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $io = new SymfonyStyle ( $input , $output ); $context = $this -> definition -> getContext ( $input , $io ); $object = new MyObject ( ... array_values ( $context )); // do something return 0 ; } } // --- USAGE --- // $ bin/console my-command [--option=OPTION] [--] [<argument>] MsgPhp\\Domain\\Infrastructure\\Console\\Definition\\DoctrineContextDefintion \u00b6 Use the Doctrine context definition to provide a class discriminator value into the final context. Typically this implementation is used when working with ORM inheritance . __construct(DomainContextDefinition $definition, EntityManagerInterface $em, string $class) $definition : The decorated context definition $em : The entity manager to use $class : The entity class to use","title":"Symfony Console"},{"location":"infrastructure/symfony-console/#symfony-console","text":"An overview of available infrastructural code when using Symfony Console . Requires symfony/console","title":"Symfony Console"},{"location":"infrastructure/symfony-console/#commands","text":"Various standard console commands are available and can be used depending on implemented domain infrastructure. They are defined in the MsgPhp\\Domain\\Infrastructure\\Console\\Command\\ namespace.","title":"Commands"},{"location":"infrastructure/symfony-console/#synchronizeprojectionscommand","text":"Synchronizes domain objects and their projections using the projection synchronization utility service. bin/console projection:synchronize","title":"SynchronizeProjectionsCommand"},{"location":"infrastructure/symfony-console/#context-definition","text":"A context definition is bound to MsgPhp\\Domain\\Infrastructure\\Console\\Definition\\DomainContextDefinition . Its purpose is to (interactively) build a context array using the CLI .","title":"Context Definition"},{"location":"infrastructure/symfony-console/#api","text":"","title":"API"},{"location":"infrastructure/symfony-console/#configureinputdefinition-definition-void","text":"Configures a command input definition. See also InputDefinition . Should be called before using getContext() .","title":"configure(InputDefinition $definition): void"},{"location":"infrastructure/symfony-console/#getcontextinputinterface-input-styleinterface-io-array-values-array","text":"Resolves the actual context from the console IO. See also InputInterface and StyleInterface . Any element value provided by $values takes precedence and should be used as-is.","title":"getContext(InputInterface $input, StyleInterface $io, array $values = []): array"},{"location":"infrastructure/symfony-console/#implementations","text":"","title":"Implementations"},{"location":"infrastructure/symfony-console/#msgphpdomaininfrastructureconsoledefinitionclasscontextdefinition","text":"Creates a context based on any class method signature. It configures the CLI signature by mapping required method arguments to command arguments, whereas optional ones are mapped to command options. In both cases a value is optional, if the actual class method argument is required and no value is given it will be asked interactively. If interaction is not possible an exception will be thrown instead. __construct(string $class, string $method, array $classMapping = [], int $flags = 0, ClassContextElementFactory $elementFactory = null) $class / $method : The class method to resolve $classMapping : Global class mapping. Usually used to map abstracts to concretes. $flags : A bit mask value to toggle various flags ClassContextBuilder::ALWAYS_OPTIONAL : Always map class method arguments to command options ClassContextBuilder::NO_DEFAULTS : Leave out default values when calling getContext() ClassContextBuilder::REUSE_DEFINITION : Reuse the original input definition for matching class method arguments $elementFactory : A custom element factory to use. See also Customizing context elements .","title":"MsgPhp\\Domain\\Infrastructure\\Console\\Definition\\ClassContextDefinition"},{"location":"infrastructure/symfony-console/#customizing-context-elements","text":"Per-element configuration can be provided by implementing a MsgPhp\\Domain\\Infrastructure\\Console\\Context\\ClassContextElementFactory . getElement(string $class, string $method, string $argument): ContextElement Get a custom ContextElement to apply to a specific class/method/argument pair A default implementation is provided by MsgPhp\\Domain\\Infrastructure\\Console\\Context\\ClassContextElementFactory which simply transforms argument names to human readable values so that $argumentName becomes Argument Name .","title":"Customizing Context Elements"},{"location":"infrastructure/symfony-console/#basic-example","text":"<?php use MsgPhp\\Domain\\Infrastructure\\Console\\Definition\\ClassContextDefinition ; use Symfony\\Component\\Console\\Command\\Command ; use Symfony\\Component\\Console\\Input\\InputInterface ; use Symfony\\Component\\Console\\Output\\OutputInterface ; use Symfony\\Component\\Console\\Style\\SymfonyStyle ; // --- SETUP --- class MyObject { public function __construct ( string $argument , $option = null ) { } } class MyCommand extends Command { private $definition ; public function __construct () { $this -> definition = new ClassContextDefinition ( MyObject :: class , '__construct' ); parent :: __construct (); } protected function configure () : void { $this -> setName ( 'my-command' ); $this -> definition -> configure ( $this -> getDefinition ()); } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $io = new SymfonyStyle ( $input , $output ); $context = $this -> definition -> getContext ( $input , $io ); $object = new MyObject ( ... array_values ( $context )); // do something return 0 ; } } // --- USAGE --- // $ bin/console my-command [--option=OPTION] [--] [<argument>]","title":"Basic Example"},{"location":"infrastructure/symfony-console/#msgphpdomaininfrastructureconsoledefinitiondoctrinecontextdefintion","text":"Use the Doctrine context definition to provide a class discriminator value into the final context. Typically this implementation is used when working with ORM inheritance . __construct(DomainContextDefinition $definition, EntityManagerInterface $em, string $class) $definition : The decorated context definition $em : The entity manager to use $class : The entity class to use","title":"MsgPhp\\Domain\\Infrastructure\\Console\\Definition\\DoctrineContextDefintion"},{"location":"infrastructure/symfony-messenger/","text":"Symfony Messenger \u00b6 An overview of available infrastructural code when using Symfony Messenger . Requires symfony/messenger Domain Message Bus \u00b6 A Symfony Messenger tailored domain message bus is provided by MsgPhp\\Domain\\Infrastructure\\Messenger\\DomainMessageBus . Basic Example \u00b6 <?php use MsgPhp\\Domain\\Infrastructure\\Messenger\\DomainMessageBus ; use Symfony\\Component\\Messenger\\MessageBusInterface ; // --- SETUP --- class CommandMessage { } class EventMessage { } /** @var MessageBusInterface $commandBus */ /** @var MessageBusInterface $eventBus */ $domainBus = new DomainMessageBus ( $commandBus , $eventBus , [ EventMessage :: class ]); // --- USAGE --- $domainBus -> dispatch ( new CommandMessage ()); $domainBus -> dispatch ( new EventMessage ());","title":"Symfony Messenger"},{"location":"infrastructure/symfony-messenger/#symfony-messenger","text":"An overview of available infrastructural code when using Symfony Messenger . Requires symfony/messenger","title":"Symfony Messenger"},{"location":"infrastructure/symfony-messenger/#domain-message-bus","text":"A Symfony Messenger tailored domain message bus is provided by MsgPhp\\Domain\\Infrastructure\\Messenger\\DomainMessageBus .","title":"Domain Message Bus"},{"location":"infrastructure/symfony-messenger/#basic-example","text":"<?php use MsgPhp\\Domain\\Infrastructure\\Messenger\\DomainMessageBus ; use Symfony\\Component\\Messenger\\MessageBusInterface ; // --- SETUP --- class CommandMessage { } class EventMessage { } /** @var MessageBusInterface $commandBus */ /** @var MessageBusInterface $eventBus */ $domainBus = new DomainMessageBus ( $commandBus , $eventBus , [ EventMessage :: class ]); // --- USAGE --- $domainBus -> dispatch ( new CommandMessage ()); $domainBus -> dispatch ( new EventMessage ());","title":"Basic Example"},{"location":"infrastructure/uuid/","text":"Universally Unique Identifier \u00b6 An overview of available infrastructural code when working with UUIDs . Requires ramsey/uuid Domain Identifier \u00b6 A UUID tailored domain identifier trait is provided by MsgPhp\\Domain\\Infrastructure\\Uuid\\DomainIdTrait . Basic Example \u00b6 <?php use MsgPhp\\Domain\\DomainId ; use MsgPhp\\Domain\\Infrastructure\\Uuid\\DomainIdTrait ; use Ramsey\\Uuid\\Uuid ; // --- SETUP --- class MyDomainUuid implements DomainId { use DomainIdTrait ; } $id = new MyDomainUuid (); // a new UUID version 4 value $id = new MyDomainUuid ( Uuid :: uuid1 ()); $id = new MyDomainUuid ( Uuid :: fromString ( '00000000-0000-0000-0000-000000000000' ));","title":"UUID"},{"location":"infrastructure/uuid/#universally-unique-identifier","text":"An overview of available infrastructural code when working with UUIDs . Requires ramsey/uuid","title":"Universally Unique Identifier"},{"location":"infrastructure/uuid/#domain-identifier","text":"A UUID tailored domain identifier trait is provided by MsgPhp\\Domain\\Infrastructure\\Uuid\\DomainIdTrait .","title":"Domain Identifier"},{"location":"infrastructure/uuid/#basic-example","text":"<?php use MsgPhp\\Domain\\DomainId ; use MsgPhp\\Domain\\Infrastructure\\Uuid\\DomainIdTrait ; use Ramsey\\Uuid\\Uuid ; // --- SETUP --- class MyDomainUuid implements DomainId { use DomainIdTrait ; } $id = new MyDomainUuid (); // a new UUID version 4 value $id = new MyDomainUuid ( Uuid :: uuid1 ()); $id = new MyDomainUuid ( Uuid :: fromString ( '00000000-0000-0000-0000-000000000000' ));","title":"Basic Example"},{"location":"projection/models/","text":"Projections \u00b6 Projection models are \" vanilla PHP objects\". Its purpose is to represent a stored document. The projection is usually a transformation from a domain object (e.g. an entity) and therefor projections should be considered read-only and disposable, given they can be re-created / synchronized at any point in time from a source of truth (the repository). A practical use case for projections are APIs, where each API resource is a so called projection, corresponding to its domain entity. It enables decoupling and thus optimized API responses.","title":"Models"},{"location":"projection/models/#projections","text":"Projection models are \" vanilla PHP objects\". Its purpose is to represent a stored document. The projection is usually a transformation from a domain object (e.g. an entity) and therefor projections should be considered read-only and disposable, given they can be re-created / synchronized at any point in time from a source of truth (the repository). A practical use case for projections are APIs, where each API resource is a so called projection, corresponding to its domain entity. It enables decoupling and thus optimized API responses.","title":"Projections"},{"location":"projection/repositories/","text":"Projection Repositories \u00b6 A projection repository is bound to MsgPhp\\Domain\\Projection\\ProjectionRepository . Its purpose is to store and query projection documents. API \u00b6 find(string $type, string $id): ?array \u00b6 Finds a single projection document by type and ID. In case the document cannot be found null should be returned. save(string $type, array $document): void \u00b6 Saves a projection document. The document will be available on any subsequent query. saveAll(string $type, iterable<int, array> $documents): void \u00b6 Saves all projection documents at once. The documents will be available on any subsequent query. delete(string $type, string $id): bool \u00b6 Deletes a projection document by type and ID. The document will be unavailable on any subsequent query. A boolean return value indicates the document was actually deleted yes or no. Implementations \u00b6 MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionRepository \u00b6 An Elasticsearch tailored projection repository. Read more Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ProjectionRepository ; // --- USAGE --- /** @var ProjectionRepository $repository */ $document = $repository -> find ( 'my_projection' , 'ID' ); if ( null === $document ) { $document = [ 'id' => 'ID' , 'some_field' => 'value' ]; $repository -> save ( 'my_projection' , $document ); }","title":"Repositories"},{"location":"projection/repositories/#projection-repositories","text":"A projection repository is bound to MsgPhp\\Domain\\Projection\\ProjectionRepository . Its purpose is to store and query projection documents.","title":"Projection Repositories"},{"location":"projection/repositories/#api","text":"","title":"API"},{"location":"projection/repositories/#findstring-type-string-id-array","text":"Finds a single projection document by type and ID. In case the document cannot be found null should be returned.","title":"find(string $type, string $id): ?array"},{"location":"projection/repositories/#savestring-type-array-document-void","text":"Saves a projection document. The document will be available on any subsequent query.","title":"save(string $type, array $document): void"},{"location":"projection/repositories/#saveallstring-type-iterableltint-arraygt-documents-void","text":"Saves all projection documents at once. The documents will be available on any subsequent query.","title":"saveAll(string $type, iterable&lt;int, array&gt; $documents): void"},{"location":"projection/repositories/#deletestring-type-string-id-bool","text":"Deletes a projection document by type and ID. The document will be unavailable on any subsequent query. A boolean return value indicates the document was actually deleted yes or no.","title":"delete(string $type, string $id): bool"},{"location":"projection/repositories/#implementations","text":"","title":"Implementations"},{"location":"projection/repositories/#msgphpdomaininfrastructureelasticsearchprojectionrepository","text":"An Elasticsearch tailored projection repository. Read more","title":"MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionRepository"},{"location":"projection/repositories/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ProjectionRepository ; // --- USAGE --- /** @var ProjectionRepository $repository */ $document = $repository -> find ( 'my_projection' , 'ID' ); if ( null === $document ) { $document = [ 'id' => 'ID' , 'some_field' => 'value' ]; $repository -> save ( 'my_projection' , $document ); }","title":"Basic example"},{"location":"projection/synchronization/","text":"Projection Synchronization \u00b6 MsgPhp\\Domain\\Projection\\ProjectionSynchronization is a utility domain service. Its purpose is to ease synchronizing projection documents from source objects. API \u00b6 synchronize(): int \u00b6 Synchronizes all projections. Returns the no. of projections synchronized. Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ProjectionDocumentProvider ; use MsgPhp\\Domain\\Projection\\ProjectionRepository ; use MsgPhp\\Domain\\Projection\\ProjectionSynchronization ; use MsgPhp\\Domain\\Projection\\ProjectionTypeRegistry ; // --- SETUP --- class MyEntity { } /** @var ProjectionTypeRegistry $typeRegistry */ /** @var ProjectionRepository $repository */ $provider = new ProjectionDocumentProvider ([ function () : iterable { yield new MyEntity (); yield new MyEntity (); }, ], function ( object $object ) : array { return ( array ) $object ; }, function ( object $object ) : string { return 'index' ; }); $synchronization = new ProjectionSynchronization ( $typeRegistry , $repository , $provider ); // --- USAGE --- $numProjections = $synchronization -> synchronize (); Command Line Interface \u00b6 A synchronization can be ran using the CLI when working with Symfony Console. Read more","title":"Synchronization"},{"location":"projection/synchronization/#projection-synchronization","text":"MsgPhp\\Domain\\Projection\\ProjectionSynchronization is a utility domain service. Its purpose is to ease synchronizing projection documents from source objects.","title":"Projection Synchronization"},{"location":"projection/synchronization/#api","text":"","title":"API"},{"location":"projection/synchronization/#synchronize-int","text":"Synchronizes all projections. Returns the no. of projections synchronized.","title":"synchronize(): int"},{"location":"projection/synchronization/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ProjectionDocumentProvider ; use MsgPhp\\Domain\\Projection\\ProjectionRepository ; use MsgPhp\\Domain\\Projection\\ProjectionSynchronization ; use MsgPhp\\Domain\\Projection\\ProjectionTypeRegistry ; // --- SETUP --- class MyEntity { } /** @var ProjectionTypeRegistry $typeRegistry */ /** @var ProjectionRepository $repository */ $provider = new ProjectionDocumentProvider ([ function () : iterable { yield new MyEntity (); yield new MyEntity (); }, ], function ( object $object ) : array { return ( array ) $object ; }, function ( object $object ) : string { return 'index' ; }); $synchronization = new ProjectionSynchronization ( $typeRegistry , $repository , $provider ); // --- USAGE --- $numProjections = $synchronization -> synchronize ();","title":"Basic example"},{"location":"projection/synchronization/#command-line-interface","text":"A synchronization can be ran using the CLI when working with Symfony Console. Read more","title":"Command Line Interface"},{"location":"projection/type-registry/","text":"Projection Type Registry \u00b6 A projection type registry is bound to MsgPhp\\Domain\\Projection\\ProjectionTypeRegistry . Its purpose is to manage all available projection type information. API \u00b6 initialize(string ...$type): void \u00b6 Initializes the registry. Usually needs to be called only once per environment, or after any type information has changed. destroy(string ...$type): void \u00b6 Destroys the registry and thus requires to be re-initialized after. Implementations \u00b6 MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionTypeRegistry \u00b6 An Elasticsearch tailored projection type registry. Read more Basic example \u00b6 <?php use MsgPhp\\Domain\\Projection\\ProjectionTypeRegistry ; // --- USAGE --- /** @var ProjectionTypeRegistry $typeRegistry */ $typeRegistry -> destroy (); $typeRegistry -> initialize ();","title":"Type Registry"},{"location":"projection/type-registry/#projection-type-registry","text":"A projection type registry is bound to MsgPhp\\Domain\\Projection\\ProjectionTypeRegistry . Its purpose is to manage all available projection type information.","title":"Projection Type Registry"},{"location":"projection/type-registry/#api","text":"","title":"API"},{"location":"projection/type-registry/#initializestring-type-void","text":"Initializes the registry. Usually needs to be called only once per environment, or after any type information has changed.","title":"initialize(string ...$type): void"},{"location":"projection/type-registry/#destroystring-type-void","text":"Destroys the registry and thus requires to be re-initialized after.","title":"destroy(string ...$type): void"},{"location":"projection/type-registry/#implementations","text":"","title":"Implementations"},{"location":"projection/type-registry/#msgphpdomaininfrastructureelasticsearchprojectiontyperegistry","text":"An Elasticsearch tailored projection type registry. Read more","title":"MsgPhp\\Domain\\Infrastructure\\Elasticsearch\\ProjectionTypeRegistry"},{"location":"projection/type-registry/#basic-example","text":"<?php use MsgPhp\\Domain\\Projection\\ProjectionTypeRegistry ; // --- USAGE --- /** @var ProjectionTypeRegistry $typeRegistry */ $typeRegistry -> destroy (); $typeRegistry -> initialize ();","title":"Basic example"}]}