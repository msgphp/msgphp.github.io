{
    "docs": [
        {
            "location": "/", 
            "text": "MsgPHP Documentation\n\n\n\n\nMsgPHP\n is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.\n\n\n\n\n\n\nNews\n\n\n\n\n2018-02-18\n Added initial \ninfrastructure\n chapter\n\n\n2018-02-12\n Added \ndomain identities\n chapter\n\n\n2018-01-27\n Added initial \nmessage driven\n chapter\n\n\n2018-01-26\n Added initial \nevent sourcing\n chapter\n\n\n2018-01-25\n Added initial project \ncode conventions\n\n\n2018-01-18\n Initial documentation setup. Work in progress as of today.", 
            "title": "Home"
        }, 
        {
            "location": "/#msgphp-documentation", 
            "text": "MsgPHP  is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.", 
            "title": "MsgPHP Documentation"
        }, 
        {
            "location": "/#news", 
            "text": "2018-02-18  Added initial  infrastructure  chapter  2018-02-12  Added  domain identities  chapter  2018-01-27  Added initial  message driven  chapter  2018-01-26  Added initial  event sourcing  chapter  2018-01-25  Added initial project  code conventions  2018-01-18  Initial documentation setup. Work in progress as of today.", 
            "title": "News"
        }, 
        {
            "location": "/code-conventions/", 
            "text": "Code conventions\n\n\nA brief description of code conventions this project follows.\n\n\nGeneral principles\n\n\n\n\nNo \nSOLID\n violations, yet be pragmatic\n\n\nReduce \nlines of code\n where possible\n\n\nReduce coupling (\nLoD\n)\n\n\nFavor latest stable PHP7 features\n\n\nChecks must pass (code style, static analysis \n unit tests)\n\n\nAdd PHPDoc / comments if needed for clarification or static analysis\n\n\n\n\nCode style\n\n\n\n\nFollows PSR2 and Symfony style\n\n\nuse\n statements are declared in alpha-order\n\n\nuse\n statements for \nMsgPhp\\\n namespace are grouped by deepest common namespace\n\n\n\n\n?php\n\n\n\n// wrong\n\n\nuse\n \nMsgPhp\\SomeB\n;\n\n\nuse\n \nMsgPhp\\SomeA\n;\n\n\nuse\n \nMsgPhp\\Some\\SomeC\n;\n\n\nuse\n \nOther\\SomeOtherB\n;\n\n\nuse\n \nOther\\Some\\SomeOtherC\n;\n\n\nuse\n \nOther\\SomeOtherA\n;\n\n\n\n// right\n\n\nuse\n \nMsgPhp\\Some\\SomeC\n;\n\n\nuse\n \nMsgPhp\\\n{\nSomeA\n,\n \nSomeB\n};\n\n\nuse\n \nOther\\Some\\SomeOtherC\n;\n\n\nuse\n \nOther\\SomeOtherA\n;\n\n\nuse\n \nOther\\SomeOtherB\n;\n\n\n\n\n\n\nStatic analysis\n\n\n\n\nFollows PHPStan level max\n\n\nExclude / ignore rules are discussed per case/topic\n\n\n\n\nPHP 7.x forward compatibility\n\n\n\n\nIntended object values are type hinted (\n@param object $value\n and \n@return object\n)\n\n\n\n\nUnit tests\n\n\n\n\nAll of the above, \nin general\n, applies to unit tests as well", 
            "title": "Code conventions"
        }, 
        {
            "location": "/code-conventions/#code-conventions", 
            "text": "A brief description of code conventions this project follows.", 
            "title": "Code conventions"
        }, 
        {
            "location": "/code-conventions/#general-principles", 
            "text": "No  SOLID  violations, yet be pragmatic  Reduce  lines of code  where possible  Reduce coupling ( LoD )  Favor latest stable PHP7 features  Checks must pass (code style, static analysis   unit tests)  Add PHPDoc / comments if needed for clarification or static analysis", 
            "title": "General principles"
        }, 
        {
            "location": "/code-conventions/#code-style", 
            "text": "Follows PSR2 and Symfony style  use  statements are declared in alpha-order  use  statements for  MsgPhp\\  namespace are grouped by deepest common namespace   ?php  // wrong  use   MsgPhp\\SomeB ;  use   MsgPhp\\SomeA ;  use   MsgPhp\\Some\\SomeC ;  use   Other\\SomeOtherB ;  use   Other\\Some\\SomeOtherC ;  use   Other\\SomeOtherA ;  // right  use   MsgPhp\\Some\\SomeC ;  use   MsgPhp\\ { SomeA ,   SomeB };  use   Other\\Some\\SomeOtherC ;  use   Other\\SomeOtherA ;  use   Other\\SomeOtherB ;", 
            "title": "Code style"
        }, 
        {
            "location": "/code-conventions/#static-analysis", 
            "text": "Follows PHPStan level max  Exclude / ignore rules are discussed per case/topic", 
            "title": "Static analysis"
        }, 
        {
            "location": "/code-conventions/#php-7x-forward-compatibility", 
            "text": "Intended object values are type hinted ( @param object $value  and  @return object )", 
            "title": "PHP 7.x forward compatibility"
        }, 
        {
            "location": "/code-conventions/#unit-tests", 
            "text": "All of the above,  in general , applies to unit tests as well", 
            "title": "Unit tests"
        }, 
        {
            "location": "/ddd/identifiers/", 
            "text": "Identifiers\n\n\nA domain identifier is a \nstring-ish\n value\nobject and bound to \nMsgPhp\\Domain\\DomainIdInterface\n. Its purpose is to utilize a primitive identifier value.\n\n\nAPI\n\n\nExtends\n\n\n\n\n\\Serializable\n\n\n\\JsonSerializable\n\n\n\n\n\n\nstatic fromValue($value): DomainIdInterface\n\n\nFactorizes a new identifier from its primitive value. Using \nnull\n might imply an empty identifier.\n\n\n\n\nisEmpty(): bool\n\n\nTells if an identifier value is considered empty, thus has no known primitive value.\n\n\n\n\nequals(DomainIdInterface $id): bool\n\n\nTells if an identifier equals another identifier.\n\n\n\n\ntoString(): string\n / \n__toString(): string\n\n\nReturns the identifier its primitive string value. If the identifier is empty (see \nisEmpty()\n) an empty string (\n\"\"\n) \nshould be returned.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\DomainId\n\n\nA first class citizen domain identifier. It leverages \nstring|null\n as underlying data type.\n\n\n\n\n__construct(string $id = null)\n\n\n$id\n: The primitive identifier value. In case of \nnull\n an empty identifier is implied.\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nOtherDomainId\n \nextends\n \nDomainId\n\n\n{\n\n\n}\n\n\n\n$emptyId\n \n=\n \nnew\n \nDomainId\n();\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\n1\n);\n\n\n\n// --- USAGE ---\n\n\n\n$emptyId\n-\nisEmpty\n();\n \n// true\n\n\n$id\n-\nisEmpty\n();\n \n// false\n\n\n\n$emptyId\n-\nequals\n(\n$emptyId\n);\n \n// true\n\n\n$emptyId\n-\nequals\n(\nnew\n \nDomainId\n());\n \n// false\n\n\n$id\n-\nequals\n(\nnew\n \nDomainId\n(\n1\n));\n \n// true\n\n\n$id\n-\nequals\n(\nnew\n \nOtherDomainId\n(\n1\n));\n \n// false due type varying\n\n\n\n$emptyId\n-\ntoString\n();\n \n// \n\n\n(\nstring\n)\n \n$id\n;\n \n// \n1\n\n\n\n$emptyStringId\n \n=\n \nnew\n \nDomainId\n(\n);\n\n\n$emptyStringId\n-\nisEmpty\n()\n \n?\n \nnull\n \n:\n \n$emptyStringId\n-\ntoString\n();\n \n// \n\n\n$emptyId\n-\nisEmpty\n()\n \n?\n \nnull\n \n:\n \n$emptyId\n-\ntoString\n();\n \n// null\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n\n\nDomain identifier based on UUID values.\n\n\n\n\nRead more", 
            "title": "Identifiers"
        }, 
        {
            "location": "/ddd/identifiers/#identifiers", 
            "text": "A domain identifier is a  string-ish  value\nobject and bound to  MsgPhp\\Domain\\DomainIdInterface . Its purpose is to utilize a primitive identifier value.", 
            "title": "Identifiers"
        }, 
        {
            "location": "/ddd/identifiers/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identifiers/#extends", 
            "text": "\\Serializable  \\JsonSerializable", 
            "title": "Extends"
        }, 
        {
            "location": "/ddd/identifiers/#static-fromvaluevalue-domainidinterface", 
            "text": "Factorizes a new identifier from its primitive value. Using  null  might imply an empty identifier.", 
            "title": "static fromValue($value): DomainIdInterface"
        }, 
        {
            "location": "/ddd/identifiers/#isempty-bool", 
            "text": "Tells if an identifier value is considered empty, thus has no known primitive value.", 
            "title": "isEmpty(): bool"
        }, 
        {
            "location": "/ddd/identifiers/#equalsdomainidinterface-id-bool", 
            "text": "Tells if an identifier equals another identifier.", 
            "title": "equals(DomainIdInterface $id): bool"
        }, 
        {
            "location": "/ddd/identifiers/#tostring-string-__tostring-string", 
            "text": "Returns the identifier its primitive string value. If the identifier is empty (see  isEmpty() ) an empty string ( \"\" ) \nshould be returned.", 
            "title": "toString(): string / __toString(): string"
        }, 
        {
            "location": "/ddd/identifiers/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/identifiers/#msgphpdomaindomainid", 
            "text": "A first class citizen domain identifier. It leverages  string|null  as underlying data type.   __construct(string $id = null)  $id : The primitive identifier value. In case of  null  an empty identifier is implied.", 
            "title": "MsgPhp\\Domain\\DomainId"
        }, 
        {
            "location": "/ddd/identifiers/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\DomainId ;  // --- SETUP ---  class   OtherDomainId   extends   DomainId  {  }  $emptyId   =   new   DomainId ();  $id   =   new   DomainId ( 1 );  // --- USAGE ---  $emptyId - isEmpty ();   // true  $id - isEmpty ();   // false  $emptyId - equals ( $emptyId );   // true  $emptyId - equals ( new   DomainId ());   // false  $id - equals ( new   DomainId ( 1 ));   // true  $id - equals ( new   OtherDomainId ( 1 ));   // false due type varying  $emptyId - toString ();   //   ( string )   $id ;   //  1  $emptyStringId   =   new   DomainId ( );  $emptyStringId - isEmpty ()   ?   null   :   $emptyStringId - toString ();   //   $emptyId - isEmpty ()   ?   null   :   $emptyId - toString ();   // null", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/identifiers/#msgphpdomaininfrauuiddomainid", 
            "text": "Domain identifier based on UUID values.   Read more", 
            "title": "MsgPhp\\Domain\\Infra\\Uuid\\DomainId"
        }, 
        {
            "location": "/ddd/identities/", 
            "text": "Identities\n\n\nA domain identity is a composite value (\narray\n) of one or more individual identifier values, indexed by an identifier\nfield name. Its usage is to uniquely identify a domain object, thus qualifying it an entity object.\n\n\nIdentifier values can be of any type; a \ndomain identifier\n, another (foreign) entity object, or any\nprimitive value.\n\n\nA single identifier value might represent an actual identity in case it's composed by a single identifier field.\n\n\nMsgPhp\\Domain\\DomainIdentityHelper\n is a domain a helper service. Its purpose is to ease working with the\n\nidentity mapping\n.\n\n\nAPI\n\n\nisIdentifier($value): bool\n\n\nTells if \n$value\n is a known identifier value. This is either a \ndomain identifier\n object or an entity\nobject.\n\n\n\n\nisEmptyIdentifier($value): bool\n\n\nTells if \n$value\n is a known empty identifier value. It returns \ntrue\n if the specified value is either \nnull\n, an empty\n\ndomain identifier\n or an entity object without its identity set.\n\n\n\n\nnormalizeIdentifier($value)\n\n\nReturns the primitive identifier value of \n$value\n. Empty identifier values (see \nisEmptyIdentifier()\n) are normalized\nas \nnull\n, a \ndomain identifier\n as string value and an entity object as normalized identity value.\nA value of any other type is returned as is.\n\n\n\n\ngetIdentifiers(object $object): array\n\n\nReturns the actual identifier values of \n$object\n.\n\n\n\n\ngetIdentifierFieldNames(string $class): array\n\n\nReturns the identifier field names for \n$class\n. Any instance should have an identity composed of these field values.\nSee also \nDomainIdentityMappingInterface::getIdentifierFieldNames()\n.\n\n\n\n\nisIdentity(string $class, $value): bool\n\n\nTells if \n$value\n is a valid identity for type \n$class\n. An identity value is considered valid if an entity object uses\na single identifier value as identity and \n$value\n is a non empty identifier (see \nisEmptyIdentifier()\n).\n\n\nIn case of one or more identifier values, given in the form of an array, its keys must exactly match the available\nidentifier field names and its values must contain no empty identifiers.\n\n\n\n\ntoIdentity(string $class, $value): array\n\n\nReturns a composite identity value for \n$class\n from \n$value\n.\n\n\n\n\ngetIdentity(object $object): array\n\n\nReturns the actual, non empty, identifier values of \n$object\n. Each identifier value is keyed by its corresponding\nidentifier field name. See also \nDomainIdentityMappingInterface::getIdentity()\n.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\\n{\nDomainId\n,\n \nDomainIdentityHelper\n};\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \npublic\n \n$id\n;\n\n\n}\n\n\n\nclass\n \nMyCompositeEntity\n\n\n{\n\n    \npublic\n \n$name\n;\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n$helper\n \n=\n \nnew\n \nDomainIdentityHelper\n(\nnew\n \nDomainIdentityMapping\n([\n\n   \nMyEntity\n::\nclass\n \n=\n \nid\n,\n\n   \nMyCompositeEntity\n::\nclass\n \n=\n \n[\nname\n,\n \nyear\n],\n\n\n]));\n\n\n\n// --- USAGE ---\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\n$entity\n-\nid\n \n=\n \nnew\n \nDomainId\n(\n1\n);\n\n\n\n$compositeEntity\n \n=\n \nnew\n \nMyCompositeEntity\n();\n\n\n$compositeEntity\n-\nname\n \n=\n \n...\n;\n\n\n$compositeEntity\n-\nyear\n \n=\n \n...\n;\n\n\n\n$helper\n-\nisIdentity\n(\n1\n);\n \n// false\n\n\n$helper\n-\nisIdentity\n(\nnew\n \nDomainId\n(\n1\n));\n \n// true\n\n\n$helper\n-\nisIdentity\n(\n$entity\n);\n \n// true\n\n\n\n$helper\n-\nnormalizeIdentifier\n(\nnew\n \nDomainId\n());\n \n// null\n\n\n$helper\n-\nnormalizeIdentifier\n(\nnew\n \nDomainId\n(\n1\n));\n \n// \n1\n\n\n$helper\n-\nnormalizeIdentifier\n(\n1\n);\n \n// \n1\n\n\n$helper\n-\nnormalizeIdentifier\n(\n$entity\n);\n \n// \n1\n\n\n$helper\n-\nnormalizeIdentifier\n(\n$compositeEntity\n);\n \n// [\nname\n =\n ..., \nyear\n =\n ....]\n\n\n\n$helper\n-\ngetIdentifiers\n(\n$entity\n);\n \n// [\nid\n]\n\n\n$helper\n-\ngetIdentifiers\n(\n$compositeEntity\n);\n \n// [\nname\n, \nyear\n]\n\n\n\n$helper\n-\nisIdentity\n(\nMyEntity\n::\nclass\n,\n \n1\n);\n \n// true\n\n\n$helper\n-\nisIdentity\n(\nMyCompositeEntity\n::\nclass\n,\n \n1\n);\n \n// false\n\n\n$helper\n-\nisIdentity\n(\nMyCompositeEntity\n::\nclass\n,\n \n[\nname\n \n=\n \n...\n]);\n \n// false\n\n\n$helper\n-\nisIdentity\n(\nMyCompositeEntity\n::\nclass\n,\n \n[\nname\n \n=\n \n...\n,\n \nyear\n \n=\n \n...\n]);\n \n// true\n\n\n\n$helper\n-\ntoIdentity\n(\nMyEntity\n::\nclass\n,\n \n1\n);\n \n// [\nid\n =\n 1]", 
            "title": "Identities"
        }, 
        {
            "location": "/ddd/identities/#identities", 
            "text": "A domain identity is a composite value ( array ) of one or more individual identifier values, indexed by an identifier\nfield name. Its usage is to uniquely identify a domain object, thus qualifying it an entity object.  Identifier values can be of any type; a  domain identifier , another (foreign) entity object, or any\nprimitive value.  A single identifier value might represent an actual identity in case it's composed by a single identifier field.  MsgPhp\\Domain\\DomainIdentityHelper  is a domain a helper service. Its purpose is to ease working with the identity mapping .", 
            "title": "Identities"
        }, 
        {
            "location": "/ddd/identities/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identities/#isidentifiervalue-bool", 
            "text": "Tells if  $value  is a known identifier value. This is either a  domain identifier  object or an entity\nobject.", 
            "title": "isIdentifier($value): bool"
        }, 
        {
            "location": "/ddd/identities/#isemptyidentifiervalue-bool", 
            "text": "Tells if  $value  is a known empty identifier value. It returns  true  if the specified value is either  null , an empty domain identifier  or an entity object without its identity set.", 
            "title": "isEmptyIdentifier($value): bool"
        }, 
        {
            "location": "/ddd/identities/#normalizeidentifiervalue", 
            "text": "Returns the primitive identifier value of  $value . Empty identifier values (see  isEmptyIdentifier() ) are normalized\nas  null , a  domain identifier  as string value and an entity object as normalized identity value.\nA value of any other type is returned as is.", 
            "title": "normalizeIdentifier($value)"
        }, 
        {
            "location": "/ddd/identities/#getidentifiersobject-object-array", 
            "text": "Returns the actual identifier values of  $object .", 
            "title": "getIdentifiers(object $object): array"
        }, 
        {
            "location": "/ddd/identities/#getidentifierfieldnamesstring-class-array", 
            "text": "Returns the identifier field names for  $class . Any instance should have an identity composed of these field values.\nSee also  DomainIdentityMappingInterface::getIdentifierFieldNames() .", 
            "title": "getIdentifierFieldNames(string $class): array"
        }, 
        {
            "location": "/ddd/identities/#isidentitystring-class-value-bool", 
            "text": "Tells if  $value  is a valid identity for type  $class . An identity value is considered valid if an entity object uses\na single identifier value as identity and  $value  is a non empty identifier (see  isEmptyIdentifier() ).  In case of one or more identifier values, given in the form of an array, its keys must exactly match the available\nidentifier field names and its values must contain no empty identifiers.", 
            "title": "isIdentity(string $class, $value): bool"
        }, 
        {
            "location": "/ddd/identities/#toidentitystring-class-value-array", 
            "text": "Returns a composite identity value for  $class  from  $value .", 
            "title": "toIdentity(string $class, $value): array"
        }, 
        {
            "location": "/ddd/identities/#getidentityobject-object-array", 
            "text": "Returns the actual, non empty, identifier values of  $object . Each identifier value is keyed by its corresponding\nidentifier field name. See also  DomainIdentityMappingInterface::getIdentity() .", 
            "title": "getIdentity(object $object): array"
        }, 
        {
            "location": "/ddd/identities/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\ { DomainId ,   DomainIdentityHelper };  use   MsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping ;  // --- SETUP ---  class   MyEntity  { \n     public   $id ;  }  class   MyCompositeEntity  { \n     public   $name ; \n     public   $year ;  }  $helper   =   new   DomainIdentityHelper ( new   DomainIdentityMapping ([ \n    MyEntity :: class   =   id , \n    MyCompositeEntity :: class   =   [ name ,   year ],  ]));  // --- USAGE ---  $entity   =   new   MyEntity ();  $entity - id   =   new   DomainId ( 1 );  $compositeEntity   =   new   MyCompositeEntity ();  $compositeEntity - name   =   ... ;  $compositeEntity - year   =   ... ;  $helper - isIdentity ( 1 );   // false  $helper - isIdentity ( new   DomainId ( 1 ));   // true  $helper - isIdentity ( $entity );   // true  $helper - normalizeIdentifier ( new   DomainId ());   // null  $helper - normalizeIdentifier ( new   DomainId ( 1 ));   //  1  $helper - normalizeIdentifier ( 1 );   //  1  $helper - normalizeIdentifier ( $entity );   //  1  $helper - normalizeIdentifier ( $compositeEntity );   // [ name  =  ...,  year  =  ....]  $helper - getIdentifiers ( $entity );   // [ id ]  $helper - getIdentifiers ( $compositeEntity );   // [ name ,  year ]  $helper - isIdentity ( MyEntity :: class ,   1 );   // true  $helper - isIdentity ( MyCompositeEntity :: class ,   1 );   // false  $helper - isIdentity ( MyCompositeEntity :: class ,   [ name   =   ... ]);   // false  $helper - isIdentity ( MyCompositeEntity :: class ,   [ name   =   ... ,   year   =   ... ]);   // true  $helper - toIdentity ( MyEntity :: class ,   1 );   // [ id  =  1]", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/identity-mapping/", 
            "text": "Identity mapping\n\n\nAn identity mapping is a domain service and is bound to \nMsgPhp\\Domain\\DomainIdentityMappingInterface\n. It tells about\nthe identifier metadata for a known domain object.\n\n\nAPI\n\n\ngetIdentifierFieldNames(string $class): array\n\n\nReturns the identifier field names for \n$class\n. Any instance should have an identity composed of these field values.\n\n\n\n\ngetIdentity(object $object): array\n\n\nReturns the actual, non empty, identifier values of \n$object\n. Each identifier value is keyed by its corresponding\nidentifier field name.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping\n\n\nIdentity mapping based on a known in-memory mapping.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \npublic\n \n$id\n;\n\n\n}\n\n\n\nclass\n \nMyCompositeEntity\n\n\n{\n\n    \npublic\n \n$name\n;\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n$mapping\n \n=\n \nnew\n \nDomainIdentityMapping\n([\n\n    \nMyEntity\n::\nclass\n \n=\n \nid\n,\n\n    \nMyCompositeEntity\n::\nclass\n \n=\n \n[\nname\n,\n \nyear\n],\n\n\n]);\n\n\n\n// --- USAGE ---\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\n$entity\n-\nid\n \n=\n \n...\n;\n\n\n\n$compositeEntity\n \n=\n \nnew\n \nMyCompositeEntity\n();\n\n\n$compositeEntity\n-\nname\n \n=\n \n...\n;\n\n\n$compositeEntity\n-\nyear\n \n=\n \n...\n;\n\n\n\n$mapping\n-\ngetIdentifierFieldNames\n(\nMyEntity\n::\nclass\n);\n \n// [\nid\n]\n\n\n$mapping\n-\ngetIdentifierFieldNames\n(\nMyCompositeEntity\n::\nclass\n);\n \n// [\nname\n, \nyear\n]\n\n\n\n$mapping\n-\ngetIdentity\n(\n$entity\n);\n \n// [\nid\n =\n ...]\n\n\n$mapping\n-\ngetIdentity\n(\n$compositeEntity\n);\n \n// [\nname\n =\n ..., \nyear\n =\n ...]\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n\n\nIdentity mapping based on Doctrine's identity map.\n\n\n\n\nRead more", 
            "title": "Identity mapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#identity-mapping", 
            "text": "An identity mapping is a domain service and is bound to  MsgPhp\\Domain\\DomainIdentityMappingInterface . It tells about\nthe identifier metadata for a known domain object.", 
            "title": "Identity mapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identity-mapping/#getidentifierfieldnamesstring-class-array", 
            "text": "Returns the identifier field names for  $class . Any instance should have an identity composed of these field values.", 
            "title": "getIdentifierFieldNames(string $class): array"
        }, 
        {
            "location": "/ddd/identity-mapping/#getidentityobject-object-array", 
            "text": "Returns the actual, non empty, identifier values of  $object . Each identifier value is keyed by its corresponding\nidentifier field name.", 
            "title": "getIdentity(object $object): array"
        }, 
        {
            "location": "/ddd/identity-mapping/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/identity-mapping/#msgphpdomaininfrainmemorydomainidentitymapping", 
            "text": "Identity mapping based on a known in-memory mapping.", 
            "title": "MsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping ;  // --- SETUP ---  class   MyEntity  { \n     public   $id ;  }  class   MyCompositeEntity  { \n     public   $name ; \n     public   $year ;  }  $mapping   =   new   DomainIdentityMapping ([ \n     MyEntity :: class   =   id , \n     MyCompositeEntity :: class   =   [ name ,   year ],  ]);  // --- USAGE ---  $entity   =   new   MyEntity ();  $entity - id   =   ... ;  $compositeEntity   =   new   MyCompositeEntity ();  $compositeEntity - name   =   ... ;  $compositeEntity - year   =   ... ;  $mapping - getIdentifierFieldNames ( MyEntity :: class );   // [ id ]  $mapping - getIdentifierFieldNames ( MyCompositeEntity :: class );   // [ name ,  year ]  $mapping - getIdentity ( $entity );   // [ id  =  ...]  $mapping - getIdentity ( $compositeEntity );   // [ name  =  ...,  year  =  ...]", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/identity-mapping/#msgphpdomaininfradoctrinedomainidentitymapping", 
            "text": "Identity mapping based on Doctrine's identity map.   Read more", 
            "title": "MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping"
        }, 
        {
            "location": "/ddd/collections/", 
            "text": "Collections\n\n\nA domain collection is a \ntraversable\n and bound to\n\nMsgPhp\\Domain\\DomainCollectionInterface\n. Its purpose is to utilize a primitive iterable value. It may hold any type of\nelement values.\n\n\nAPI\n\n\nExtends\n\n\n\n\n\\Countable\n\n\n\\IteratorAggregate\n\n\n\n\n\n\nstatic fromValue(?iterable $value): DomainCollectionInterface\n\n\nFactorizes a new collection from its primitive value. Using \nnull\n implies an empty collection.\n\n\n\n\nisEmpty(): bool\n\n\nTells if a collection is considered empty, i.e. contains zero elements.\n\n\n\n\ncontains($element): bool\n\n\nTells if a collection contains the given element. Comparison is done strictly.\n\n\n\n\ncontainsKey($key): bool\n\n\nTells if a collection contains an element at the given key/index.\n\n\n\n\nfirst()\n\n\nReturns the first element or \nfalse\n if the collection is empty.\n\n\n\n\nlast()\n\n\nReturns the last element or \nfalse\n if the collection is empty.\n\n\n\n\nget($key)\n\n\nReturns the element at the given key/index or \nnull\n if the collection is empty.\n\n\n\n\nfilter(callable $filter): DomainCollectionInterface\n\n\nReturns a \nnew\n collection containing only elements for which \n$filter\n returns \ntrue\n. Keys are preserved.\n\n\n\n\nslice(int $offset, int $limit = 0): DomainCollectionInterface\n\n\nReturns a \nnew\n collection containing a slice of elements. By default the slice has no limit, implied by integer \n0\n.\nKeys are preserved.\n\n\n\n\nmap(callable $mapper): array\n\n\nReturns a map with each collection element as returned by \n$mapper\n.s\n\n\nImplementations\n\n\nMsgPhp\\Domain\\DomainCollection\n\n\nA first class citizen domain collection. It leverages \niterable\n as underlying data type. Lazy support is built-in for\ntype \n\\Traversable\n. Meaning the minimal no. of elements are traversed, i.e. until the first element in case of\n\nisEmpty()\n. Note type \n\\Generator\n can only start traversing once.\n\n\n\n\n__construct(iterable $elements)\n\n\n$elements\n: The elements this collection contains\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n// --- SETUP ---\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\na\n,\n \nb\n,\n \nc\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \nkey\n \n=\n \nvalue\n]);\n\n\n\n// --- USAGE ---\n\n\n\n$collection\n-\nisEmpty\n();\n \n// false\n\n\ncount\n(\n$collection\n);\n \n// int(7)\n\n\n\n$collection\n-\ncontains\n(\n2\n);\n \n// true\n\n\n$collection\n-\ncontains\n(\n2\n);\n \n// false\n\n\n\n$collection\n-\ncontainsKey\n(\n0\n);\n \n// true\n\n\n$collection\n-\ncontainsKey\n(\n0\n);\n \n// true\n\n\n\n$collection\n-\nfirst\n();\n \n// \na\n\n\n$collection\n-\nlast\n();\n \n// int(3)\n\n\n\n$collection\n-\nget\n(\n0\n);\n \n// \na\n\n\n$collection\n-\nget\n(\n3\n);\n \n// int(1)\n\n\n$collection\n-\nget\n(\nkey\n);\n \n// \nvalue\n\n\n\n$onlyInts\n \n=\n \n$collection\n-\nfilter\n(\nfunction\n \n(\n$value\n)\n:\n \nbool\n \n{\n\n    \nreturn\n \nis_int\n(\n$value\n);\n\n\n});\n\n\n\n$firstTwoInts\n \n=\n \n$onlyInts\n-\nslice\n(\n0\n,\n \n2\n);\n\n\n\n$firstTwoIntsPlussed\n \n=\n \n$firstTwoInts\n-\nmap\n(\nfunction\n \n(\nint\n \n$value\n)\n:\n \nint\n \n{\n\n    \nreturn\n \n++\n$value\n;\n\n\n});\n \n// [2, 4]\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n\n\nDomain collection based on \nDoctrine Collections\n.\n\n\n\n\nRead more", 
            "title": "Collections"
        }, 
        {
            "location": "/ddd/collections/#collections", 
            "text": "A domain collection is a  traversable  and bound to MsgPhp\\Domain\\DomainCollectionInterface . Its purpose is to utilize a primitive iterable value. It may hold any type of\nelement values.", 
            "title": "Collections"
        }, 
        {
            "location": "/ddd/collections/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/collections/#extends", 
            "text": "\\Countable  \\IteratorAggregate", 
            "title": "Extends"
        }, 
        {
            "location": "/ddd/collections/#static-fromvalueiterable-value-domaincollectioninterface", 
            "text": "Factorizes a new collection from its primitive value. Using  null  implies an empty collection.", 
            "title": "static fromValue(?iterable $value): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#isempty-bool", 
            "text": "Tells if a collection is considered empty, i.e. contains zero elements.", 
            "title": "isEmpty(): bool"
        }, 
        {
            "location": "/ddd/collections/#containselement-bool", 
            "text": "Tells if a collection contains the given element. Comparison is done strictly.", 
            "title": "contains($element): bool"
        }, 
        {
            "location": "/ddd/collections/#containskeykey-bool", 
            "text": "Tells if a collection contains an element at the given key/index.", 
            "title": "containsKey($key): bool"
        }, 
        {
            "location": "/ddd/collections/#first", 
            "text": "Returns the first element or  false  if the collection is empty.", 
            "title": "first()"
        }, 
        {
            "location": "/ddd/collections/#last", 
            "text": "Returns the last element or  false  if the collection is empty.", 
            "title": "last()"
        }, 
        {
            "location": "/ddd/collections/#getkey", 
            "text": "Returns the element at the given key/index or  null  if the collection is empty.", 
            "title": "get($key)"
        }, 
        {
            "location": "/ddd/collections/#filtercallable-filter-domaincollectioninterface", 
            "text": "Returns a  new  collection containing only elements for which  $filter  returns  true . Keys are preserved.", 
            "title": "filter(callable $filter): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#sliceint-offset-int-limit-0-domaincollectioninterface", 
            "text": "Returns a  new  collection containing a slice of elements. By default the slice has no limit, implied by integer  0 .\nKeys are preserved.", 
            "title": "slice(int $offset, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#mapcallable-mapper-array", 
            "text": "Returns a map with each collection element as returned by  $mapper .s", 
            "title": "map(callable $mapper): array"
        }, 
        {
            "location": "/ddd/collections/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/collections/#msgphpdomaindomaincollection", 
            "text": "A first class citizen domain collection. It leverages  iterable  as underlying data type. Lazy support is built-in for\ntype  \\Traversable . Meaning the minimal no. of elements are traversed, i.e. until the first element in case of isEmpty() . Note type  \\Generator  can only start traversing once.   __construct(iterable $elements)  $elements : The elements this collection contains", 
            "title": "MsgPhp\\Domain\\DomainCollection"
        }, 
        {
            "location": "/ddd/collections/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\DomainCollection ;  // --- SETUP ---  $collection   =   new   DomainCollection ([ a ,   b ,   c ,   1 ,   2 ,   3 ,   key   =   value ]);  // --- USAGE ---  $collection - isEmpty ();   // false  count ( $collection );   // int(7)  $collection - contains ( 2 );   // true  $collection - contains ( 2 );   // false  $collection - containsKey ( 0 );   // true  $collection - containsKey ( 0 );   // true  $collection - first ();   //  a  $collection - last ();   // int(3)  $collection - get ( 0 );   //  a  $collection - get ( 3 );   // int(1)  $collection - get ( key );   //  value  $onlyInts   =   $collection - filter ( function   ( $value ) :   bool   { \n     return   is_int ( $value );  });  $firstTwoInts   =   $onlyInts - slice ( 0 ,   2 );  $firstTwoIntsPlussed   =   $firstTwoInts - map ( function   ( int   $value ) :   int   { \n     return   ++ $value ;  });   // [2, 4]", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/collections/#msgphpdomaininfradoctrinedomaincollection", 
            "text": "Domain collection based on  Doctrine Collections .   Read more", 
            "title": "MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection"
        }, 
        {
            "location": "/ddd/factory/object/", 
            "text": "Object factory\n\n\nA domain object factory is bound to \nMsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface\n. Its purpose is to initialize\nany domain object based on a given class name and context.\n\n\nAPI\n\n\ncreate(string $class, array $context = []): object\n\n\nFactorizes a new domain object by class name. Optionally a context can be provided for the factory to act upon.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\DomainObjectFactory\n\n\nA generic object factory. It initializes the given class by reading its constructor arguments. Argument values are\nresolved from the provided context. By convention a camel cased argument name (e.g. \n$myArgument\n) matches a\ncorresponding underscored context key (i.e. \n'my_argument'\n), note however, an exact match (i.e. \n'myArgument'\n) has\nhigher precedence. In case the context key is numeric its value will be provided to a corresponding argument at index N.\n\n\nAny sub class of \nMsgPhp\\Domain\\DomainIdInterface\n or \nMsgPhp\\Domain\\DomainCollectionInterface\n will be initialized\nusing \n$class::fromValue()\n by default, otherwise initialization happens regularly (i.e. \nnew $class(...$arguments)\n).\n\n\nNested objects (e.g. \nMyObject $myArgument\n) can be provided as nested context (thus nested array).\n\n\n\n\nsetNestedFactory(?DomainObjectFactoryInterface $factory): void\n\n\n$factory\n: The optional factory to use for nested objects. If not set the current factory will be used instead.\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainObjectFactory\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nSome\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nint\n \n$a\n,\n \n?\nint\n \n$b\n,\n \n?\nint\n \n$c\n)\n\n    \n{\n\n    \n}\n\n\n}\n\n\n\nclass\n \nSubject\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nstring\n \n$argument\n,\n \nSome\n \n$some\n,\n \nSubject\n \n$otherSubject\n \n=\n \nnull\n)\n\n    \n{\n\n    \n}\n\n\n}\n\n\n\n$factory\n \n=\n \nnew\n \nDomainObjectFactory\n();\n\n\n\n// --- USAGE ---\n\n\n\n/** @var Subject $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nSubject\n::\nclass\n,\n \n[\n\n    \nargument\n \n=\n  \nvalue\n,\n\n    \nsome\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \nother_subject\n \n=\n \n[\n\n        \nargument\n \n=\n \nother_value\n,\n\n        \nsome\n \n=\n \n[\na\n \n=\n \n1\n],\n\n    \n],\n\n\n]);\n\n\n\n\n\n\nMsgPhp\\Domain\\Factory\\ChainObjectFactory\n\n\nA chain object factory. It holds many object factories and returns a domain object from the first supporting factory.\n\n\n\n\n__construct(iterable $factories)\n\n\n$factories\n: Available object factories\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\\n{\nChainObjectFactory\n,\n \nDomainObjectFactory\n,\n \nDomainObjectFactoryInterface\n};\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyFactory\n \nimplements\n \nDomainObjectFactoryInterface\n\n\n{\n\n    \npublic\n \nfunction\n \ncreate\n(\nstring\n \n$class\n,\n \narray\n \n$context\n \n=\n \n[])\n\n    \n{\n\n        \n// ...\n\n    \n}\n\n\n}\n\n\n\n$factory\n \n=\n \nnew\n \nChainObjectFactory\n([\nnew\n \nMyFactory\n(),\n \nnew\n \nDomainObjectFactory\n()]);\n\n\n\n\n\n\nMsgPhp\\Domain\\Factory\\ClassMappingObjectFactory\n\n\nA class mapping object factory. It decorates any object factory and resolves the actual class name from a provided\nmapping. In case the class is not mapped it will be used as is.\n\n\n\n\n__construct(DomainObjectFactoryInterface $factory, array $mapping)\n\n\n$factory\n: The decorated object factory\n\n\n$mapping\n: The class mapping (\n['SourceClass' =\n 'TargetClass']\n)\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\\n{\nClassMappingObjectFactory\n,\n \nDomainObjectFactory\n};\n\n\n\n// --- SETUP ---\n\n\n\ninterface\n \nKnownInterface\n\n\n{\n\n\n}\n\n\n\nclass\n \nSubject\n \nimplements\n \nKnownInterface\n\n\n{\n\n\n}\n\n\n\n$factory\n \n=\n \nnew\n \nClassMappingObjectFactory\n(\n\n    \nnew\n \nDomainObjectFactory\n(),\n\n    \n[\nKnownInterface\n::\nclass\n \n=\n \nSubject\n::\nclass\n]\n\n\n);\n\n\n\n// --- USAGE ---\n\n\n\n/** @var Subject $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nKnownInterface\n::\nclass\n);", 
            "title": "Object factory"
        }, 
        {
            "location": "/ddd/factory/object/#object-factory", 
            "text": "A domain object factory is bound to  MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface . Its purpose is to initialize\nany domain object based on a given class name and context.", 
            "title": "Object factory"
        }, 
        {
            "location": "/ddd/factory/object/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/factory/object/#createstring-class-array-context-object", 
            "text": "Factorizes a new domain object by class name. Optionally a context can be provided for the factory to act upon.", 
            "title": "create(string $class, array $context = []): object"
        }, 
        {
            "location": "/ddd/factory/object/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactorydomainobjectfactory", 
            "text": "A generic object factory. It initializes the given class by reading its constructor arguments. Argument values are\nresolved from the provided context. By convention a camel cased argument name (e.g.  $myArgument ) matches a\ncorresponding underscored context key (i.e.  'my_argument' ), note however, an exact match (i.e.  'myArgument' ) has\nhigher precedence. In case the context key is numeric its value will be provided to a corresponding argument at index N.  Any sub class of  MsgPhp\\Domain\\DomainIdInterface  or  MsgPhp\\Domain\\DomainCollectionInterface  will be initialized\nusing  $class::fromValue()  by default, otherwise initialization happens regularly (i.e.  new $class(...$arguments) ).  Nested objects (e.g.  MyObject $myArgument ) can be provided as nested context (thus nested array).   setNestedFactory(?DomainObjectFactoryInterface $factory): void  $factory : The optional factory to use for nested objects. If not set the current factory will be used instead.", 
            "title": "MsgPhp\\Domain\\Factory\\DomainObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainObjectFactory ;  // --- SETUP ---  class   Some  { \n     public   function   __construct ( int   $a ,   ? int   $b ,   ? int   $c ) \n     { \n     }  }  class   Subject  { \n     public   function   __construct ( string   $argument ,   Some   $some ,   Subject   $otherSubject   =   null ) \n     { \n     }  }  $factory   =   new   DomainObjectFactory ();  // --- USAGE ---  /** @var Subject $object */  $object   =   $factory - create ( Subject :: class ,   [ \n     argument   =    value , \n     some   =   [ 1 ,   2 ,   3 ], \n     other_subject   =   [ \n         argument   =   other_value , \n         some   =   [ a   =   1 ], \n     ],  ]);", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactorychainobjectfactory", 
            "text": "A chain object factory. It holds many object factories and returns a domain object from the first supporting factory.   __construct(iterable $factories)  $factories : Available object factories", 
            "title": "MsgPhp\\Domain\\Factory\\ChainObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#basic-example_1", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ { ChainObjectFactory ,   DomainObjectFactory ,   DomainObjectFactoryInterface };  // --- SETUP ---  class   MyFactory   implements   DomainObjectFactoryInterface  { \n     public   function   create ( string   $class ,   array   $context   =   []) \n     { \n         // ... \n     }  }  $factory   =   new   ChainObjectFactory ([ new   MyFactory (),   new   DomainObjectFactory ()]);", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactoryclassmappingobjectfactory", 
            "text": "A class mapping object factory. It decorates any object factory and resolves the actual class name from a provided\nmapping. In case the class is not mapped it will be used as is.   __construct(DomainObjectFactoryInterface $factory, array $mapping)  $factory : The decorated object factory  $mapping : The class mapping ( ['SourceClass' =  'TargetClass'] )", 
            "title": "MsgPhp\\Domain\\Factory\\ClassMappingObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#basic-example_2", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ { ClassMappingObjectFactory ,   DomainObjectFactory };  // --- SETUP ---  interface   KnownInterface  {  }  class   Subject   implements   KnownInterface  {  }  $factory   =   new   ClassMappingObjectFactory ( \n     new   DomainObjectFactory (), \n     [ KnownInterface :: class   =   Subject :: class ]  );  // --- USAGE ---  /** @var Subject $object */  $object   =   $factory - create ( KnownInterface :: class );", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/entity-aware/", 
            "text": "Entity aware factory\n\n\nAn entity aware factory is an \nobject factory\n and additionally bound to\n\nMsgPhp\\Domain\\Factory\\EntityAwareFactoryInterface\n. Its purpose is to factorize entity related objects.\n\n\nAPI\n\n\ncreate(string $class, array $context = []): object\n\n\nInherited from \nMsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface::create()\n.\n\n\n\n\nreference(string $class, $id): object\n\n\nFactorize a reference object for a known existing entity object. The object must be of type \n$class\n. Any type of\n\nidentity\n value can be passed as \n$id\n.\n\n\n\n\nidentify(string $class, $value): DomainIdInterface\n\n\nFactorize an \nidentifier\n for the given entity class from a known primitive value.\n\n\n\n\nnextIdentifier(string $class): DomainIdInterface\n\n\nFactorize the next \nidentifier\n for the given entity class. Depending on the implementation its value\nmight be considered empty if it's not capable to calculate one upfront.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\EntityAwareFactory\n\n\nA generic entity factory. It decorates any object factory and additionally must be provided with an entity to identifier\nclass mapping.\n\n\n\n\n__construct(DomainObjectFactoryInterface $factory, array $identifierMapping, callable $referenceLoader = null)\n\n\n$factory\n: The decorated object factory\n\n\n$identifierMapping\n: The identifier class mapping (\n['EntityClass' =\n 'IdClass']\n)\n\n\n$referenceLoader\n: An optional reference loader. If \nnull\n using \nreference()\n is not supported. The callable\n  receives the same arguments as given to \nreference()\n. It should return an instance of the received class name.\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\\n{\nDomainObjectFactory\n,\n \nEntityAwareFactory\n};\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n \nas\n \nDomainUuid\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \npublic\n \n$id\n;\n\n\n}\n\n\n\n$factory\n \n=\n \nnew\n \nEntityAwareFactory\n(\nnew\n \nDomainObjectFactory\n(),\n \n[\n\n    \nMyEntity\n::\nclass\n \n=\n \nDomainUuid\n::\nclass\n,\n\n\n],\n \nfunction\n \n(\nstring\n \n$class\n,\n \n$id\n)\n \n{\n\n    \n$object\n \n=\n \nnew\n \n$class\n();\n\n    \n$object\n-\nid\n \n=\n \n$id\n;\n\n\n    \nreturn\n \n$object\n;\n\n\n});\n\n\n\n// --- USAGE ---\n\n\n\n/** @var MyEntity $entity */\n\n\n$ref\n \n=\n \n$factory\n-\nreference\n(\nMyEntity\n::\nclass\n,\n \nnew\n \nDomainUuid\n());\n\n\n\n/** @var DomainUuid $id */\n\n\n$id\n \n=\n \n$factory\n-\nidentify\n(\nMyEntity\n::\nclass\n,\n \ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n\n/** @var DomainUuid $id */\n\n\n$id\n \n=\n \n$factory\n-\nnextIdentifier\n(\nMyEntity\n::\nclass\n);", 
            "title": "Entity aware factory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#entity-aware-factory", 
            "text": "An entity aware factory is an  object factory  and additionally bound to MsgPhp\\Domain\\Factory\\EntityAwareFactoryInterface . Its purpose is to factorize entity related objects.", 
            "title": "Entity aware factory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#createstring-class-array-context-object", 
            "text": "Inherited from  MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface::create() .", 
            "title": "create(string $class, array $context = []): object"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#referencestring-class-id-object", 
            "text": "Factorize a reference object for a known existing entity object. The object must be of type  $class . Any type of identity  value can be passed as  $id .", 
            "title": "reference(string $class, $id): object"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#identifystring-class-value-domainidinterface", 
            "text": "Factorize an  identifier  for the given entity class from a known primitive value.", 
            "title": "identify(string $class, $value): DomainIdInterface"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#nextidentifierstring-class-domainidinterface", 
            "text": "Factorize the next  identifier  for the given entity class. Depending on the implementation its value\nmight be considered empty if it's not capable to calculate one upfront.", 
            "title": "nextIdentifier(string $class): DomainIdInterface"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#msgphpdomainfactoryentityawarefactory", 
            "text": "A generic entity factory. It decorates any object factory and additionally must be provided with an entity to identifier\nclass mapping.   __construct(DomainObjectFactoryInterface $factory, array $identifierMapping, callable $referenceLoader = null)  $factory : The decorated object factory  $identifierMapping : The identifier class mapping ( ['EntityClass' =  'IdClass'] )  $referenceLoader : An optional reference loader. If  null  using  reference()  is not supported. The callable\n  receives the same arguments as given to  reference() . It should return an instance of the received class name.", 
            "title": "MsgPhp\\Domain\\Factory\\EntityAwareFactory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ { DomainObjectFactory ,   EntityAwareFactory };  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId   as   DomainUuid ;  // --- SETUP ---  class   MyEntity  { \n     public   $id ;  }  $factory   =   new   EntityAwareFactory ( new   DomainObjectFactory (),   [ \n     MyEntity :: class   =   DomainUuid :: class ,  ],   function   ( string   $class ,   $id )   { \n     $object   =   new   $class (); \n     $object - id   =   $id ; \n\n     return   $object ;  });  // --- USAGE ---  /** @var MyEntity $entity */  $ref   =   $factory - reference ( MyEntity :: class ,   new   DomainUuid ());  /** @var DomainUuid $id */  $id   =   $factory - identify ( MyEntity :: class ,   cf3d2f85-6c86-44d1-8634-af51c91a9a74 );  /** @var DomainUuid $id */  $id   =   $factory - nextIdentifier ( MyEntity :: class );", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/static/", 
            "text": "Static factory\n\n\nA static factory is a utility class, it cannot be initialized as a new instance using \nnew ...();\n. Its purpose is to\nfactorize a known implementation for a given class.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\DomainIdFactory\n\n\nFactorizes an \nidentifier\n.\n\n\n\n\nstatic create($value): DomainIdInterface\n\n\n$value\n: Any (primitive) identifier value\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainIdFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n \nas\n \nDomainUuid\n;\n\n\n\n// --- USAGE ---\n\n\n\n/** @var DomainId $id */\n\n\n$id\n \n=\n \nDomainIdFactory\n::\ncreate\n(\n1\n);\n\n\n\n/** @var DomainUuid $id */\n\n\n$id\n \n=\n \nDomainIdFactory\n::\ncreate\n(\ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n\n\n\n\nMsgPhp\\Domain\\Factory\\DomainCollectionFactory\n\n\nFactorizes a \ncollection\n.\n\n\n\n\nstatic create(?iterable $value): DomainCollectionInterface\n\n\n$value\n: Any (primitive) iterable value or \nnull\n to imply an empty collection\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainCollectionFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n \nas\n \nDoctrineDomainCollection\n;\n\n\n\n// --- USAGE ---\n\n\n\n/** @var DomainCollection $collection */\n\n\n$collection\n \n=\n \nDomainCollectionFactory\n::\ncreate\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\n/** @var DoctrineDomainCollection $collection */\n\n\n$collection\n \n=\n \nDomainCollectionFactory\n::\ncreate\n([\n1\n,\n \n2\n,\n \n3\n]);", 
            "title": "Static factory"
        }, 
        {
            "location": "/ddd/factory/static/#static-factory", 
            "text": "A static factory is a utility class, it cannot be initialized as a new instance using  new ...(); . Its purpose is to\nfactorize a known implementation for a given class.", 
            "title": "Static factory"
        }, 
        {
            "location": "/ddd/factory/static/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/static/#msgphpdomainfactorydomainidfactory", 
            "text": "Factorizes an  identifier .   static create($value): DomainIdInterface  $value : Any (primitive) identifier value", 
            "title": "MsgPhp\\Domain\\Factory\\DomainIdFactory"
        }, 
        {
            "location": "/ddd/factory/static/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\DomainId ;  use   MsgPhp\\Domain\\Factory\\DomainIdFactory ;  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId   as   DomainUuid ;  // --- USAGE ---  /** @var DomainId $id */  $id   =   DomainIdFactory :: create ( 1 );  /** @var DomainUuid $id */  $id   =   DomainIdFactory :: create ( cf3d2f85-6c86-44d1-8634-af51c91a9a74 );", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/static/#msgphpdomainfactorydomaincollectionfactory", 
            "text": "Factorizes a  collection .   static create(?iterable $value): DomainCollectionInterface  $value : Any (primitive) iterable value or  null  to imply an empty collection", 
            "title": "MsgPhp\\Domain\\Factory\\DomainCollectionFactory"
        }, 
        {
            "location": "/ddd/factory/static/#basic-example_1", 
            "text": "?php  use   MsgPhp\\Domain\\DomainCollection ;  use   MsgPhp\\Domain\\Factory\\DomainCollectionFactory ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection   as   DoctrineDomainCollection ;  // --- USAGE ---  /** @var DomainCollection $collection */  $collection   =   DomainCollectionFactory :: create ([ 1 ,   2 ,   3 ]);  /** @var DoctrineDomainCollection $collection */  $collection   =   DomainCollectionFactory :: create ([ 1 ,   2 ,   3 ]);", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/repositories/", 
            "text": "Repositories\n\n\nA domain repository is not interface bound by default. Instead you can leverage a utility trait, tied to specific\ninfrastructure (e.g. Doctrine), to rapidly create one. This page describes the API provided by default \nimplementations\n.\n\n\nAPI\n\n\ndoFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface\n\n\nFind all entities available. An unlimited collection is implied by \n$limit\n set to zero.\n\n\n\n\ndoFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface\n\n\nFind all entities matching all specified fields. Supported field values should be \nnull\n, \nscalar\n, \narray\n (one of a\nknown literal list) and \nobject\n (foreign entity or an \nidentifier\n). An unlimited collection is implied\nby \n$limit\n set to zero.\n\n\n\n\ndoFind($id): object\n\n\nFind a single entity by its identity. Supported identity values should be \nscalar\n, \narray\n (composite \nidentity\n)\nand \nobject\n (foreign entity or an \nidentifier\n).\n\n\n\n\ndoFindByFields(array $fields): object\n\n\nFind the first entity matching all specified fields. See \ndoFindAllByFields()\n for supported field values.\n\n\n\n\ndoExists($id): bool\n\n\nVerify if an entity exists by its identity. See \ndoFind()\n for supported identity values.\n\n\n\n\ndoExistsByFields(array $fields): bool\n\n\nVerify if an entity exists matching all specified fields. See \ndoFindAllByFields()\n for supported field values.\n\n\n\n\ndoSave(object $entity): void\n\n\nPersist an entity in the identity map. The entity will be available on any subsequent query.\n\n\n\n\ndoDelete(object $entity): void\n\n\nRemove an entity from the identity map. The entity will be unavailable on any subsequent query.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Infra\\InMemory\\DomainEntityRepositoryTrait\n\n\nRepository trait based on in-memory persistence.\n\n\n\n\n__construct(string $class, DomainIdentityHelper $identityHelper, GlobalObjectMemory $memory = null, ObjectFieldAccessor $accessor = null)\n\n\n$class\n: The entity class this repository is tied to\n\n\n$identityHelper\n: The domain identity helper. \nRead more\n.\n\n\n$memory\n: Custom memory layer. By default the same global pool is used. See also \nGlobalObjectMemory\n.\n\n\n$accessor\n: Custom object field accessor. See also \nGlobalObjectMemory\n.\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainIdentityHelper\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\InMemory\\\n{\nDomainIdentityMapping\n,\n \nDomainEntityRepositoryTrait\n};\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \npublic\n \n$id\n;\n\n\n}\n\n\n\nclass\n \nMyEntityRepository\n\n\n{\n\n    \nuse\n \nDomainEntityRepositoryTrait\n \n{\n\n        \ndoFind\n \nas\n \npublic\n \nfind\n;\n\n        \ndoExists\n \nas\n \npublic\n \nexists\n;\n\n        \ndoSave\n \nas\n \npublic\n \nsave\n;\n\n    \n}\n\n\n}\n\n\n\n$helper\n \n=\n \nnew\n \nDomainIdentityHelper\n(\nnew\n \nDomainIdentityMapping\n([\n\n   \nMyEntity\n::\nclass\n \n=\n \nid\n,\n\n\n]));\n\n\n\n$repository\n \n=\n \nnew\n \nMyEntityRepository\n(\nMyEntity\n::\nclass\n,\n \n$helper\n);\n\n\n\n// --- USAGE ---\n\n\n\nif\n \n(\n$repository\n-\nexists\n(\n1\n))\n \n{\n\n    \n$entity\n \n=\n \n$repository\n-\nfind\n(\n1\n);\n\n\n}\n \nelse\n \n{\n\n    \n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n    \n$entity\n-\nid\n \n=\n \n1\n;\n\n\n    \n$repository\n-\nsave\n(\n$entity\n);\n\n\n}\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n\n\nRepository trait based on \nDoctrine ORM\n persistence.\n\n\n\n\nRead more", 
            "title": "Repositories"
        }, 
        {
            "location": "/ddd/repositories/#repositories", 
            "text": "A domain repository is not interface bound by default. Instead you can leverage a utility trait, tied to specific\ninfrastructure (e.g. Doctrine), to rapidly create one. This page describes the API provided by default  implementations .", 
            "title": "Repositories"
        }, 
        {
            "location": "/ddd/repositories/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/repositories/#dofindallint-offset-0-int-limit-0-domaincollectioninterface", 
            "text": "Find all entities available. An unlimited collection is implied by  $limit  set to zero.", 
            "title": "doFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/repositories/#dofindallbyfieldsarray-fields-int-offset-0-int-limit-0-domaincollectioninterface", 
            "text": "Find all entities matching all specified fields. Supported field values should be  null ,  scalar ,  array  (one of a\nknown literal list) and  object  (foreign entity or an  identifier ). An unlimited collection is implied\nby  $limit  set to zero.", 
            "title": "doFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/repositories/#dofindid-object", 
            "text": "Find a single entity by its identity. Supported identity values should be  scalar ,  array  (composite  identity )\nand  object  (foreign entity or an  identifier ).", 
            "title": "doFind($id): object"
        }, 
        {
            "location": "/ddd/repositories/#dofindbyfieldsarray-fields-object", 
            "text": "Find the first entity matching all specified fields. See  doFindAllByFields()  for supported field values.", 
            "title": "doFindByFields(array $fields): object"
        }, 
        {
            "location": "/ddd/repositories/#doexistsid-bool", 
            "text": "Verify if an entity exists by its identity. See  doFind()  for supported identity values.", 
            "title": "doExists($id): bool"
        }, 
        {
            "location": "/ddd/repositories/#doexistsbyfieldsarray-fields-bool", 
            "text": "Verify if an entity exists matching all specified fields. See  doFindAllByFields()  for supported field values.", 
            "title": "doExistsByFields(array $fields): bool"
        }, 
        {
            "location": "/ddd/repositories/#dosaveobject-entity-void", 
            "text": "Persist an entity in the identity map. The entity will be available on any subsequent query.", 
            "title": "doSave(object $entity): void"
        }, 
        {
            "location": "/ddd/repositories/#dodeleteobject-entity-void", 
            "text": "Remove an entity from the identity map. The entity will be unavailable on any subsequent query.", 
            "title": "doDelete(object $entity): void"
        }, 
        {
            "location": "/ddd/repositories/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/repositories/#msgphpdomaininfrainmemorydomainentityrepositorytrait", 
            "text": "Repository trait based on in-memory persistence.   __construct(string $class, DomainIdentityHelper $identityHelper, GlobalObjectMemory $memory = null, ObjectFieldAccessor $accessor = null)  $class : The entity class this repository is tied to  $identityHelper : The domain identity helper.  Read more .  $memory : Custom memory layer. By default the same global pool is used. See also  GlobalObjectMemory .  $accessor : Custom object field accessor. See also  GlobalObjectMemory .", 
            "title": "MsgPhp\\Domain\\Infra\\InMemory\\DomainEntityRepositoryTrait"
        }, 
        {
            "location": "/ddd/repositories/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\DomainIdentityHelper ;  use   MsgPhp\\Domain\\Infra\\InMemory\\ { DomainIdentityMapping ,   DomainEntityRepositoryTrait };  // --- SETUP ---  class   MyEntity  { \n     public   $id ;  }  class   MyEntityRepository  { \n     use   DomainEntityRepositoryTrait   { \n         doFind   as   public   find ; \n         doExists   as   public   exists ; \n         doSave   as   public   save ; \n     }  }  $helper   =   new   DomainIdentityHelper ( new   DomainIdentityMapping ([ \n    MyEntity :: class   =   id ,  ]));  $repository   =   new   MyEntityRepository ( MyEntity :: class ,   $helper );  // --- USAGE ---  if   ( $repository - exists ( 1 ))   { \n     $entity   =   $repository - find ( 1 );  }   else   { \n     $entity   =   new   MyEntity (); \n     $entity - id   =   1 ; \n\n     $repository - save ( $entity );  }", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/repositories/#msgphpdomaininfradoctrinedomainentityrepositorytrait", 
            "text": "Repository trait based on  Doctrine ORM  persistence.   Read more", 
            "title": "MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait"
        }, 
        {
            "location": "/ddd/entities/", 
            "text": "Entities\n\n\nEntity objects are provided per domain layer and usually follow a \nPOPO\n\ndesign.\n\n\nTo simplify entity definitions common fields and features are provided in the form of PHP \ntraits\n.\nEntity fields can be compared to a read-operation, whereas entity features represent a write-operation.\n\n\nThey are defined in a dedicated namespace for discovery, respectively \nMsgphp\\Domain\\Entity\\Fields\\\n and\n\nMsgPhp\\Domain\\Entity\\Features\\\n. Additionally more specific fields and features can be provided per domain layer.\n\n\nCommon entity fields\n\n\nCreatedAtField\n\n\nA datetime value representing an entity was initially created at. Requires \n$createdAt\n to be set initially.\n\n\n\n\ngetCreatedAt(): \\DateTimeInterface\n\n\n\n\nEnabledField\n\n\nA boolean value representing an entity its availability state. Sets \n$enabled\n to \nfalse\n by default.\n\n\n\n\nisEnabled(): bool\n\n\n\n\nLastUpdatedAtField\n\n\nA datetime value representing an entity was last updated at. Requires \n$lastUpdatedAt\n to be set initially.\n\n\n\n\ngetLastUpdatedAt(): \\DateTimeInterface\n\n\n\n\nCommon entity features\n\n\nCanBeConfirmed\n\n\nProvides ability to confirm an entity. Requires \n$confirmationToken\n to be set initially (usually a random token).\n\n\n\n\ngetConfirmationToken(): ?string\n\n\ngetConfirmedAt(): ?\\DateTimeInterface\n \n\n\nisConfirmed(): bool\n \n\n\nconfirm(): void\n \n\n\nResets \n$confirmationToken\n\n\nSets \n$confirmatedAt\n to the current datetime\n\n\n\n\n\n\n\n\nCanBeEnabled\n\n\nProvides ability to toggle an entity its availability state.\n\n\n\n\nInherits from \nEnabledField\n\n\nenable(): void\n\n\nSets \n$enabled\n to \ntrue\n\n\n\n\n\n\ndisable(): void\n\n\nSets \n$enabled\n to \nfalse", 
            "title": "Entities"
        }, 
        {
            "location": "/ddd/entities/#entities", 
            "text": "Entity objects are provided per domain layer and usually follow a  POPO \ndesign.  To simplify entity definitions common fields and features are provided in the form of PHP  traits .\nEntity fields can be compared to a read-operation, whereas entity features represent a write-operation.  They are defined in a dedicated namespace for discovery, respectively  Msgphp\\Domain\\Entity\\Fields\\  and MsgPhp\\Domain\\Entity\\Features\\ . Additionally more specific fields and features can be provided per domain layer.", 
            "title": "Entities"
        }, 
        {
            "location": "/ddd/entities/#common-entity-fields", 
            "text": "", 
            "title": "Common entity fields"
        }, 
        {
            "location": "/ddd/entities/#createdatfield", 
            "text": "A datetime value representing an entity was initially created at. Requires  $createdAt  to be set initially.   getCreatedAt(): \\DateTimeInterface", 
            "title": "CreatedAtField"
        }, 
        {
            "location": "/ddd/entities/#enabledfield", 
            "text": "A boolean value representing an entity its availability state. Sets  $enabled  to  false  by default.   isEnabled(): bool", 
            "title": "EnabledField"
        }, 
        {
            "location": "/ddd/entities/#lastupdatedatfield", 
            "text": "A datetime value representing an entity was last updated at. Requires  $lastUpdatedAt  to be set initially.   getLastUpdatedAt(): \\DateTimeInterface", 
            "title": "LastUpdatedAtField"
        }, 
        {
            "location": "/ddd/entities/#common-entity-features", 
            "text": "", 
            "title": "Common entity features"
        }, 
        {
            "location": "/ddd/entities/#canbeconfirmed", 
            "text": "Provides ability to confirm an entity. Requires  $confirmationToken  to be set initially (usually a random token).   getConfirmationToken(): ?string  getConfirmedAt(): ?\\DateTimeInterface    isConfirmed(): bool    confirm(): void    Resets  $confirmationToken  Sets  $confirmatedAt  to the current datetime", 
            "title": "CanBeConfirmed"
        }, 
        {
            "location": "/ddd/entities/#canbeenabled", 
            "text": "Provides ability to toggle an entity its availability state.   Inherits from  EnabledField  enable(): void  Sets  $enabled  to  true    disable(): void  Sets  $enabled  to  false", 
            "title": "CanBeEnabled"
        }, 
        {
            "location": "/event-sourcing/events/", 
            "text": "Events\n\n\nA domain event is bound to \nMsgPhp\\Domain\\Event\\DomainEventInterface\n. Its purpose is to identify concrete domain events\nwhich represent something that happens. When handled it might lead to an application state change.\n\n\nImplementations\n\n\nDomain events provided and handled by default \nentity features\n:\n\n\nMsgPhp\\Domain\\Event\\ConfirmEvent\n\n\nTriggers a confirmation. Handled by default with \nMsgPhp\\Domain\\Entity\\Features\\CanBeConfirmed::handleConfirmEvent()\n.\n\n\nMsgPhp\\Domain\\Event\\DisableEvent\n\n\nTriggers disabling availability. Handled by default with \nMsgPhp\\Domain\\Entity\\Features\\CanBeEnabled::handleDisableEvent()\n.\n\n\nMsgPhp\\Domain\\Event\\EnableEvent\n\n\nTriggers enabling availability. Handled by default with \nMsgPhp\\Domain\\Entity\\Features\\CanBeEnabled::handleEnableEvent()\n.", 
            "title": "Events"
        }, 
        {
            "location": "/event-sourcing/events/#events", 
            "text": "A domain event is bound to  MsgPhp\\Domain\\Event\\DomainEventInterface . Its purpose is to identify concrete domain events\nwhich represent something that happens. When handled it might lead to an application state change.", 
            "title": "Events"
        }, 
        {
            "location": "/event-sourcing/events/#implementations", 
            "text": "Domain events provided and handled by default  entity features :", 
            "title": "Implementations"
        }, 
        {
            "location": "/event-sourcing/events/#msgphpdomaineventconfirmevent", 
            "text": "Triggers a confirmation. Handled by default with  MsgPhp\\Domain\\Entity\\Features\\CanBeConfirmed::handleConfirmEvent() .", 
            "title": "MsgPhp\\Domain\\Event\\ConfirmEvent"
        }, 
        {
            "location": "/event-sourcing/events/#msgphpdomaineventdisableevent", 
            "text": "Triggers disabling availability. Handled by default with  MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled::handleDisableEvent() .", 
            "title": "MsgPhp\\Domain\\Event\\DisableEvent"
        }, 
        {
            "location": "/event-sourcing/events/#msgphpdomaineventenableevent", 
            "text": "Triggers enabling availability. Handled by default with  MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled::handleEnableEvent() .", 
            "title": "MsgPhp\\Domain\\Event\\EnableEvent"
        }, 
        {
            "location": "/event-sourcing/event-handlers/", 
            "text": "Event handlers\n\n\nA domain event handler is bound to \nMsgPhp\\Domain\\Event\\DomainEventHandlerInterface\n. Its purpose is to implement the\nhandling of \ndomain events\n within a certain context.\n\n\nUsually an entity implements it in order to mutate its own state (i.e. self-handling). It enforces the entity state to\nbe valid by design as it encapsulates all write operations.\n\n\nIn practice domain events can be recorded on trigger. It allows to re-play them at any point in time afterwards.\nConsider this a design choice to be made upfront, e.g. in case your entity design requires its history to be accessible.\n\n\nAPI\n\n\nhandleEvent(DomainEventInterface $event): bool\n\n\nHandles the given domain event for a known subject. A boolean return value tells if the domain event is actually handled\nyes or no.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Event\\DomainEventHandlerTrait\n\n\nA utility trait implementing the event handler API. By convention it maps events to\n\nhandle\nEvent_Class_Name_Without_Event_Suffix\nEvent()\n methods. It's designed to support default \nevents\n\nout-of-the-box.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Event\\\n{\nDomainEventHandlerInterface\n,\n \nDomainEventHandlerTrait\n};\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyEvent\n\n\n{\n\n    \npublic\n \n$newValue\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n(\n$value\n)\n\n    \n{\n\n        \n$this\n-\nnewValue\n \n=\n \n$value\n;\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyEntity\n \nimplements\n \nDomainEventHandlerInterface\n\n\n{\n\n    \nuse\n \nDomainEventHandlerTrait\n;\n\n\n    \npublic\n \n$value\n;\n\n\n    \nprivate\n \nfunction\n \nhandleMyEvent\n(\nMyEvent\n \n$event\n)\n:\n \nbool\n\n    \n{\n\n        \nif\n \n(\n$this\n-\nvalue\n \n===\n \n$event\n-\nnewValue\n)\n \n{\n\n            \nreturn\n \nfalse\n;\n\n        \n}\n\n\n        \n$this\n-\nvalue\n \n=\n \n$event\n-\nnewValue\n;\n\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n\n\n}\n\n\n\n// --- USAGE ---\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\n\nif\n \n(\n$entity\n-\nhandleEvent\n(\nnew\n \nMyEvent\n(\nnew value\n)))\n \n{\n\n    \n// do something\n\n\n}", 
            "title": "Event handlers"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#event-handlers", 
            "text": "A domain event handler is bound to  MsgPhp\\Domain\\Event\\DomainEventHandlerInterface . Its purpose is to implement the\nhandling of  domain events  within a certain context.  Usually an entity implements it in order to mutate its own state (i.e. self-handling). It enforces the entity state to\nbe valid by design as it encapsulates all write operations.  In practice domain events can be recorded on trigger. It allows to re-play them at any point in time afterwards.\nConsider this a design choice to be made upfront, e.g. in case your entity design requires its history to be accessible.", 
            "title": "Event handlers"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#handleeventdomaineventinterface-event-bool", 
            "text": "Handles the given domain event for a known subject. A boolean return value tells if the domain event is actually handled\nyes or no.", 
            "title": "handleEvent(DomainEventInterface $event): bool"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#msgphpdomaineventdomaineventhandlertrait", 
            "text": "A utility trait implementing the event handler API. By convention it maps events to handle Event_Class_Name_Without_Event_Suffix Event()  methods. It's designed to support default  events \nout-of-the-box.", 
            "title": "MsgPhp\\Domain\\Event\\DomainEventHandlerTrait"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface ,   DomainEventHandlerTrait };  // --- SETUP ---  class   MyEvent  { \n     public   $newValue ; \n\n     public   function   __construct ( $value ) \n     { \n         $this - newValue   =   $value ; \n     }  }  class   MyEntity   implements   DomainEventHandlerInterface  { \n     use   DomainEventHandlerTrait ; \n\n     public   $value ; \n\n     private   function   handleMyEvent ( MyEvent   $event ) :   bool \n     { \n         if   ( $this - value   ===   $event - newValue )   { \n             return   false ; \n         } \n\n         $this - value   =   $event - newValue ; \n\n         return   true ; \n     }  }  // --- USAGE ---  $entity   =   new   MyEntity ();  if   ( $entity - handleEvent ( new   MyEvent ( new value )))   { \n     // do something  }", 
            "title": "Basic example"
        }, 
        {
            "location": "/message-driven/message-bus/", 
            "text": "Message bus\n\n\nA domain message bus is bound to \nMsgPhp\\Domain\\Message\\DomainMessageBusInterface\n. Its purpose is to dispatch any type\nof message object and helps you to use \nCQRS\n and \nevent sourcing\n.\n\n\nAPI\n\n\ndispatch(object $message): mixed\n\n\nDispatches the given message object. The bus can return a value coming from handlers, but is not required to do so.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Infra\\SimpleBus\\DomainMessageBus\n\n\nRequires \nsimple-bus/message-bus", 
            "title": "Message bus"
        }, 
        {
            "location": "/message-driven/message-bus/#message-bus", 
            "text": "A domain message bus is bound to  MsgPhp\\Domain\\Message\\DomainMessageBusInterface . Its purpose is to dispatch any type\nof message object and helps you to use  CQRS  and  event sourcing .", 
            "title": "Message bus"
        }, 
        {
            "location": "/message-driven/message-bus/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/message-driven/message-bus/#dispatchobject-message-mixed", 
            "text": "Dispatches the given message object. The bus can return a value coming from handlers, but is not required to do so.", 
            "title": "dispatch(object $message): mixed"
        }, 
        {
            "location": "/message-driven/message-bus/#implementations", 
            "text": "MsgPhp\\Domain\\Infra\\SimpleBus\\DomainMessageBus  Requires  simple-bus/message-bus", 
            "title": "Implementations"
        }, 
        {
            "location": "/message-driven/message-dispatcher/", 
            "text": "Message dispatcher\n\n\nThe domain message dispatcher is a utility trait. Its purpose is to dispatch a factorized message object using a\n\nobject factory\n and a \nmessage bus\n.\n\n\nAPI\n\n\ndispatch(string $class, array $context = []): mixed\n\n\nDispatches a message object factorized from \n$class\n and \n$context\n. The dispatcher can return a value coming from\nhandlers, but is not required to do so.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Message\\MessageDispatchingTrait\n;\n\n\n\nclass\n \nMyMessage\n\n\n{\n\n    \npublic\n \n$argument\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n(\nstring\n \n$argument\n)\n\n    \n{\n\n        \n$this\n-\nargument\n \n=\n \n$argument\n;\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyClass\n\n\n{\n\n    \nuse\n \nMessageDispatchingTrait\n;\n\n\n    \npublic\n \nfunction\n \ndoSomething\n()\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\ndispatch\n(\nMyMessage\n::\nclass\n,\n \n[\nargument\n \n=\n \nvalue\n]);\n\n    \n}\n\n\n}", 
            "title": "Message dispatcher"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#message-dispatcher", 
            "text": "The domain message dispatcher is a utility trait. Its purpose is to dispatch a factorized message object using a object factory  and a  message bus .", 
            "title": "Message dispatcher"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#dispatchstring-class-array-context-mixed", 
            "text": "Dispatches a message object factorized from  $class  and  $context . The dispatcher can return a value coming from\nhandlers, but is not required to do so.", 
            "title": "dispatch(string $class, array $context = []): mixed"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Message\\MessageDispatchingTrait ;  class   MyMessage  { \n     public   $argument ; \n\n     public   function   __construct ( string   $argument ) \n     { \n         $this - argument   =   $argument ; \n     }  }  class   MyClass  { \n     use   MessageDispatchingTrait ; \n\n     public   function   doSomething () :   void \n     { \n         $this - dispatch ( MyMessage :: class ,   [ argument   =   value ]); \n     }  }", 
            "title": "Basic example"
        }, 
        {
            "location": "/message-driven/cqrs/", 
            "text": "Command Query Responsibility Segregation\n\n\nCommands are domain objects and provided per domain layer. They usually follow a \nPOPO\n\ndesign. Its purpose is to describe an action to be taken. For commands being messages they can be dispatched using any\n\nmessage bus\n.\n\n\nEvent-sourcing command handler\n\n\nAn event-sourcing command handler utility trait is provided by \nMsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait\n.\nIts purpose is to ease the handling of command by messages by sourcing a \ndomain event\n to\nits \nevent handler\n.\n\n\n\n\nhandle(object $command, callable $onHandled = null): void\n\n\n$command\n: The command message to be handled\n\n\n$onHandled\n: Callable to be invoked in case the triggered domain event is handled. It receives the event handler\n  as first argument.\n\n\n\n\n\n\nabstract getDomainEvent(object $command): DomainEventInterface\n\n\nabstract getDomainEventHandler(object $command): DomainEventHandlerInterface\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait\n;\n \n\nuse\n \nMsgPhp\\Domain\\Event\\\n{\nDomainEventHandlerInterface\n,\n \nDomainEventInterface\n};\n\n\nuse\n \nMsgPhp\\Domain\\Message\\DomainMessageBusInterface\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyCommand\n\n\n{\n\n\n}\n\n\n\nclass\n \nMyCommandHandler\n\n\n{\n\n    \nuse\n \nEventSourcingCommandHandlerTrait\n;\n\n\n    \npublic\n \nfunction\n \n__invoke\n(\nMyCommand\n \n$command\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\nhandle\n(\n$command\n,\n \nfunction\n \n(\nMyEntity\n \n$entity\n)\n:\n \nvoid\n \n{\n\n            \n// do something when $command is handled\n\n        \n});\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \ngetDomainEvent\n(\nMyCommand\n \n$command\n)\n:\n \nDomainEventInterface\n\n    \n{\n\n        \nreturn\n \nnew\n \nMyDomainEvent\n();\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \ngetDomainEventHandler\n(\nMyCommand\n \n$command\n)\n:\n \nDomainEventHandlerInterface\n\n    \n{\n\n        \nreturn\n \nnew\n \nMyEntity\n();\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyDomainEvent\n \nimplements\n \nDomainEventInterface\n\n\n{\n\n\n}\n\n\n\nclass\n \nMyEntity\n \nimplements\n \nDomainEventHandlerInterface\n\n\n{\n\n    \npublic\n \nfunction\n \nhandleEvent\n(\nDomainEventInterface\n \n$event\n)\n:\n \nbool\n\n    \n{\n\n        \nif\n \n(\n$event\n \ninstanceof\n \nMyDomainEvent\n)\n \n{\n\n            \n// do something\n\n\n            \nreturn\n \ntrue\n;\n\n        \n}\n\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n}\n\n\n\n// --- USAGE ---\n\n\n\n/** @var DomainMessageBusInterface $bus */\n\n\n$bus\n \n=\n \n...\n;\n\n\n\n$bus\n-\ndispatch\n(\nnew\n \nMyCommand\n());", 
            "title": "CQRS"
        }, 
        {
            "location": "/message-driven/cqrs/#command-query-responsibility-segregation", 
            "text": "Commands are domain objects and provided per domain layer. They usually follow a  POPO \ndesign. Its purpose is to describe an action to be taken. For commands being messages they can be dispatched using any message bus .", 
            "title": "Command Query Responsibility Segregation"
        }, 
        {
            "location": "/message-driven/cqrs/#event-sourcing-command-handler", 
            "text": "An event-sourcing command handler utility trait is provided by  MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait .\nIts purpose is to ease the handling of command by messages by sourcing a  domain event  to\nits  event handler .   handle(object $command, callable $onHandled = null): void  $command : The command message to be handled  $onHandled : Callable to be invoked in case the triggered domain event is handled. It receives the event handler\n  as first argument.    abstract getDomainEvent(object $command): DomainEventInterface  abstract getDomainEventHandler(object $command): DomainEventHandlerInterface", 
            "title": "Event-sourcing command handler"
        }, 
        {
            "location": "/message-driven/cqrs/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait ;   use   MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface ,   DomainEventInterface };  use   MsgPhp\\Domain\\Message\\DomainMessageBusInterface ;  // --- SETUP ---  class   MyCommand  {  }  class   MyCommandHandler  { \n     use   EventSourcingCommandHandlerTrait ; \n\n     public   function   __invoke ( MyCommand   $command ) :   void \n     { \n         $this - handle ( $command ,   function   ( MyEntity   $entity ) :   void   { \n             // do something when $command is handled \n         }); \n     } \n\n     protected   function   getDomainEvent ( MyCommand   $command ) :   DomainEventInterface \n     { \n         return   new   MyDomainEvent (); \n     } \n\n     protected   function   getDomainEventHandler ( MyCommand   $command ) :   DomainEventHandlerInterface \n     { \n         return   new   MyEntity (); \n     }  }  class   MyDomainEvent   implements   DomainEventInterface  {  }  class   MyEntity   implements   DomainEventHandlerInterface  { \n     public   function   handleEvent ( DomainEventInterface   $event ) :   bool \n     { \n         if   ( $event   instanceof   MyDomainEvent )   { \n             // do something \n\n             return   true ; \n         } \n\n         return   false ; \n     }  }  // --- USAGE ---  /** @var DomainMessageBusInterface $bus */  $bus   =   ... ;  $bus - dispatch ( new   MyCommand ());", 
            "title": "Basic example"
        }, 
        {
            "location": "/infrastructure/uuid/", 
            "text": "Universally Unique Identifier\n\n\nAn overview of available infrastructural code when working with \nUUID's\n.\n\n\n\n\nRequires \nramsey/uuid\n\n\n\n\nDomain identifier\n\n\nA UUID tailored \ndomain identifier\n is provided by \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n. It\nleverages type \nRamsey\\Uuid\\UuidInterface\n as underlying data type.\n\n\n\n\n__construct(UuidInterface $uuid = null)\n\n\n$uuid\n: The underlying UUID. In case of \nnull\n a UUID version 4 value is generated upfront. Meaning the\n  identifier will never be considered empty.\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n;\n\n\nuse\n \nRamsey\\Uuid\\Uuid\n;\n\n\n\n// --- SETUP ---\n\n\n\n$id\n \n=\n \nnew\n \nDomainId\n();\n \n// a new UUID version 4 value\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\nUuid\n::\nuuid1\n());\n \n// UUID version 1 value\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\nUuid\n::\nfromString\n(\n00000000-0000-0000-0000-000000000000\n));\n \n// Nil UUID value\n\n\n\n// static\n\n\n\n$id\n \n=\n \nDomainId\n::\nfromValue\n(\n00000000-0000-0000-0000-000000000000\n);", 
            "title": "UUID"
        }, 
        {
            "location": "/infrastructure/uuid/#universally-unique-identifier", 
            "text": "An overview of available infrastructural code when working with  UUID's .   Requires  ramsey/uuid", 
            "title": "Universally Unique Identifier"
        }, 
        {
            "location": "/infrastructure/uuid/#domain-identifier", 
            "text": "A UUID tailored  domain identifier  is provided by  MsgPhp\\Domain\\Infra\\Uuid\\DomainId . It\nleverages type  Ramsey\\Uuid\\UuidInterface  as underlying data type.   __construct(UuidInterface $uuid = null)  $uuid : The underlying UUID. In case of  null  a UUID version 4 value is generated upfront. Meaning the\n  identifier will never be considered empty.", 
            "title": "Domain identifier"
        }, 
        {
            "location": "/infrastructure/uuid/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId ;  use   Ramsey\\Uuid\\Uuid ;  // --- SETUP ---  $id   =   new   DomainId ();   // a new UUID version 4 value  $id   =   new   DomainId ( Uuid :: uuid1 ());   // UUID version 1 value  $id   =   new   DomainId ( Uuid :: fromString ( 00000000-0000-0000-0000-000000000000 ));   // Nil UUID value  // static  $id   =   DomainId :: fromValue ( 00000000-0000-0000-0000-000000000000 );", 
            "title": "Basic example"
        }, 
        {
            "location": "/infrastructure/doctrine-collections/", 
            "text": "Doctrine Collections\n\n\nAn overview of available infrastructural code when using Doctrine's \nCollections\n.\n\n\n\n\nRequires \ndoctrine/collections\n\n\n\n\nDomain collection\n\n\nA Doctrine tailored \ndomain collection\n is provided by \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n.\nIt leverages type \nDoctrine\\Common\\Collections\\Collection\n as underlying data type.\n\n\n\n\n__construct(Collection $collection)\n\n\n$collection\n: The underlying collection\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nDoctrine\\Common\\Collections\\ArrayCollection\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n;\n\n\n\n// --- SETUP ---\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));\n\n\n\n// static\n\n\n\n$collection\n \n=\n \nDomainCollection\n::\nfromValue\n([\n1\n,\n \n2\n,\n \n3\n]);", 
            "title": "Collections"
        }, 
        {
            "location": "/infrastructure/doctrine-collections/#doctrine-collections", 
            "text": "An overview of available infrastructural code when using Doctrine's  Collections .   Requires  doctrine/collections", 
            "title": "Doctrine Collections"
        }, 
        {
            "location": "/infrastructure/doctrine-collections/#domain-collection", 
            "text": "A Doctrine tailored  domain collection  is provided by  MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection .\nIt leverages type  Doctrine\\Common\\Collections\\Collection  as underlying data type.   __construct(Collection $collection)  $collection : The underlying collection", 
            "title": "Domain collection"
        }, 
        {
            "location": "/infrastructure/doctrine-collections/#basic-example", 
            "text": "?php  use   Doctrine\\Common\\Collections\\ArrayCollection ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection ;  // --- SETUP ---  $collection   =   new   DomainCollection ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));  // static  $collection   =   DomainCollection :: fromValue ([ 1 ,   2 ,   3 ]);", 
            "title": "Basic example"
        }, 
        {
            "location": "/infrastructure/doctrine-dbal/", 
            "text": "Doctrine Database Abstraction Layer\n\n\nAn overview of available infrastructural code when using Doctrine's \nDatabase Abstraction Layer\n.\n\n\n\n\nRequires \ndoctrine/dbal\n\n\n\n\nDomain identifier type\n\n\nTODO", 
            "title": "DBAL"
        }, 
        {
            "location": "/infrastructure/doctrine-dbal/#doctrine-database-abstraction-layer", 
            "text": "An overview of available infrastructural code when using Doctrine's  Database Abstraction Layer .   Requires  doctrine/dbal", 
            "title": "Doctrine Database Abstraction Layer"
        }, 
        {
            "location": "/infrastructure/doctrine-dbal/#domain-identifier-type", 
            "text": "TODO", 
            "title": "Domain identifier type"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/", 
            "text": "Doctrine Object Relational Mapper\n\n\nAn overview of available infrastructural code when using Doctrine's \nObject Relational Mapper\n.\n\n\n\n\nRequires \ndoctrine/orm\n\n\n\n\nDomain identity mapping\n\n\nA Doctrine tailored \ndomain identity mapping\n is provided by\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n. It uses Doctrine's entity manager, bound to\n\nDoctrine\\ORM\\EntityManagerInterface\n, as underlying mapping.\n\n\n\n\n__construct(EntityManagerInterface $em)\n\n\n$em\n: The entity manager to use\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nDoctrine\\ORM\\EntityManagerInterface\n;\n\n\nuse\n \nDoctrine\\ORM\\Mapping\n \nas\n \nORM\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n;\n\n\n\n// --- SETUP ---\n\n\n\n/** @ORM\\Entity() */\n\n\nclass\n \nMyCompositeEntity\n\n\n{\n\n    \n/** @ORM\\Id @ORM\\Column(type=\nstring\n) */\n\n    \npublic\n \n$name\n;\n\n\n    \n/** @ORM\\Id @ORM\\Column(type=\ninteger\n) */\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n/** @var EntityManagerInterface $em */\n\n\n$em\n \n=\n \n...\n;\n\n\n$mapping\n \n=\n \nnew\n \nDomainIdentityMapping\n(\n$em\n);\n\n\n\n\n\n\nDomain repository\n\n\nA Doctrine tailored \nrepository trait\n is provided by\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n. It uses Doctrine's entity manager, bound to\n\nDoctrine\\ORM\\EntityManagerInterface\n, as underlying persistence layer.\n\n\n\n\n__construct(string $class, EntityManagerInterface $em, DomainIdentityHelper $identityHelper = null)\n\n\n$class\n: The entity class this repository is tied to\n\n\n$em\n: The entity manager to use\n\n\n$identityHelper\n: Custom domain identity helper. By default it's resolved from the given entity manager.\n  \nRead more\n.\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nDoctrine\\ORM\\EntityManagerInterface\n;\n\n\nuse\n \nDoctrine\\ORM\\Mapping\n \nas\n \nORM\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n;\n\n\n\n// --- SETUP ---\n\n\n\n/** @ORM\\Entity() */\n\n\nclass\n \nMyCompositeEntity\n\n\n{\n\n    \n/** @ORM\\Id @ORM\\Column(type=\nstring\n) */\n\n    \npublic\n \n$name\n;\n\n\n    \n/** @ORM\\Id @ORM\\Column(type=\ninteger\n) */\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n\nclass\n \nMyCompositeEntityRepository\n\n\n{\n\n    \nuse\n \nDomainEntityRepositoryTrait\n \n{\n\n        \ndoFind\n \nas\n \npublic\n \nfind\n;\n\n        \ndoExists\n \nas\n \npublic\n \nexists\n;\n\n        \ndoSave\n \nas\n \npublic\n \nsave\n;\n\n    \n}\n\n\n}\n\n\n\n/** @var EntityManagerInterface $em */\n\n\n$em\n \n=\n \n...\n;\n\n\n$repository\n \n=\n \nnew\n \nMyCompositeEntityRepository\n(\nMyCompositeEntity\n::\nclass\n,\n \n$em\n);\n\n\n\n// --- USAGE ---\n\n\n\nif\n \n(\n$repository\n-\nexists\n(\n$id\n \n=\n \n[\nname\n \n=\n \n...\n,\n \nyear\n \n=\n \n...\n]))\n \n{\n\n    \n$entity\n \n=\n \n$repository\n-\nfind\n(\n$id\n);\n\n\n}\n \nelse\n \n{\n\n    \n$entity\n \n=\n \nnew\n \nMyCompositeEntity\n();\n\n    \n$entity\n-\nname\n \n=\n \n...\n;\n\n    \n$entity\n-\nyear\n \n=\n \n...\n;\n\n\n    \n$repository\n-\nsave\n(\n$entity\n);\n\n\n}\n\n\n\n\n\n\nHydration\n\n\nTODO\n\n\nEntity reference loader\n\n\nTODO\n\n\nObject field mappings\n\n\nTODO", 
            "title": "ORM"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#doctrine-object-relational-mapper", 
            "text": "An overview of available infrastructural code when using Doctrine's  Object Relational Mapper .   Requires  doctrine/orm", 
            "title": "Doctrine Object Relational Mapper"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#domain-identity-mapping", 
            "text": "A Doctrine tailored  domain identity mapping  is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping . It uses Doctrine's entity manager, bound to Doctrine\\ORM\\EntityManagerInterface , as underlying mapping.   __construct(EntityManagerInterface $em)  $em : The entity manager to use", 
            "title": "Domain identity mapping"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#basic-example", 
            "text": "?php  use   Doctrine\\ORM\\EntityManagerInterface ;  use   Doctrine\\ORM\\Mapping   as   ORM ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping ;  // --- SETUP ---  /** @ORM\\Entity() */  class   MyCompositeEntity  { \n     /** @ORM\\Id @ORM\\Column(type= string ) */ \n     public   $name ; \n\n     /** @ORM\\Id @ORM\\Column(type= integer ) */ \n     public   $year ;  }  /** @var EntityManagerInterface $em */  $em   =   ... ;  $mapping   =   new   DomainIdentityMapping ( $em );", 
            "title": "Basic example"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#domain-repository", 
            "text": "A Doctrine tailored  repository trait  is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait . It uses Doctrine's entity manager, bound to Doctrine\\ORM\\EntityManagerInterface , as underlying persistence layer.   __construct(string $class, EntityManagerInterface $em, DomainIdentityHelper $identityHelper = null)  $class : The entity class this repository is tied to  $em : The entity manager to use  $identityHelper : Custom domain identity helper. By default it's resolved from the given entity manager.\n   Read more .", 
            "title": "Domain repository"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#basic-example_1", 
            "text": "?php  use   Doctrine\\ORM\\EntityManagerInterface ;  use   Doctrine\\ORM\\Mapping   as   ORM ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait ;  // --- SETUP ---  /** @ORM\\Entity() */  class   MyCompositeEntity  { \n     /** @ORM\\Id @ORM\\Column(type= string ) */ \n     public   $name ; \n\n     /** @ORM\\Id @ORM\\Column(type= integer ) */ \n     public   $year ;  }  class   MyCompositeEntityRepository  { \n     use   DomainEntityRepositoryTrait   { \n         doFind   as   public   find ; \n         doExists   as   public   exists ; \n         doSave   as   public   save ; \n     }  }  /** @var EntityManagerInterface $em */  $em   =   ... ;  $repository   =   new   MyCompositeEntityRepository ( MyCompositeEntity :: class ,   $em );  // --- USAGE ---  if   ( $repository - exists ( $id   =   [ name   =   ... ,   year   =   ... ]))   { \n     $entity   =   $repository - find ( $id );  }   else   { \n     $entity   =   new   MyCompositeEntity (); \n     $entity - name   =   ... ; \n     $entity - year   =   ... ; \n\n     $repository - save ( $entity );  }", 
            "title": "Basic example"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#hydration", 
            "text": "TODO", 
            "title": "Hydration"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#entity-reference-loader", 
            "text": "TODO", 
            "title": "Entity reference loader"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#object-field-mappings", 
            "text": "TODO", 
            "title": "Object field mappings"
        }, 
        {
            "location": "/infrastructure/symfony-console/", 
            "text": "Symfony Console\n\n\nAn overview of available infrastructural code when using \nSymfony Console\n.\n\n\n\n\nRequires \nsymfony/console\n\n\n\n\nContext builder\n\n\nA context builder is bound to \nMsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ContextBuilderInterface\n. Its purpose is to\n(interactively) built an arbitrary array value, i.e. the context, from a CLI command. Its value can be used as e.g. a\ncontext provided to an \nobject factory\n.\n\n\n\n\nBlog post: \nInitializing objects with CLI and the power of Symfony Console\n\n\n\n\nAPI\n\n\nconfigure(InputDefinition $definition): void\n\n\nConfigure a command input definition. See also \nInputDefinition\n.\n\n\n\n\ngetContext(InputInterface $input, StyleInterface $io): array\n\n\nResolve the actual context from the console IO. See also \nInputInterface\n\nand \nStyleInterface\n.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ClassContextBuilder\n\n\nBuild a context value from any class method signature. It configures the CLI signature by mapping required class method\narguments to command arguments, whereas optional ones are mapped to command options.\n\n\nBy default any command argument / option will be optional. If the actual class method argument is required and no value\nis given it will be asked interactively. If interaction is not possible an exception will be thrown instead.\n\n\n\n\n__construct(string $class, string $method, iterable $elementProviders = [], array $classMapping = [], int $flags = 0)\n\n\n$class / $method\n: The class method to resolve\n\n\n$elementProviders\n: Available context element providers (see \nProviding context elements\n)\n\n\n$classMapping\n: Global class mapping which resolves \n$class\n or any nested class name from type info. Usually used\n  to map interfaces to concretes.\n\n\n$flags\n: A bit mask value to toggle various flags\n\n\nClassContextBuilder::ALWAYS_OPTIONAL\n: Always map class method argument to command options\n\n\nClassContextBuilder::NO_DEFAULTS\n: Leave out default values when calling \ngetContext()\n\n\n\n\n\n\n\n\n\n\n\n\nProviding context elements\n\n\nPer-element configuration can be provided by implementing a \nMsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ContextElementProviderInterface\n.\n\n\n\n\ngetElement(string $class, string $method, string $argument): ?ContextElement\n\n\nResolve a \nContextElement\n\n  from a class/method/argument combination\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\\n{\nClassContextBuilder\n,\n \nContextElement\n,\n \nContextElementProviderInterface\n};\n\n\nuse\n \nSymfony\\Component\\Console\\Command\\Command\n;\n\n\nuse\n \nSymfony\\Component\\Console\\Input\\InputInterface\n;\n\n\nuse\n \nSymfony\\Component\\Console\\Output\\OutputInterface\n;\n\n\nuse\n \nSymfony\\Component\\Console\\Style\\SymfonyStyle\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyClass\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nstring\n \n$argument\n)\n\n    \n{\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyContextElementProvider\n \nimplements\n \nContextElementProviderInterface\n\n\n{\n\n    \npublic\n \nfunction\n \ngetElement\n(\nstring\n \n$class\n,\n \nstring\n \n$method\n,\n \nstring\n \n$argument\n)\n:\n \n?\nContextElement\n\n    \n{\n\n        \nreturn\n \nnew\n \nContextElement\n(\nstrtoupper\n(\n$argument\n));\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyCommand\n \nextends\n \nCommand\n\n\n{\n\n    \nprivate\n \n$contextBuilder\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\ncontextBuilder\n \n=\n \nnew\n \nClassContextBuilder\n(\nMyClass\n::\nclass\n,\n \n__construct\n,\n \n[\nnew\n \nMyContextElementProvider\n()]);\n\n\n        \nparent\n::\n__construct\n();\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \nconfigure\n()\n:\n \nvoid\n\n    \n{\n\n       \n$this\n-\nsetName\n(\nmy-command\n);\n\n       \n$this\n-\ncontextBuilder\n-\nconfigure\n(\n$this\n-\ngetDefinition\n());\n\n\n       \n// The CLI usage is now:\n\n       \n// bin/console my-command [argument]\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \nexecute\n(\nInputInterface\n \n$input\n,\nOutputInterface\n \n$output\n)\n:\n \nint\n\n    \n{\n\n        \n$io\n \n=\n \nnew\n \nSymfonyStyle\n(\n$input\n,\n \n$output\n);\n\n        \n$context\n \n=\n \n$this\n-\ncontextBuilder\n-\ngetContext\n(\n$input\n,\n \n$io\n);\n \n// [\nargument\n =\n \nVALUE\n]\n\n        \n$object\n \n=\n \nnew\n \nMyClass\n(\n...\narray_values\n(\n$context\n));\n\n\n        \n// do something\n\n\n        \nreturn\n \n0\n;\n\n    \n}\n\n\n}\n\n\n\n// --- USAGE ---\n\n\n\n// $ bin/console my-command", 
            "title": "Console"
        }, 
        {
            "location": "/infrastructure/symfony-console/#symfony-console", 
            "text": "An overview of available infrastructural code when using  Symfony Console .   Requires  symfony/console", 
            "title": "Symfony Console"
        }, 
        {
            "location": "/infrastructure/symfony-console/#context-builder", 
            "text": "A context builder is bound to  MsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ContextBuilderInterface . Its purpose is to\n(interactively) built an arbitrary array value, i.e. the context, from a CLI command. Its value can be used as e.g. a\ncontext provided to an  object factory .   Blog post:  Initializing objects with CLI and the power of Symfony Console", 
            "title": "Context builder"
        }, 
        {
            "location": "/infrastructure/symfony-console/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/infrastructure/symfony-console/#configureinputdefinition-definition-void", 
            "text": "Configure a command input definition. See also  InputDefinition .", 
            "title": "configure(InputDefinition $definition): void"
        }, 
        {
            "location": "/infrastructure/symfony-console/#getcontextinputinterface-input-styleinterface-io-array", 
            "text": "Resolve the actual context from the console IO. See also  InputInterface \nand  StyleInterface .", 
            "title": "getContext(InputInterface $input, StyleInterface $io): array"
        }, 
        {
            "location": "/infrastructure/symfony-console/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/infrastructure/symfony-console/#msgphpdomaininfraconsolecontextbuilderclasscontextbuilder", 
            "text": "Build a context value from any class method signature. It configures the CLI signature by mapping required class method\narguments to command arguments, whereas optional ones are mapped to command options.  By default any command argument / option will be optional. If the actual class method argument is required and no value\nis given it will be asked interactively. If interaction is not possible an exception will be thrown instead.   __construct(string $class, string $method, iterable $elementProviders = [], array $classMapping = [], int $flags = 0)  $class / $method : The class method to resolve  $elementProviders : Available context element providers (see  Providing context elements )  $classMapping : Global class mapping which resolves  $class  or any nested class name from type info. Usually used\n  to map interfaces to concretes.  $flags : A bit mask value to toggle various flags  ClassContextBuilder::ALWAYS_OPTIONAL : Always map class method argument to command options  ClassContextBuilder::NO_DEFAULTS : Leave out default values when calling  getContext()", 
            "title": "MsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ClassContextBuilder"
        }, 
        {
            "location": "/infrastructure/symfony-console/#providing-context-elements", 
            "text": "Per-element configuration can be provided by implementing a  MsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ContextElementProviderInterface .   getElement(string $class, string $method, string $argument): ?ContextElement  Resolve a  ContextElement \n  from a class/method/argument combination", 
            "title": "Providing context elements"
        }, 
        {
            "location": "/infrastructure/symfony-console/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ { ClassContextBuilder ,   ContextElement ,   ContextElementProviderInterface };  use   Symfony\\Component\\Console\\Command\\Command ;  use   Symfony\\Component\\Console\\Input\\InputInterface ;  use   Symfony\\Component\\Console\\Output\\OutputInterface ;  use   Symfony\\Component\\Console\\Style\\SymfonyStyle ;  // --- SETUP ---  class   MyClass  { \n     public   function   __construct ( string   $argument ) \n     { \n     }  }  class   MyContextElementProvider   implements   ContextElementProviderInterface  { \n     public   function   getElement ( string   $class ,   string   $method ,   string   $argument ) :   ? ContextElement \n     { \n         return   new   ContextElement ( strtoupper ( $argument )); \n     }  }  class   MyCommand   extends   Command  { \n     private   $contextBuilder ; \n\n     public   function   __construct () \n     { \n         $this - contextBuilder   =   new   ClassContextBuilder ( MyClass :: class ,   __construct ,   [ new   MyContextElementProvider ()]); \n\n         parent :: __construct (); \n     } \n\n     protected   function   configure () :   void \n     { \n        $this - setName ( my-command ); \n        $this - contextBuilder - configure ( $this - getDefinition ()); \n\n        // The CLI usage is now: \n        // bin/console my-command [argument] \n     } \n\n     protected   function   execute ( InputInterface   $input , OutputInterface   $output ) :   int \n     { \n         $io   =   new   SymfonyStyle ( $input ,   $output ); \n         $context   =   $this - contextBuilder - getContext ( $input ,   $io );   // [ argument  =   VALUE ] \n         $object   =   new   MyClass ( ... array_values ( $context )); \n\n         // do something \n\n         return   0 ; \n     }  }  // --- USAGE ---  // $ bin/console my-command", 
            "title": "Basic example"
        }, 
        {
            "location": "/domain/architecture/", 
            "text": "Domain layer architecture\n\n\nTODO", 
            "title": "Architecture"
        }, 
        {
            "location": "/domain/architecture/#domain-layer-architecture", 
            "text": "TODO", 
            "title": "Domain layer architecture"
        }, 
        {
            "location": "/domain/user/", 
            "text": "User domain layer\n\n\nTODO", 
            "title": "User domain"
        }, 
        {
            "location": "/domain/user/#user-domain-layer", 
            "text": "TODO", 
            "title": "User domain layer"
        }, 
        {
            "location": "/domain/eav/", 
            "text": "Entity-Attribute-Value domain layer\n\n\nTODO", 
            "title": "EAV domain"
        }, 
        {
            "location": "/domain/eav/#entity-attribute-value-domain-layer", 
            "text": "TODO", 
            "title": "Entity-Attribute-Value domain layer"
        }, 
        {
            "location": "/symfony-bundle/architecture/", 
            "text": "Bundle architecture\n\n\nTODO", 
            "title": "Architecture"
        }, 
        {
            "location": "/symfony-bundle/architecture/#bundle-architecture", 
            "text": "TODO", 
            "title": "Bundle architecture"
        }, 
        {
            "location": "/symfony-bundle/user/", 
            "text": "User bundle\n\n\nTODO", 
            "title": "User bundle"
        }, 
        {
            "location": "/symfony-bundle/user/#user-bundle", 
            "text": "TODO", 
            "title": "User bundle"
        }, 
        {
            "location": "/symfony-bundle/eav/", 
            "text": "Entity-Attribute-Value bundle\n\n\nTODO", 
            "title": "EAV bundle"
        }, 
        {
            "location": "/symfony-bundle/eav/#entity-attribute-value-bundle", 
            "text": "TODO", 
            "title": "Entity-Attribute-Value bundle"
        }
    ]
}