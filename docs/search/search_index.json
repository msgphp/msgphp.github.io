{
    "docs": [
        {
            "location": "/", 
            "text": "MsgPHP Documentation\n\n\n\n\nMsgPHP\n is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.\n\n\n\n\n\n\nNews\n\n\n\n\n2018-01-25\n Added initial project \ncode conventions\n\n\n2018-01-18\n Initial documentation setup. Work in progress as of today.", 
            "title": "Home"
        }, 
        {
            "location": "/#msgphp-documentation", 
            "text": "MsgPHP  is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.", 
            "title": "MsgPHP Documentation"
        }, 
        {
            "location": "/#news", 
            "text": "2018-01-25  Added initial project  code conventions  2018-01-18  Initial documentation setup. Work in progress as of today.", 
            "title": "News"
        }, 
        {
            "location": "/code-conventions/", 
            "text": "Code conventions\n\n\nA brief description of code conventions this project follows.\n\n\nGeneral principles\n\n\n\n\nNo \nSOLID\n violations, yet be pragmatic\n\n\nReduce \nlines of code\n where possible\n\n\nReduce coupling (\nLoD\n)\n\n\nFavor latest stable PHP7 features\n\n\nChecks must pass (code style, static analysis \n unit tests)\n\n\nAdd PHPDoc / comments if needed for clarification or static analysis\n\n\n\n\nCode style\n\n\n\n\nFollows PSR2 and Symfony style\n\n\nuse\n statements are declared in alpha-order\n\n\nuse\n statements for \nMsgPhp\\\n namespace are grouped by deepest common namespace\n\n\n\n\n?php\n\n\n\n// wrong\n\n\nuse\n \nMsgPhp\\SomeB\n;\n\n\nuse\n \nMsgPhp\\SomeA\n;\n\n\nuse\n \nMsgPhp\\Some\\SomeC\n;\n\n\nuse\n \nOther\\SomeOtherB\n;\n\n\nuse\n \nOther\\Some\\SomeOtherC\n;\n\n\nuse\n \nOther\\SomeOtherA\n;\n\n\n\n// right\n\n\nuse\n \nMsgPhp\\Some\\SomeC\n;\n\n\nuse\n \nMsgPhp\\\n{\nSomeA\n,\n \nSomeB\n};\n\n\nuse\n \nOther\\Some\\SomeOtherC\n;\n\n\nuse\n \nOther\\SomeOtherA\n;\n\n\nuse\n \nOther\\SomeOtherB\n;\n\n\n\n\n\n\nStatic analysis\n\n\n\n\nFollows PHPStan level max\n\n\nExclude / ignore rules are discussed per case/topic\n\n\n\n\nUnit tests\n\n\n\n\nAll of the above, \nin general\n, applies to unit tests as well", 
            "title": "Code conventions"
        }, 
        {
            "location": "/code-conventions/#code-conventions", 
            "text": "A brief description of code conventions this project follows.", 
            "title": "Code conventions"
        }, 
        {
            "location": "/code-conventions/#general-principles", 
            "text": "No  SOLID  violations, yet be pragmatic  Reduce  lines of code  where possible  Reduce coupling ( LoD )  Favor latest stable PHP7 features  Checks must pass (code style, static analysis   unit tests)  Add PHPDoc / comments if needed for clarification or static analysis", 
            "title": "General principles"
        }, 
        {
            "location": "/code-conventions/#code-style", 
            "text": "Follows PSR2 and Symfony style  use  statements are declared in alpha-order  use  statements for  MsgPhp\\  namespace are grouped by deepest common namespace   ?php  // wrong  use   MsgPhp\\SomeB ;  use   MsgPhp\\SomeA ;  use   MsgPhp\\Some\\SomeC ;  use   Other\\SomeOtherB ;  use   Other\\Some\\SomeOtherC ;  use   Other\\SomeOtherA ;  // right  use   MsgPhp\\Some\\SomeC ;  use   MsgPhp\\ { SomeA ,   SomeB };  use   Other\\Some\\SomeOtherC ;  use   Other\\SomeOtherA ;  use   Other\\SomeOtherB ;", 
            "title": "Code style"
        }, 
        {
            "location": "/code-conventions/#static-analysis", 
            "text": "Follows PHPStan level max  Exclude / ignore rules are discussed per case/topic", 
            "title": "Static analysis"
        }, 
        {
            "location": "/code-conventions/#unit-tests", 
            "text": "All of the above,  in general , applies to unit tests as well", 
            "title": "Unit tests"
        }, 
        {
            "location": "/ddd/identifiers/", 
            "text": "Identifiers\n\n\nAn identifier is a domain value object and is bound to \nMsgPhp\\Domain\\DomainIdInterface\n. It's used to identify domain\nobjects, i.e. entities.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\DomainId\n (generic scalar values)\n\n\nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n (UUID values)\n\n\nrequires: \nramsey/uuid\n\n\n\n\n\n\n\n\nAPI\n\n\nstatic fromValue($value): DomainIdInterface\n\n\nFactorizes a new identifier from a primitive value.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\n$id\n \n=\n \nDomainId\n::\nfromValue\n(\n1\n);\n \n// allowed\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\n1\n);\n \n// not allowed\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\n1\n);\n \n// allowed\n\n\n\n\n\n\n\n\nisEmpty(): bool\n\n\nTells if an identifier value is considered empty. In general this is the case when an identifier is created from a\nprimitive \nnull\n value, and therefor enables to differ its string value from an explicit empty string value (\n\"\"\n).\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\n$id\n \n=\n \nnew\n \nDomainId\n();\n\n\n$value\n \n=\n \n$id\n-\nisEmpty\n()\n \n?\n \nnull\n \n:\n \n(\nstring\n)\n \n$id\n;\n \n// null\n\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\n);\n\n\n$value\n \n=\n \n$id\n-\nisEmpty\n()\n \n?\n \nnull\n \n:\n \n(\nstring\n)\n \n$id\n;\n \n// \n\n\n\n\n\n\n\n\nequals(): bool\n\n\nTells if an identifier equals another identifier. Default implementations vary on type (including UUID). Meaning the\nsame identifier value is considered \nnot\n equal when comparing e.g.:\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\nclass\n \nMyDomainId\n \nextends\n \nDomainId\n \n{\n \n}\n\n\n\nDomainId\n::\nfromValue\n(\n1\n)\n-\nequals\n(\nMyDomainId\n::\nfromValue\n(\n1\n));\n \n// false!\n\n\n\n\n\n\n\n\ntoString(): string\n / \n__toString(): string\n\n\nReturns the string value of the identifier. If the the identifier is empty (see \nisEmpty\n) an empty string (\n\"\"\n) \nshould be returned.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\necho\n \n(\nnew\n \nDomainId\n(\n1\n))\n-\ntoString\n();\n\n\necho\n \nnew\n \nDomainId\n(\n2\n);\n\n\n\n\n\n\nUUID example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n;\n\n\nuse\n \nRamsey\\Uuid\\Uuid\n;\n\n\n\n$uuid4\n \n=\n \nDomainId\n::\nfromValue\n(\ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n$uuid4Alt\n \n=\n \nDomainId\n::\nfromValue\n(\nUuid\n::\nfromString\n(\ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n));\n\n\n$uuid4Alt2\n \n=\n \nDomainId\n::\nfromValue\n(\nUuid\n::\nuuid4\n());\n\n\n$newUuid4\n \n=\n \nnew\n \nDomainId\n();\n\n\n$newUuid5\n \n=\n \nnew\n \nDomainId\n(\nUuid\n::\nuuid5\n(\nUuid\n::\nNAMESPACE_URL\n,\n \nhttp://php.net/\n));", 
            "title": "Identifiers"
        }, 
        {
            "location": "/ddd/identifiers/#identifiers", 
            "text": "An identifier is a domain value object and is bound to  MsgPhp\\Domain\\DomainIdInterface . It's used to identify domain\nobjects, i.e. entities.", 
            "title": "Identifiers"
        }, 
        {
            "location": "/ddd/identifiers/#implementations", 
            "text": "MsgPhp\\Domain\\DomainId  (generic scalar values)  MsgPhp\\Domain\\Infra\\Uuid\\DomainId  (UUID values)  requires:  ramsey/uuid", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/identifiers/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identifiers/#static-fromvaluevalue-domainidinterface", 
            "text": "Factorizes a new identifier from a primitive value.  ?php  use   MsgPhp\\Domain\\DomainId ;  $id   =   DomainId :: fromValue ( 1 );   // allowed  $id   =   new   DomainId ( 1 );   // not allowed  $id   =   new   DomainId ( 1 );   // allowed", 
            "title": "static fromValue($value): DomainIdInterface"
        }, 
        {
            "location": "/ddd/identifiers/#isempty-bool", 
            "text": "Tells if an identifier value is considered empty. In general this is the case when an identifier is created from a\nprimitive  null  value, and therefor enables to differ its string value from an explicit empty string value ( \"\" ).  ?php  use   MsgPhp\\Domain\\DomainId ;  $id   =   new   DomainId ();  $value   =   $id - isEmpty ()   ?   null   :   ( string )   $id ;   // null  $id   =   new   DomainId ( );  $value   =   $id - isEmpty ()   ?   null   :   ( string )   $id ;   //", 
            "title": "isEmpty(): bool"
        }, 
        {
            "location": "/ddd/identifiers/#equals-bool", 
            "text": "Tells if an identifier equals another identifier. Default implementations vary on type (including UUID). Meaning the\nsame identifier value is considered  not  equal when comparing e.g.:  ?php  use   MsgPhp\\Domain\\DomainId ;  class   MyDomainId   extends   DomainId   {   }  DomainId :: fromValue ( 1 ) - equals ( MyDomainId :: fromValue ( 1 ));   // false!", 
            "title": "equals(): bool"
        }, 
        {
            "location": "/ddd/identifiers/#tostring-string-__tostring-string", 
            "text": "Returns the string value of the identifier. If the the identifier is empty (see  isEmpty ) an empty string ( \"\" ) \nshould be returned.  ?php  use   MsgPhp\\Domain\\DomainId ;  echo   ( new   DomainId ( 1 )) - toString ();  echo   new   DomainId ( 2 );", 
            "title": "toString(): string / __toString(): string"
        }, 
        {
            "location": "/ddd/identifiers/#uuid-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId ;  use   Ramsey\\Uuid\\Uuid ;  $uuid4   =   DomainId :: fromValue ( cf3d2f85-6c86-44d1-8634-af51c91a9a74 );  $uuid4Alt   =   DomainId :: fromValue ( Uuid :: fromString ( cf3d2f85-6c86-44d1-8634-af51c91a9a74 ));  $uuid4Alt2   =   DomainId :: fromValue ( Uuid :: uuid4 ());  $newUuid4   =   new   DomainId ();  $newUuid5   =   new   DomainId ( Uuid :: uuid5 ( Uuid :: NAMESPACE_URL ,   http://php.net/ ));", 
            "title": "UUID example"
        }, 
        {
            "location": "/ddd/identity-mapping/", 
            "text": "Identity mapping\n\n\nAn identity mapping is a domain service and is bound to \nMsgPhp\\Domain\\DomainIdentityMappingInterface\n. It tells about the\nidentifier mappings for a known domain object.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping\n (uses in-memory identity map)\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n (uses Doctrine identity map)\n\n\nrequires: \ndoctrine/orm\n\n\n\n\n\n\n\n\nAPI\n\n\ngetIdentifierFieldNames(string $class): array\n\n\nReturns the (composite) identifier field names for the given class. Any instance should have an identity composed of\nthese field values.\n\n\ngetIdentity(object $object): array\n\n\nReturns the actual identity value for the given object. Indexed by identifier field names.\n\n\nDoctrine example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n;\n\n\nuse\n \nDoctrine\\ORM\\EntityManagerInterface\n;\n\n\nuse\n \nDoctrine\\ORM\\Mapping\n \nas\n \nORM\n;\n\n\n\n/** @ORM\\Entity() */\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \n/** @ORM\\Id @ORM\\Column(type=\nstring\n) */\n\n    \npublic\n \n$name\n;\n\n\n    \n/** @ORM\\Id @ORM\\Column(type=\ninteger\n) */\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\n$entity\n-\nname\n \n=\n \n...\n;\n\n\n$entity\n-\nyear\n \n=\n \n...\n;\n\n\n\n/** @var EntityManagerInterface $em */\n\n\n$em\n \n=\n \n...\n;\n\n\n\n$identityMapping\n \n=\n \nnew\n \nDomainIdentityMapping\n(\n$em\n);\n\n\n\n$fields\n \n=\n \n$identityMapping\n-\ngetIdentifierFieldNames\n(\nMyEntity\n::\nclass\n);\n \n// [\nname\n, \nyear\n]\n\n\n$identity\n \n=\n \n$identityMapping\n-\ngetIdentity\n(\n$entity\n);\n \n// [\nname\n =\n ..., \nyear\n =\n ...]", 
            "title": "Identity mapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#identity-mapping", 
            "text": "An identity mapping is a domain service and is bound to  MsgPhp\\Domain\\DomainIdentityMappingInterface . It tells about the\nidentifier mappings for a known domain object.", 
            "title": "Identity mapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#implementations", 
            "text": "MsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping  (uses in-memory identity map)  MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping  (uses Doctrine identity map)  requires:  doctrine/orm", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/identity-mapping/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identity-mapping/#getidentifierfieldnamesstring-class-array", 
            "text": "Returns the (composite) identifier field names for the given class. Any instance should have an identity composed of\nthese field values.", 
            "title": "getIdentifierFieldNames(string $class): array"
        }, 
        {
            "location": "/ddd/identity-mapping/#getidentityobject-object-array", 
            "text": "Returns the actual identity value for the given object. Indexed by identifier field names.", 
            "title": "getIdentity(object $object): array"
        }, 
        {
            "location": "/ddd/identity-mapping/#doctrine-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping ;  use   Doctrine\\ORM\\EntityManagerInterface ;  use   Doctrine\\ORM\\Mapping   as   ORM ;  /** @ORM\\Entity() */  class   MyEntity  { \n     /** @ORM\\Id @ORM\\Column(type= string ) */ \n     public   $name ; \n\n     /** @ORM\\Id @ORM\\Column(type= integer ) */ \n     public   $year ;  }  $entity   =   new   MyEntity ();  $entity - name   =   ... ;  $entity - year   =   ... ;  /** @var EntityManagerInterface $em */  $em   =   ... ;  $identityMapping   =   new   DomainIdentityMapping ( $em );  $fields   =   $identityMapping - getIdentifierFieldNames ( MyEntity :: class );   // [ name ,  year ]  $identity   =   $identityMapping - getIdentity ( $entity );   // [ name  =  ...,  year  =  ...]", 
            "title": "Doctrine example"
        }, 
        {
            "location": "/ddd/collections/", 
            "text": "Collections\n\n\nA domain collection is bound to \nMsgPhp\\Domain\\DomainCollectionInterface\n. It's main usage is to aggregate objects bound\ntogether by a root entity.\n\n\nThe technical implementation is generic and may hold any type of elements from any iterable value.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\DomainCollection\n (generic collection)\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n (Doctrine collection)\n\n\nrequires: \ndoctrine/collections\n\n\n\n\n\n\n\n\nAPI\n\n\nstatic fromValue(?iterable $value): DomainCollectionInterface\n\n\nFactorizes a new collection from a primitive iterable value.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nDomainCollection\n::\nfromValue\n(\nnull\n);\n \n// allowed; empty collection\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n(\nnull\n);\n \n// not allowed\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n \n// allowed\n\n\n\n\n\n\n\n\nisEmpty(): bool\n\n\nTells if a collection is considered empty, i.e. contains zero elements.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([]);\n\n\n$collection\n-\nisEmpty\n();\n \n// true\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collection\n-\nisEmpty\n();\n \n// false\n\n\n\n\n\n\n\n\ncontains($element): bool\n\n\nTells if a collection contains the given element. Comparison is done strictly.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\n$collection\n-\ncontains\n(\n2\n);\n \n// true\n\n\n$collection\n-\ncontains\n(\n2\n);\n \n// false\n\n\n\n\n\n\n\n\ncontainsKey($key): bool\n\n\nTells if a collection contains an element at the given key/index.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\n$collection\n-\ncontainsKey\n(\n2\n);\n \n// true\n\n\n$collection\n-\ncontainsKey\n(\n3\n);\n \n// false\n\n\n\n\n\n\n\n\nfirst()\n\n\nReturns the first element, or \nfalse\n if the collection is empty.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collection\n-\nfirst\n();\n \n// int(1)\n\n\n\n\n\n\n\n\nlast()\n\n\nReturns the last element, or \nfalse\n if the collection is empty.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collection\n-\nlast\n();\n \n// int(3)\n\n\n\n\n\n\n\n\nget($key)\n\n\nReturns the element at the given key/index, or \nnull\n if the collection is empty.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collection\n-\nget\n(\n1\n);\n \n// int(2)\n\n\n\n\n\n\n\n\nfilter(callable $filter): DomainCollectionInterface\n\n\nReturns a \nnew\n collection containing only elements for which \n$filter\n returns \ntrue\n. Keys are preserved.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$twoOrHigher\n \n=\n \n$collection\n-\nfilter\n(\nfunction\n \n(\nint\n \n$element\n)\n:\n \nbool\n \n{\n\n    \nreturn\n \n$element\n \n=\n \n2\n;\n\n\n});\n\n\n\n\n\n\n\n\nslice(int $offset, int $limit = 0): DomainCollectionInterface\n\n\nReturns a \nnew\n collection containing a slice of elements. By default the slice has no limit, implied by integer \n0\n. Keys are preserved.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$onlyTwo\n \n=\n \n$collection\n-\nslice\n(\n1\n,\n \n1\n);\n\n\n$twoAndThree\n \n=\n \n$collection\n-\nslice\n(\n1\n);\n\n\n\n\n\n\n\n\nmap(callable $mapper): array\n\n\nReturns a map with each collection element as returned by \n$mapper\n.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$timesTwo\n \n=\n \n$collection\n-\nmap\n(\nfunction\n \n(\nint\n \n$element\n)\n:\n \nint\n \n{\n\n    \nreturn\n \n$element\n \n*\n \n2\n;\n\n\n});\n\n\n\n\n\n\nDoctrine example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n;\n\n\nuse\n \nDoctrine\\Common\\Collections\\ArrayCollection\n;\n\n\n\n$collection\n \n=\n \nDomainCollection\n::\nfromValue\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collectionAlt\n \n=\n \nDomainCollection\n::\nfromValue\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));\n\n\n$collectionAlt2\n \n=\n \nnew\n \nDomainCollection\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));", 
            "title": "Collections"
        }, 
        {
            "location": "/ddd/collections/#collections", 
            "text": "A domain collection is bound to  MsgPhp\\Domain\\DomainCollectionInterface . It's main usage is to aggregate objects bound\ntogether by a root entity.  The technical implementation is generic and may hold any type of elements from any iterable value.", 
            "title": "Collections"
        }, 
        {
            "location": "/ddd/collections/#implementations", 
            "text": "MsgPhp\\Domain\\DomainCollection  (generic collection)  MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection  (Doctrine collection)  requires:  doctrine/collections", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/collections/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/collections/#static-fromvalueiterable-value-domaincollectioninterface", 
            "text": "Factorizes a new collection from a primitive iterable value.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   DomainCollection :: fromValue ( null );   // allowed; empty collection  $collection   =   new   DomainCollection ( null );   // not allowed  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);   // allowed", 
            "title": "static fromValue(?iterable $value): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#isempty-bool", 
            "text": "Tells if a collection is considered empty, i.e. contains zero elements.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([]);  $collection - isEmpty ();   // true  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - isEmpty ();   // false", 
            "title": "isEmpty(): bool"
        }, 
        {
            "location": "/ddd/collections/#containselement-bool", 
            "text": "Tells if a collection contains the given element. Comparison is done strictly.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - contains ( 2 );   // true  $collection - contains ( 2 );   // false", 
            "title": "contains($element): bool"
        }, 
        {
            "location": "/ddd/collections/#containskeykey-bool", 
            "text": "Tells if a collection contains an element at the given key/index.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - containsKey ( 2 );   // true  $collection - containsKey ( 3 );   // false", 
            "title": "containsKey($key): bool"
        }, 
        {
            "location": "/ddd/collections/#first", 
            "text": "Returns the first element, or  false  if the collection is empty.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - first ();   // int(1)", 
            "title": "first()"
        }, 
        {
            "location": "/ddd/collections/#last", 
            "text": "Returns the last element, or  false  if the collection is empty.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - last ();   // int(3)", 
            "title": "last()"
        }, 
        {
            "location": "/ddd/collections/#getkey", 
            "text": "Returns the element at the given key/index, or  null  if the collection is empty.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - get ( 1 );   // int(2)", 
            "title": "get($key)"
        }, 
        {
            "location": "/ddd/collections/#filtercallable-filter-domaincollectioninterface", 
            "text": "Returns a  new  collection containing only elements for which  $filter  returns  true . Keys are preserved.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $twoOrHigher   =   $collection - filter ( function   ( int   $element ) :   bool   { \n     return   $element   =   2 ;  });", 
            "title": "filter(callable $filter): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#sliceint-offset-int-limit-0-domaincollectioninterface", 
            "text": "Returns a  new  collection containing a slice of elements. By default the slice has no limit, implied by integer  0 . Keys are preserved.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $onlyTwo   =   $collection - slice ( 1 ,   1 );  $twoAndThree   =   $collection - slice ( 1 );", 
            "title": "slice(int $offset, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#mapcallable-mapper-array", 
            "text": "Returns a map with each collection element as returned by  $mapper .  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $timesTwo   =   $collection - map ( function   ( int   $element ) :   int   { \n     return   $element   *   2 ;  });", 
            "title": "map(callable $mapper): array"
        }, 
        {
            "location": "/ddd/collections/#doctrine-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection ;  use   Doctrine\\Common\\Collections\\ArrayCollection ;  $collection   =   DomainCollection :: fromValue ([ 1 ,   2 ,   3 ]);  $collectionAlt   =   DomainCollection :: fromValue ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));  $collectionAlt2   =   new   DomainCollection ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));", 
            "title": "Doctrine example"
        }, 
        {
            "location": "/ddd/factory/object/", 
            "text": "Object factory\n\n\nA domain object factory is bound to \nMsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface\n. It's usage is to initialize\nany domain object based on a class name and context.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\ChainObjectFactory\n\n\nHolds many object factories. It returns a domain object from the first supporting factory.\n\n\nMsgPhp\\Domain\\Factory\\ClassMappingObjectFactory\n\n\nDecorates any object factory. It resolves the actual class name to use from a provided mapping or, if unknown, it uses\nthe original provided class name.\n\n\nMsgPhp\\Domain\\Factory\\DomainObjectFactory\n\n\nGeneric object factory. Initializes the given class name by reading its constructor arguments. Argument values are\nresolved from the provided context. By convention a camel cased argument name (e.g. \n$myArgument\n) matches a\ncorresponding underscored context key (e.g. \n['my_argument' =\n 'value']\n). If the context key is numeric its value will\nbe provided to a corresponding argument at index N.\n\n\nAny sub class of \nMsgPhp\\Domain\\DomainIdInterface\n or \nMsgPhp\\Domain\\DomainCollectionInterface\n will be initialized\nfrom \n$class::fromValue()\n by default, otherwise initialization happens regulary (i.e. \nnew $class(...$args)\n).\n\n\nNested objects (e.g. \nMyObject $myArgument\n) might be provided as nested context (thus array). The current factory will\nbe used to initialize the object as argument value. Another (decorating) factory can be set using \n\nDomainObjectFactory::setNestedFactory(DomainObjectFactoryInterface $factory)\n.\n\n\nAPI\n\n\ncreate(string $class, array $context = []): object\n\n\nFactorizes a new domain object by class name. Optionally a context can be provided for the factory to act upon.\n\n\nChain example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\ChainObjectFactory\n;\n\n\n\n$firstFactory\n \n=\n \n...\n;\n\n\n$secondFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nChainObjectFactory\n([\n$firstFactory\n,\n \n$secondFactory\n]);\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nSomeObject\n::\nclass\n,\n \n[\nkey\n \n=\n \nvalue\n]);\n\n\n\n\n\n\nClass mapping example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\ClassMappingObjectFactory\n;\n\n\n\ninterface\n \nKnownInterface\n \n{\n \n}\n\n\nclass\n \nSubject\n \nimplements\n \nKnownInterface\n \n{\n \n}\n\n\n\n$realFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nClassMappingObjectFactory\n([\nKnownInterface\n::\nclass\n \n=\n \nSubject\n::\nclass\n],\n \n$realFactory\n);\n\n\n\n/** @var Subject $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nKnownInterface\n::\nclass\n);\n\n\n\n\n\n\nGeneric example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainObjectFactory\n;\n\n\n\nclass\n \nSome\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nint\n \n$a\n,\n \n?\nint\n \n$b\n,\n \n?\nint\n \n$c\n)\n\n    \n{\n \n}\n\n\n}\n\n\n\nclass\n \nSubject\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nstring\n \n$argument\n,\n \nSome\n \n$some\n,\n \nSubject\n \n$otherSubject\n \n=\n \nnull\n)\n\n    \n{\n \n}\n\n\n}\n\n\n\n$factory\n \n=\n \nnew\n \nDomainObjectFactory\n();\n\n\n\n/** @var Subject $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nSubject\n::\nclass\n,\n \n[\n\n    \nargument\n \n=\n  \nvalue\n,\n\n    \nsome\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \nother_subject\n \n=\n \n[\n\n        \nargument\n \n=\n \nother_value\n,\n\n        \nsome\n \n=\n \n[\na\n \n=\n \n1\n],\n\n    \n],\n\n\n]);", 
            "title": "Object factory"
        }, 
        {
            "location": "/ddd/factory/object/#object-factory", 
            "text": "A domain object factory is bound to  MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface . It's usage is to initialize\nany domain object based on a class name and context.", 
            "title": "Object factory"
        }, 
        {
            "location": "/ddd/factory/object/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactorychainobjectfactory", 
            "text": "Holds many object factories. It returns a domain object from the first supporting factory.", 
            "title": "MsgPhp\\Domain\\Factory\\ChainObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactoryclassmappingobjectfactory", 
            "text": "Decorates any object factory. It resolves the actual class name to use from a provided mapping or, if unknown, it uses\nthe original provided class name.", 
            "title": "MsgPhp\\Domain\\Factory\\ClassMappingObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactorydomainobjectfactory", 
            "text": "Generic object factory. Initializes the given class name by reading its constructor arguments. Argument values are\nresolved from the provided context. By convention a camel cased argument name (e.g.  $myArgument ) matches a\ncorresponding underscored context key (e.g.  ['my_argument' =  'value'] ). If the context key is numeric its value will\nbe provided to a corresponding argument at index N.  Any sub class of  MsgPhp\\Domain\\DomainIdInterface  or  MsgPhp\\Domain\\DomainCollectionInterface  will be initialized\nfrom  $class::fromValue()  by default, otherwise initialization happens regulary (i.e.  new $class(...$args) ).  Nested objects (e.g.  MyObject $myArgument ) might be provided as nested context (thus array). The current factory will\nbe used to initialize the object as argument value. Another (decorating) factory can be set using  DomainObjectFactory::setNestedFactory(DomainObjectFactoryInterface $factory) .", 
            "title": "MsgPhp\\Domain\\Factory\\DomainObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/factory/object/#createstring-class-array-context-object", 
            "text": "Factorizes a new domain object by class name. Optionally a context can be provided for the factory to act upon.", 
            "title": "create(string $class, array $context = []): object"
        }, 
        {
            "location": "/ddd/factory/object/#chain-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ChainObjectFactory ;  $firstFactory   =   ... ;  $secondFactory   =   ... ;  $factory   =   new   ChainObjectFactory ([ $firstFactory ,   $secondFactory ]);  $object   =   $factory - create ( SomeObject :: class ,   [ key   =   value ]);", 
            "title": "Chain example"
        }, 
        {
            "location": "/ddd/factory/object/#class-mapping-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ClassMappingObjectFactory ;  interface   KnownInterface   {   }  class   Subject   implements   KnownInterface   {   }  $realFactory   =   ... ;  $factory   =   new   ClassMappingObjectFactory ([ KnownInterface :: class   =   Subject :: class ],   $realFactory );  /** @var Subject $object */  $object   =   $factory - create ( KnownInterface :: class );", 
            "title": "Class mapping example"
        }, 
        {
            "location": "/ddd/factory/object/#generic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainObjectFactory ;  class   Some  { \n     public   function   __construct ( int   $a ,   ? int   $b ,   ? int   $c ) \n     {   }  }  class   Subject  { \n     public   function   __construct ( string   $argument ,   Some   $some ,   Subject   $otherSubject   =   null ) \n     {   }  }  $factory   =   new   DomainObjectFactory ();  /** @var Subject $object */  $object   =   $factory - create ( Subject :: class ,   [ \n     argument   =    value , \n     some   =   [ 1 ,   2 ,   3 ], \n     other_subject   =   [ \n         argument   =   other_value , \n         some   =   [ a   =   1 ], \n     ],  ]);", 
            "title": "Generic example"
        }, 
        {
            "location": "/ddd/factory/entity/", 
            "text": "Entity factory\n\n\nAn entity factory is a domain object factory and is bound to \nMsgPhp\\Domain\\Factory\\EntityFactoryInterface\n.\nBesides initializing the entity via \ncreate()\n it can also initialize an identifier using either \nidentify()\n or \n\nnextIdentifier()\n.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\EntityFactory\n\n\nGeneric entity factory and decorates any object factory. Additionally it must be provided with the identifier class \nmapping.\n\n\nAPI\n\n\ncreate(string $class, array $context = []): object\n\n\nInherited from \nMsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface::create()\n.\n\n\n\n\nidentify(string $class, $id): DomainIdInterface\n\n\nReturns an identifier for the given entity class from a known primitive value.\n\n\n\n\nnextIdentifier(string $class): DomainIdInterface\n\n\nReturns the next identifier for the given entity class. Depending on the implementation its value might be considered\nempty if it's not capable to calculate one upfront.\n\n\nGeneric example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\EntityFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n \nas\n \nDomainUuid\n;\n\n\n\n$realFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nEntityFactory\n([\n\n    \nMyEntity\n::\nclass\n \n=\n \nDomainId\n::\nclass\n,\n\n    \nMyOtherEntity\n::\nclass\n \n=\n \nDomainUuid\n::\nclass\n,\n\n\n],\n \n$realFactory\n);\n\n\n\n/** @var DomainId $object */\n\n\n$entityId\n \n=\n \n$factory\n-\nidentify\n(\nMyEntity\n::\nclass\n,\n \n1\n);\n\n\n$factory\n-\nnextIdentifier\n(\nMyEntity\n::\nclass\n)\n-\nisEmpty\n();\n \n// true\n\n\n\n/** @var DomainUuid $object */\n\n\n$otherEntityId\n \n=\n \n$factory\n-\nidentify\n(\nMyOtherEntity\n::\nclass\n,\n \ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n$factory\n-\nnextIdentifier\n(\nMyOtherEntity\n::\nclass\n)\n-\nisEmpty\n();\n \n// false", 
            "title": "Entity factory"
        }, 
        {
            "location": "/ddd/factory/entity/#entity-factory", 
            "text": "An entity factory is a domain object factory and is bound to  MsgPhp\\Domain\\Factory\\EntityFactoryInterface .\nBesides initializing the entity via  create()  it can also initialize an identifier using either  identify()  or  nextIdentifier() .", 
            "title": "Entity factory"
        }, 
        {
            "location": "/ddd/factory/entity/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/entity/#msgphpdomainfactoryentityfactory", 
            "text": "Generic entity factory and decorates any object factory. Additionally it must be provided with the identifier class \nmapping.", 
            "title": "MsgPhp\\Domain\\Factory\\EntityFactory"
        }, 
        {
            "location": "/ddd/factory/entity/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/factory/entity/#createstring-class-array-context-object", 
            "text": "Inherited from  MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface::create() .", 
            "title": "create(string $class, array $context = []): object"
        }, 
        {
            "location": "/ddd/factory/entity/#identifystring-class-id-domainidinterface", 
            "text": "Returns an identifier for the given entity class from a known primitive value.", 
            "title": "identify(string $class, $id): DomainIdInterface"
        }, 
        {
            "location": "/ddd/factory/entity/#nextidentifierstring-class-domainidinterface", 
            "text": "Returns the next identifier for the given entity class. Depending on the implementation its value might be considered\nempty if it's not capable to calculate one upfront.", 
            "title": "nextIdentifier(string $class): DomainIdInterface"
        }, 
        {
            "location": "/ddd/factory/entity/#generic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\EntityFactory ;  use   MsgPhp\\Domain\\DomainId ;  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId   as   DomainUuid ;  $realFactory   =   ... ;  $factory   =   new   EntityFactory ([ \n     MyEntity :: class   =   DomainId :: class , \n     MyOtherEntity :: class   =   DomainUuid :: class ,  ],   $realFactory );  /** @var DomainId $object */  $entityId   =   $factory - identify ( MyEntity :: class ,   1 );  $factory - nextIdentifier ( MyEntity :: class ) - isEmpty ();   // true  /** @var DomainUuid $object */  $otherEntityId   =   $factory - identify ( MyOtherEntity :: class ,   cf3d2f85-6c86-44d1-8634-af51c91a9a74 );  $factory - nextIdentifier ( MyOtherEntity :: class ) - isEmpty ();   // false", 
            "title": "Generic example"
        }, 
        {
            "location": "/ddd/factory/static/", 
            "text": "Static factory\n\n\nA static factory is a utility class, it cannot be initialized as a new instance using \nnew ...();\n. In general its\npurpose is to factorize a known implementation for a given interface. It's designed, but not limited, to be used\ninternally mainly.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Factory\\DomainIdFactory\n\n\nMsgPhp\\Domain\\Factory\\DomainCollectionFactory\n\n\n\n\nDomain identifier factory\n\n\nFactorizes a \nMsgPhp\\Domain\\DomainIdInterface\n.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainIdFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n \nas\n \nDomainUuid\n;\n\n\n\n/** @var DomainId $id */\n\n\n$id\n \n=\n \nDomainIdFactory\n::\ncreate\n(\n1\n);\n\n\n\n/** @var DomainUuid $uuid */\n\n\n$uuid\n \n=\n \nDomainIdFactory\n::\ncreate\n(\ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n\n\n\n\nDomain collection factory\n\n\nFactorizes a \nMsgPhp\\Domain\\DomainCollectionInterface\n.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainCollectionFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n \nas\n \nDoctrineDomainCollection\n;\n\n\nuse\n \nDoctrine\\Common\\Collections\\ArrayCollection\n;\n\n\n\n/** @var DomainCollection $collection */\n\n\n$collection\n \n=\n \nDomainCollectionFactory\n::\ncreate\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\n/** @var DoctrineDomainCollection $doctrineCollection */\n\n\n$doctrineCollection\n \n=\n \nDomainCollectionFactory\n::\ncreate\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));", 
            "title": "Static factory"
        }, 
        {
            "location": "/ddd/factory/static/#static-factory", 
            "text": "A static factory is a utility class, it cannot be initialized as a new instance using  new ...(); . In general its\npurpose is to factorize a known implementation for a given interface. It's designed, but not limited, to be used\ninternally mainly.", 
            "title": "Static factory"
        }, 
        {
            "location": "/ddd/factory/static/#implementations", 
            "text": "MsgPhp\\Domain\\Factory\\DomainIdFactory  MsgPhp\\Domain\\Factory\\DomainCollectionFactory", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/static/#domain-identifier-factory", 
            "text": "Factorizes a  MsgPhp\\Domain\\DomainIdInterface .", 
            "title": "Domain identifier factory"
        }, 
        {
            "location": "/ddd/factory/static/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainIdFactory ;  use   MsgPhp\\Domain\\DomainId ;  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId   as   DomainUuid ;  /** @var DomainId $id */  $id   =   DomainIdFactory :: create ( 1 );  /** @var DomainUuid $uuid */  $uuid   =   DomainIdFactory :: create ( cf3d2f85-6c86-44d1-8634-af51c91a9a74 );", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/static/#domain-collection-factory", 
            "text": "Factorizes a  MsgPhp\\Domain\\DomainCollectionInterface .", 
            "title": "Domain collection factory"
        }, 
        {
            "location": "/ddd/factory/static/#basic-example_1", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainCollectionFactory ;  use   MsgPhp\\Domain\\DomainCollection ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection   as   DoctrineDomainCollection ;  use   Doctrine\\Common\\Collections\\ArrayCollection ;  /** @var DomainCollection $collection */  $collection   =   DomainCollectionFactory :: create ([ 1 ,   2 ,   3 ]);  /** @var DoctrineDomainCollection $doctrineCollection */  $doctrineCollection   =   DomainCollectionFactory :: create ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/repositories/", 
            "text": "Repositories\n\n\nA repository is not interface bound by default. Instead you can leverage various trait objects to rapidly create one, \ndepending on the type of infrastructure needed. By design they follow the same API although there might be subtle\ndifferences per implementation.\n\n\nNote default (interface bound) repositories are provided per domain layer.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Infra\\InMemory\\DomainEntityRepositoryTrait\n (In-memory persistence)\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n (Doctrine persistence)\n\n\nrequires: \ndoctrine/orm\n\n\n\n\n\n\n\n\nAPI\n\n\nNote this API is exposed privately as a trait. You can decide to \nchange method visibility\n\non a per case basis.\n\n\ndoFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface\n\n\nFinds all entities available.\n\n\ndoFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface\n\n\nFinds all entities matching all specified fields.\n\n\n?php\n\n\n$this\n-\ndoFindAllByFields\n([\nfield\n \n=\n \nnull\n]);\n\n\n$this\n-\ndoFindAllByFields\n([\nfield\n \n=\n \nvalue\n]);\n\n\n$this\n-\ndoFindAllByFields\n([\nfield\n \n=\n \n[\none\n,\n \nof\n,\n \nthese\n]);\n\n\n\n\n\n\ndoFind($id, ...$idN): object\n\n\nFinds a single entity by its identity.\n\n\ndoFindByFields(array $fields): object\n\n\nFinds the first entity matching all specified fields.\n\n\ndoExists($id, ...$idN): bool\n\n\nVerify if an entity exists by its identity.\n\n\ndoExistsByFields(array $fields): bool\n\n\nVerify if an entity exists matching all specified fields.\n\n\ndoSave(object $entity): void\n\n\nPersist an entity in the identity map. The entity will be available on any subsequent query.\n\n\ndoDelete(object $entity): void\n\n\nRemove an entity from the identity map. The entity will be unavailable on any subsequent query.\n\n\nGeneric Doctrine repository example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n;\n\n\nuse\n \nDoctrine\\ORM\\EntityManagerInterface\n;\n\n\n\nclass\n \nMyGenericRepository\n\n\n{\n\n    \nuse\n \nDomainEntityRepositoryTrait\n \n{\n\n        \ndoFind\n \nas\n \npublic\n \nfind\n;\n\n        \ndoExists\n \nas\n \npublic\n \nexists\n;\n\n    \n}\n\n\n}\n\n\n\n/** @var EntityManagerInterface $em */\n\n\n$em\n \n=\n \n...\n;\n\n\n\n$repository\n \n=\n \nnew\n \nMyGenericRepository\n(\nMyEntity\n::\nclass\n,\n \n$em\n);\n \n\n\n/** @var MyEntity $entity */\n\n\n$entity\n \n=\n \n$repository\n-\nfind\n(\n1\n);", 
            "title": "Repositories"
        }, 
        {
            "location": "/ddd/repositories/#repositories", 
            "text": "A repository is not interface bound by default. Instead you can leverage various trait objects to rapidly create one, \ndepending on the type of infrastructure needed. By design they follow the same API although there might be subtle\ndifferences per implementation.  Note default (interface bound) repositories are provided per domain layer.", 
            "title": "Repositories"
        }, 
        {
            "location": "/ddd/repositories/#implementations", 
            "text": "MsgPhp\\Domain\\Infra\\InMemory\\DomainEntityRepositoryTrait  (In-memory persistence)  MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait  (Doctrine persistence)  requires:  doctrine/orm", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/repositories/#api", 
            "text": "Note this API is exposed privately as a trait. You can decide to  change method visibility \non a per case basis.", 
            "title": "API"
        }, 
        {
            "location": "/ddd/repositories/#dofindallint-offset-0-int-limit-0-domaincollectioninterface", 
            "text": "Finds all entities available.", 
            "title": "doFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/repositories/#dofindallbyfieldsarray-fields-int-offset-0-int-limit-0-domaincollectioninterface", 
            "text": "Finds all entities matching all specified fields.  ?php  $this - doFindAllByFields ([ field   =   null ]);  $this - doFindAllByFields ([ field   =   value ]);  $this - doFindAllByFields ([ field   =   [ one ,   of ,   these ]);", 
            "title": "doFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/repositories/#dofindid-idn-object", 
            "text": "Finds a single entity by its identity.", 
            "title": "doFind($id, ...$idN): object"
        }, 
        {
            "location": "/ddd/repositories/#dofindbyfieldsarray-fields-object", 
            "text": "Finds the first entity matching all specified fields.", 
            "title": "doFindByFields(array $fields): object"
        }, 
        {
            "location": "/ddd/repositories/#doexistsid-idn-bool", 
            "text": "Verify if an entity exists by its identity.", 
            "title": "doExists($id, ...$idN): bool"
        }, 
        {
            "location": "/ddd/repositories/#doexistsbyfieldsarray-fields-bool", 
            "text": "Verify if an entity exists matching all specified fields.", 
            "title": "doExistsByFields(array $fields): bool"
        }, 
        {
            "location": "/ddd/repositories/#dosaveobject-entity-void", 
            "text": "Persist an entity in the identity map. The entity will be available on any subsequent query.", 
            "title": "doSave(object $entity): void"
        }, 
        {
            "location": "/ddd/repositories/#dodeleteobject-entity-void", 
            "text": "Remove an entity from the identity map. The entity will be unavailable on any subsequent query.", 
            "title": "doDelete(object $entity): void"
        }, 
        {
            "location": "/ddd/repositories/#generic-doctrine-repository-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait ;  use   Doctrine\\ORM\\EntityManagerInterface ;  class   MyGenericRepository  { \n     use   DomainEntityRepositoryTrait   { \n         doFind   as   public   find ; \n         doExists   as   public   exists ; \n     }  }  /** @var EntityManagerInterface $em */  $em   =   ... ;  $repository   =   new   MyGenericRepository ( MyEntity :: class ,   $em );   /** @var MyEntity $entity */  $entity   =   $repository - find ( 1 );", 
            "title": "Generic Doctrine repository example"
        }, 
        {
            "location": "/ddd/entities/", 
            "text": "Entities\n\n\nEntity objects are provided per domain layer and usually follow a \nPOPO\n\ndesign.\n\n\nTo simplify the creation of entities the base domain layer provides common fields and features in the form of PHP\ntraits. Entity fields can be compared to a read-operation, whereas entity features represent a write-operation.\n\n\nThey are defined in a dedicated namespace for discovery, respectively \nMsgphp\\Domain\\Entiy\\Field\\\n and\n\nMsgPhp\\Domain\\Entity\\Features\\\n.\n\n\nCommon entity fields\n\n\nCreatedAtField\n\n\nA datetime value representing the entity was initially created at.\n\n\n\n\ngetCreatedAt(): \\DateTimeInterface\n\n\nRequired to be set initially\n\n\n\n\n\n\n\n\nEnabledField\n\n\nA boolean value representing the entity should be considered enabled yes or no.\n\n\n\n\nisEnabled(): bool\n\n\nfalse\n by default\n\n\n\n\n\n\n\n\nLastUpdatedAtField\n\n\nA datetime value representing the entity was last updated at.\n\n\n\n\ngetLastUpdatedAt(): \\DateTimeInterface\n\n\nRequired to be set initially\n\n\n\n\n\n\n\n\nCommon entity features\n\n\nCanBeConfirmed\n\n\nProvides ability to confirm an entity. When used an entity is considered initially unconfirmed.\n\n\n\n\ngetConfirmationToken(): ?string\n\n\nRequired to be set initially\n\n\n\n\n\n\ngetConfirmedAt(): ?\\DateTimeInterface\n \n\n\nisConfirmed(): bool\n \n\n\nconfirm(): void\n \n\n\nconfirmationToken\n is unset\n\n\nconfirmatedAt\n is set to current datetime\n\n\n\n\n\n\n\n\nCanBeEnabled\n\n\nProvides ability to toggle an entity availability state.\n\n\n\n\nInherits from \nEnabledField\n\n\nenable(): void\n\n\ndisable(): void", 
            "title": "Entities"
        }, 
        {
            "location": "/ddd/entities/#entities", 
            "text": "Entity objects are provided per domain layer and usually follow a  POPO \ndesign.  To simplify the creation of entities the base domain layer provides common fields and features in the form of PHP\ntraits. Entity fields can be compared to a read-operation, whereas entity features represent a write-operation.  They are defined in a dedicated namespace for discovery, respectively  Msgphp\\Domain\\Entiy\\Field\\  and MsgPhp\\Domain\\Entity\\Features\\ .", 
            "title": "Entities"
        }, 
        {
            "location": "/ddd/entities/#common-entity-fields", 
            "text": "", 
            "title": "Common entity fields"
        }, 
        {
            "location": "/ddd/entities/#createdatfield", 
            "text": "A datetime value representing the entity was initially created at.   getCreatedAt(): \\DateTimeInterface  Required to be set initially", 
            "title": "CreatedAtField"
        }, 
        {
            "location": "/ddd/entities/#enabledfield", 
            "text": "A boolean value representing the entity should be considered enabled yes or no.   isEnabled(): bool  false  by default", 
            "title": "EnabledField"
        }, 
        {
            "location": "/ddd/entities/#lastupdatedatfield", 
            "text": "A datetime value representing the entity was last updated at.   getLastUpdatedAt(): \\DateTimeInterface  Required to be set initially", 
            "title": "LastUpdatedAtField"
        }, 
        {
            "location": "/ddd/entities/#common-entity-features", 
            "text": "", 
            "title": "Common entity features"
        }, 
        {
            "location": "/ddd/entities/#canbeconfirmed", 
            "text": "Provides ability to confirm an entity. When used an entity is considered initially unconfirmed.   getConfirmationToken(): ?string  Required to be set initially    getConfirmedAt(): ?\\DateTimeInterface    isConfirmed(): bool    confirm(): void    confirmationToken  is unset  confirmatedAt  is set to current datetime", 
            "title": "CanBeConfirmed"
        }, 
        {
            "location": "/ddd/entities/#canbeenabled", 
            "text": "Provides ability to toggle an entity availability state.   Inherits from  EnabledField  enable(): void  disable(): void", 
            "title": "CanBeEnabled"
        }
    ]
}