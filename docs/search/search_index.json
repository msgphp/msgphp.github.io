{
    "docs": [
        {
            "location": "/", 
            "text": "MsgPHP Documentation\n\n\n\n\nMsgPHP\n is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.\n\n\n\n\n\n\nNews\n\n\n\n\n2018-02-12\n Added \ndomain identities\n chapter\n\n\n2018-01-27\n Added initial \nmessage driven\n chapter\n\n\n2018-01-26\n Added initial \nevent sourcing\n chapter\n\n\n2018-01-25\n Added initial project \ncode conventions\n\n\n2018-01-18\n Initial documentation setup. Work in progress as of today.", 
            "title": "Home"
        }, 
        {
            "location": "/#msgphp-documentation", 
            "text": "MsgPHP  is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.", 
            "title": "MsgPHP Documentation"
        }, 
        {
            "location": "/#news", 
            "text": "2018-02-12  Added  domain identities  chapter  2018-01-27  Added initial  message driven  chapter  2018-01-26  Added initial  event sourcing  chapter  2018-01-25  Added initial project  code conventions  2018-01-18  Initial documentation setup. Work in progress as of today.", 
            "title": "News"
        }, 
        {
            "location": "/code-conventions/", 
            "text": "Code conventions\n\n\nA brief description of code conventions this project follows.\n\n\nGeneral principles\n\n\n\n\nNo \nSOLID\n violations, yet be pragmatic\n\n\nReduce \nlines of code\n where possible\n\n\nReduce coupling (\nLoD\n)\n\n\nFavor latest stable PHP7 features\n\n\nChecks must pass (code style, static analysis \n unit tests)\n\n\nAdd PHPDoc / comments if needed for clarification or static analysis\n\n\n\n\nCode style\n\n\n\n\nFollows PSR2 and Symfony style\n\n\nuse\n statements are declared in alpha-order\n\n\nuse\n statements for \nMsgPhp\\\n namespace are grouped by deepest common namespace\n\n\n\n\n?php\n\n\n\n// wrong\n\n\nuse\n \nMsgPhp\\SomeB\n;\n\n\nuse\n \nMsgPhp\\SomeA\n;\n\n\nuse\n \nMsgPhp\\Some\\SomeC\n;\n\n\nuse\n \nOther\\SomeOtherB\n;\n\n\nuse\n \nOther\\Some\\SomeOtherC\n;\n\n\nuse\n \nOther\\SomeOtherA\n;\n\n\n\n// right\n\n\nuse\n \nMsgPhp\\Some\\SomeC\n;\n\n\nuse\n \nMsgPhp\\\n{\nSomeA\n,\n \nSomeB\n};\n\n\nuse\n \nOther\\Some\\SomeOtherC\n;\n\n\nuse\n \nOther\\SomeOtherA\n;\n\n\nuse\n \nOther\\SomeOtherB\n;\n\n\n\n\n\n\nStatic analysis\n\n\n\n\nFollows PHPStan level max\n\n\nExclude / ignore rules are discussed per case/topic\n\n\n\n\nPHP 7.x forward compatibility\n\n\n\n\nIntended object values are type hinted (\n@param object $value\n and \n@return object\n)\n\n\n\n\nUnit tests\n\n\n\n\nAll of the above, \nin general\n, applies to unit tests as well", 
            "title": "Code conventions"
        }, 
        {
            "location": "/code-conventions/#code-conventions", 
            "text": "A brief description of code conventions this project follows.", 
            "title": "Code conventions"
        }, 
        {
            "location": "/code-conventions/#general-principles", 
            "text": "No  SOLID  violations, yet be pragmatic  Reduce  lines of code  where possible  Reduce coupling ( LoD )  Favor latest stable PHP7 features  Checks must pass (code style, static analysis   unit tests)  Add PHPDoc / comments if needed for clarification or static analysis", 
            "title": "General principles"
        }, 
        {
            "location": "/code-conventions/#code-style", 
            "text": "Follows PSR2 and Symfony style  use  statements are declared in alpha-order  use  statements for  MsgPhp\\  namespace are grouped by deepest common namespace   ?php  // wrong  use   MsgPhp\\SomeB ;  use   MsgPhp\\SomeA ;  use   MsgPhp\\Some\\SomeC ;  use   Other\\SomeOtherB ;  use   Other\\Some\\SomeOtherC ;  use   Other\\SomeOtherA ;  // right  use   MsgPhp\\Some\\SomeC ;  use   MsgPhp\\ { SomeA ,   SomeB };  use   Other\\Some\\SomeOtherC ;  use   Other\\SomeOtherA ;  use   Other\\SomeOtherB ;", 
            "title": "Code style"
        }, 
        {
            "location": "/code-conventions/#static-analysis", 
            "text": "Follows PHPStan level max  Exclude / ignore rules are discussed per case/topic", 
            "title": "Static analysis"
        }, 
        {
            "location": "/code-conventions/#php-7x-forward-compatibility", 
            "text": "Intended object values are type hinted ( @param object $value  and  @return object )", 
            "title": "PHP 7.x forward compatibility"
        }, 
        {
            "location": "/code-conventions/#unit-tests", 
            "text": "All of the above,  in general , applies to unit tests as well", 
            "title": "Unit tests"
        }, 
        {
            "location": "/ddd/identifiers/", 
            "text": "Identifiers\n\n\nA domain identifier is a value object, bound to \nMsgPhp\\Domain\\DomainIdInterface\n. Its purpose is to identify domain\nobjects, i.e. entities.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\DomainId\n\n\nGeneric scalar values\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n\n\nUUID values\n\n\nRequires \nramsey/uuid\n\n\n\n\n\n\n\n\nAPI\n\n\nstatic fromValue($value): DomainIdInterface\n\n\nFactorizes a new identifier from a primitive value.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\n$id\n \n=\n \nDomainId\n::\nfromValue\n(\n1\n);\n \n// allowed\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\n1\n);\n \n// not allowed\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\n1\n);\n \n// allowed\n\n\n\n\n\n\n\n\nisEmpty(): bool\n\n\nTells if an identifier value is considered empty. In general this is the case when an identifier is created from a\nprimitive \nnull\n value, and therefor enables to differ its string value from an explicit empty string value (\n\"\"\n).\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\n$id\n \n=\n \nnew\n \nDomainId\n();\n\n\n$value\n \n=\n \n$id\n-\nisEmpty\n()\n \n?\n \nnull\n \n:\n \n(\nstring\n)\n \n$id\n;\n \n// null\n\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\n);\n\n\n$value\n \n=\n \n$id\n-\nisEmpty\n()\n \n?\n \nnull\n \n:\n \n(\nstring\n)\n \n$id\n;\n \n// \n\n\n\n\n\n\n\n\nequals(): bool\n\n\nTells if an identifier equals another identifier. Default implementations vary on type (including UUID). Meaning the\nsame identifier value is considered \nnot\n equal when comparing e.g.:\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\nclass\n \nMyDomainId\n \nextends\n \nDomainId\n \n{\n \n}\n\n\n\nDomainId\n::\nfromValue\n(\n1\n)\n-\nequals\n(\nMyDomainId\n::\nfromValue\n(\n1\n));\n \n// false!\n\n\n\n\n\n\n\n\ntoString(): string\n / \n__toString(): string\n\n\nReturns the string value of the identifier. If the the identifier is empty (see \nisEmpty\n) an empty string (\n\"\"\n) \nshould be returned.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\necho\n \n(\nnew\n \nDomainId\n(\n1\n))\n-\ntoString\n();\n\n\necho\n \nnew\n \nDomainId\n(\n2\n);\n\n\n\n\n\n\nUUID example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n;\n\n\nuse\n \nRamsey\\Uuid\\Uuid\n;\n\n\n\n$uuid4\n \n=\n \nDomainId\n::\nfromValue\n(\ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n$uuid4Alt\n \n=\n \nDomainId\n::\nfromValue\n(\nUuid\n::\nfromString\n(\ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n));\n\n\n$uuid4Alt2\n \n=\n \nDomainId\n::\nfromValue\n(\nUuid\n::\nuuid4\n());\n\n\n$newUuid4\n \n=\n \nnew\n \nDomainId\n();\n\n\n$newUuid5\n \n=\n \nnew\n \nDomainId\n(\nUuid\n::\nuuid5\n(\nUuid\n::\nNAMESPACE_URL\n,\n \nhttp://php.net/\n));", 
            "title": "Identifiers"
        }, 
        {
            "location": "/ddd/identifiers/#identifiers", 
            "text": "A domain identifier is a value object, bound to  MsgPhp\\Domain\\DomainIdInterface . Its purpose is to identify domain\nobjects, i.e. entities.", 
            "title": "Identifiers"
        }, 
        {
            "location": "/ddd/identifiers/#implementations", 
            "text": "MsgPhp\\Domain\\DomainId  Generic scalar values    MsgPhp\\Domain\\Infra\\Uuid\\DomainId  UUID values  Requires  ramsey/uuid", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/identifiers/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identifiers/#static-fromvaluevalue-domainidinterface", 
            "text": "Factorizes a new identifier from a primitive value.  ?php  use   MsgPhp\\Domain\\DomainId ;  $id   =   DomainId :: fromValue ( 1 );   // allowed  $id   =   new   DomainId ( 1 );   // not allowed  $id   =   new   DomainId ( 1 );   // allowed", 
            "title": "static fromValue($value): DomainIdInterface"
        }, 
        {
            "location": "/ddd/identifiers/#isempty-bool", 
            "text": "Tells if an identifier value is considered empty. In general this is the case when an identifier is created from a\nprimitive  null  value, and therefor enables to differ its string value from an explicit empty string value ( \"\" ).  ?php  use   MsgPhp\\Domain\\DomainId ;  $id   =   new   DomainId ();  $value   =   $id - isEmpty ()   ?   null   :   ( string )   $id ;   // null  $id   =   new   DomainId ( );  $value   =   $id - isEmpty ()   ?   null   :   ( string )   $id ;   //", 
            "title": "isEmpty(): bool"
        }, 
        {
            "location": "/ddd/identifiers/#equals-bool", 
            "text": "Tells if an identifier equals another identifier. Default implementations vary on type (including UUID). Meaning the\nsame identifier value is considered  not  equal when comparing e.g.:  ?php  use   MsgPhp\\Domain\\DomainId ;  class   MyDomainId   extends   DomainId   {   }  DomainId :: fromValue ( 1 ) - equals ( MyDomainId :: fromValue ( 1 ));   // false!", 
            "title": "equals(): bool"
        }, 
        {
            "location": "/ddd/identifiers/#tostring-string-__tostring-string", 
            "text": "Returns the string value of the identifier. If the the identifier is empty (see  isEmpty ) an empty string ( \"\" ) \nshould be returned.  ?php  use   MsgPhp\\Domain\\DomainId ;  echo   ( new   DomainId ( 1 )) - toString ();  echo   new   DomainId ( 2 );", 
            "title": "toString(): string / __toString(): string"
        }, 
        {
            "location": "/ddd/identifiers/#uuid-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId ;  use   Ramsey\\Uuid\\Uuid ;  $uuid4   =   DomainId :: fromValue ( cf3d2f85-6c86-44d1-8634-af51c91a9a74 );  $uuid4Alt   =   DomainId :: fromValue ( Uuid :: fromString ( cf3d2f85-6c86-44d1-8634-af51c91a9a74 ));  $uuid4Alt2   =   DomainId :: fromValue ( Uuid :: uuid4 ());  $newUuid4   =   new   DomainId ();  $newUuid5   =   new   DomainId ( Uuid :: uuid5 ( Uuid :: NAMESPACE_URL ,   http://php.net/ ));", 
            "title": "UUID example"
        }, 
        {
            "location": "/ddd/identities/", 
            "text": "Identities\n\n\nA domain identity is a composite value of one or more individual identifier values, indexed by an identifier field name.\nIts usage is to uniquely identify a domain object, and therefor qualifying it an entity object.\n\n\nIdentifier values can be of any type, e.g. a \ndomain identifier\n, another (foreign) entity object, or\nany primitive value.\n\n\nTo ease working with the \nidentity mapping\n one can use a \nMsgPhp\\Domain\\DomainIdentityHelper\n\ndomain service.\n\n\nAPI\n\n\nisIdentifier($value): bool\n\n\nTells if \n$value\n is a known identifier value. This is either a \ndomain identifier\n object or an entity\nobject.\n\n\n\n\nisEmptyIdentifier($value): bool\n\n\nTells if \n$value\n is a known empty identifier value. It returns \ntrue\n if the specified value is either \nnull\n, an empty\n\ndomain identifier\n or an entity object without its identity set.\n\n\n\n\nnormalizeIdentifier($value)\n\n\nReturns the primitive identifier value of \n$value\n. Empty identifier values (see \nisEmptyIdentifier()\n) are normalized\nas \nnull\n, a \ndomain identifier\n as string value and an entity object as normalized identity value.\nA value of any other type is returned as is.\n\n\n\n\ngetIdentifiers(object $object): array\n\n\nReturns the actual identifier values of \n$object\n.\n\n\n\n\ngetIdentifierFieldNames(string $class): array\n\n\nReturns the identifier field names for \n$class\n. Any instance should have an identity composed of these field values.\nSee also \nDomainIdentityMappingInterface::getIdentifierFieldNames()\n.\n\n\n\n\nisIdentity(string $class, $value): bool\n\n\nTells if \n$value\n is a valid identity for type \n$class\n. An identity value is considered valid if an entity object uses\na single identifier value as identity and \n$value\n is a non empty identifier (see \nisEmptyIdentifier()\n).\n\n\nIn case of one or more identifier values, given in the form of an array, its keys must exactly match the available\nidentifier field names and its values must contain no empty identifiers.\n\n\n\n\ntoIdentity(string $class, $value): array\n\n\nReturns a composite identity value for \n$class\n from \n$value\n.\n\n\n\n\ngetIdentity(object $object): array\n\n\nReturns the actual, non empty, identifier values of \n$object\n. Each identifier value is keyed by its corresponding\nidentifier field name. ee also \nDomainIdentityMappingInterface::getIdentity()\n.", 
            "title": "Identities"
        }, 
        {
            "location": "/ddd/identities/#identities", 
            "text": "A domain identity is a composite value of one or more individual identifier values, indexed by an identifier field name.\nIts usage is to uniquely identify a domain object, and therefor qualifying it an entity object.  Identifier values can be of any type, e.g. a  domain identifier , another (foreign) entity object, or\nany primitive value.  To ease working with the  identity mapping  one can use a  MsgPhp\\Domain\\DomainIdentityHelper \ndomain service.", 
            "title": "Identities"
        }, 
        {
            "location": "/ddd/identities/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identities/#isidentifiervalue-bool", 
            "text": "Tells if  $value  is a known identifier value. This is either a  domain identifier  object or an entity\nobject.", 
            "title": "isIdentifier($value): bool"
        }, 
        {
            "location": "/ddd/identities/#isemptyidentifiervalue-bool", 
            "text": "Tells if  $value  is a known empty identifier value. It returns  true  if the specified value is either  null , an empty domain identifier  or an entity object without its identity set.", 
            "title": "isEmptyIdentifier($value): bool"
        }, 
        {
            "location": "/ddd/identities/#normalizeidentifiervalue", 
            "text": "Returns the primitive identifier value of  $value . Empty identifier values (see  isEmptyIdentifier() ) are normalized\nas  null , a  domain identifier  as string value and an entity object as normalized identity value.\nA value of any other type is returned as is.", 
            "title": "normalizeIdentifier($value)"
        }, 
        {
            "location": "/ddd/identities/#getidentifiersobject-object-array", 
            "text": "Returns the actual identifier values of  $object .", 
            "title": "getIdentifiers(object $object): array"
        }, 
        {
            "location": "/ddd/identities/#getidentifierfieldnamesstring-class-array", 
            "text": "Returns the identifier field names for  $class . Any instance should have an identity composed of these field values.\nSee also  DomainIdentityMappingInterface::getIdentifierFieldNames() .", 
            "title": "getIdentifierFieldNames(string $class): array"
        }, 
        {
            "location": "/ddd/identities/#isidentitystring-class-value-bool", 
            "text": "Tells if  $value  is a valid identity for type  $class . An identity value is considered valid if an entity object uses\na single identifier value as identity and  $value  is a non empty identifier (see  isEmptyIdentifier() ).  In case of one or more identifier values, given in the form of an array, its keys must exactly match the available\nidentifier field names and its values must contain no empty identifiers.", 
            "title": "isIdentity(string $class, $value): bool"
        }, 
        {
            "location": "/ddd/identities/#toidentitystring-class-value-array", 
            "text": "Returns a composite identity value for  $class  from  $value .", 
            "title": "toIdentity(string $class, $value): array"
        }, 
        {
            "location": "/ddd/identities/#getidentityobject-object-array", 
            "text": "Returns the actual, non empty, identifier values of  $object . Each identifier value is keyed by its corresponding\nidentifier field name. ee also  DomainIdentityMappingInterface::getIdentity() .", 
            "title": "getIdentity(object $object): array"
        }, 
        {
            "location": "/ddd/identity-mapping/", 
            "text": "Identity mapping\n\n\nAn identity mapping is a domain service and is bound to \nMsgPhp\\Domain\\DomainIdentityMappingInterface\n. It tells about\nthe identifier metadata for a known domain object.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping\n\n\nBased on in-memory identity map\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n\n\nBased on Doctrine's identity map\n\n\nRequires \ndoctrine/orm\n\n\n\n\n\n\n\n\nAPI\n\n\ngetIdentifierFieldNames(string $class): array\n\n\nReturns the identifier field names for \n$class\n. Any instance should have an identity composed of these field values.\n\n\n\n\ngetIdentity(object $object): array\n\n\nReturns the actual, non empty, identifier values of \n$object\n. Each identifier value is keyed by its corresponding\nidentifier field name.\n\n\nDoctrine example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n;\n\n\nuse\n \nDoctrine\\ORM\\EntityManagerInterface\n;\n\n\nuse\n \nDoctrine\\ORM\\Mapping\n \nas\n \nORM\n;\n\n\n\n/** @ORM\\Entity() */\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \n/** @ORM\\Id @ORM\\Column(type=\nstring\n) */\n\n    \npublic\n \n$name\n;\n\n\n    \n/** @ORM\\Id @ORM\\Column(type=\ninteger\n) */\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\n$entity\n-\nname\n \n=\n \n...\n;\n\n\n$entity\n-\nyear\n \n=\n \n...\n;\n\n\n\n/** @var EntityManagerInterface $em */\n\n\n$em\n \n=\n \n...\n;\n\n\n\n$identityMapping\n \n=\n \nnew\n \nDomainIdentityMapping\n(\n$em\n);\n\n\n\n$fields\n \n=\n \n$identityMapping\n-\ngetIdentifierFieldNames\n(\nMyEntity\n::\nclass\n);\n \n// [\nname\n, \nyear\n]\n\n\n$identity\n \n=\n \n$identityMapping\n-\ngetIdentity\n(\n$entity\n);\n \n// [\nname\n =\n ..., \nyear\n =\n ...]", 
            "title": "Identity mapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#identity-mapping", 
            "text": "An identity mapping is a domain service and is bound to  MsgPhp\\Domain\\DomainIdentityMappingInterface . It tells about\nthe identifier metadata for a known domain object.", 
            "title": "Identity mapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#implementations", 
            "text": "MsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping  Based on in-memory identity map    MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping  Based on Doctrine's identity map  Requires  doctrine/orm", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/identity-mapping/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identity-mapping/#getidentifierfieldnamesstring-class-array", 
            "text": "Returns the identifier field names for  $class . Any instance should have an identity composed of these field values.", 
            "title": "getIdentifierFieldNames(string $class): array"
        }, 
        {
            "location": "/ddd/identity-mapping/#getidentityobject-object-array", 
            "text": "Returns the actual, non empty, identifier values of  $object . Each identifier value is keyed by its corresponding\nidentifier field name.", 
            "title": "getIdentity(object $object): array"
        }, 
        {
            "location": "/ddd/identity-mapping/#doctrine-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping ;  use   Doctrine\\ORM\\EntityManagerInterface ;  use   Doctrine\\ORM\\Mapping   as   ORM ;  /** @ORM\\Entity() */  class   MyEntity  { \n     /** @ORM\\Id @ORM\\Column(type= string ) */ \n     public   $name ; \n\n     /** @ORM\\Id @ORM\\Column(type= integer ) */ \n     public   $year ;  }  $entity   =   new   MyEntity ();  $entity - name   =   ... ;  $entity - year   =   ... ;  /** @var EntityManagerInterface $em */  $em   =   ... ;  $identityMapping   =   new   DomainIdentityMapping ( $em );  $fields   =   $identityMapping - getIdentifierFieldNames ( MyEntity :: class );   // [ name ,  year ]  $identity   =   $identityMapping - getIdentity ( $entity );   // [ name  =  ...,  year  =  ...]", 
            "title": "Doctrine example"
        }, 
        {
            "location": "/ddd/collections/", 
            "text": "Collections\n\n\nA domain collection is bound to \nMsgPhp\\Domain\\DomainCollectionInterface\n. Its main purpose is is to aggregate objects\nbound together by a root entity.\n\n\nThe technical implementation is generic and may hold any type of elements from any iterable value.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\DomainCollection\n\n\nGeneric collection\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n\n\nDoctrine collection\n\n\nRequires \ndoctrine/collections\n\n\n\n\n\n\n\n\nAPI\n\n\nstatic fromValue(?iterable $value): DomainCollectionInterface\n\n\nFactorizes a new collection from a primitive iterable value.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nDomainCollection\n::\nfromValue\n(\nnull\n);\n \n// allowed; empty collection\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n(\nnull\n);\n \n// not allowed\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n \n// allowed\n\n\n\n\n\n\n\n\nisEmpty(): bool\n\n\nTells if a collection is considered empty, i.e. contains zero elements.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([]);\n\n\n$collection\n-\nisEmpty\n();\n \n// true\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collection\n-\nisEmpty\n();\n \n// false\n\n\n\n\n\n\n\n\ncontains($element): bool\n\n\nTells if a collection contains the given element. Comparison is done strictly.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\n$collection\n-\ncontains\n(\n2\n);\n \n// true\n\n\n$collection\n-\ncontains\n(\n2\n);\n \n// false\n\n\n\n\n\n\n\n\ncontainsKey($key): bool\n\n\nTells if a collection contains an element at the given key/index.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\n$collection\n-\ncontainsKey\n(\n2\n);\n \n// true\n\n\n$collection\n-\ncontainsKey\n(\n3\n);\n \n// false\n\n\n\n\n\n\n\n\nfirst()\n\n\nReturns the first element, or \nfalse\n if the collection is empty.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collection\n-\nfirst\n();\n \n// int(1)\n\n\n\n\n\n\n\n\nlast()\n\n\nReturns the last element, or \nfalse\n if the collection is empty.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collection\n-\nlast\n();\n \n// int(3)\n\n\n\n\n\n\n\n\nget($key)\n\n\nReturns the element at the given key/index, or \nnull\n if the collection is empty.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collection\n-\nget\n(\n1\n);\n \n// int(2)\n\n\n\n\n\n\n\n\nfilter(callable $filter): DomainCollectionInterface\n\n\nReturns a \nnew\n collection containing only elements for which \n$filter\n returns \ntrue\n. Keys are preserved.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$twoOrHigher\n \n=\n \n$collection\n-\nfilter\n(\nfunction\n \n(\nint\n \n$element\n)\n:\n \nbool\n \n{\n\n    \nreturn\n \n$element\n \n=\n \n2\n;\n\n\n});\n\n\n\n\n\n\n\n\nslice(int $offset, int $limit = 0): DomainCollectionInterface\n\n\nReturns a \nnew\n collection containing a slice of elements. By default the slice has no limit, implied by integer \n0\n. Keys are preserved.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$onlyTwo\n \n=\n \n$collection\n-\nslice\n(\n1\n,\n \n1\n);\n\n\n$twoAndThree\n \n=\n \n$collection\n-\nslice\n(\n1\n);\n\n\n\n\n\n\n\n\nmap(callable $mapper): array\n\n\nReturns a map with each collection element as returned by \n$mapper\n.\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$timesTwo\n \n=\n \n$collection\n-\nmap\n(\nfunction\n \n(\nint\n \n$element\n)\n:\n \nint\n \n{\n\n    \nreturn\n \n$element\n \n*\n \n2\n;\n\n\n});\n\n\n\n\n\n\nDoctrine example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n;\n\n\nuse\n \nDoctrine\\Common\\Collections\\ArrayCollection\n;\n\n\n\n$collection\n \n=\n \nDomainCollection\n::\nfromValue\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n$collectionAlt\n \n=\n \nDomainCollection\n::\nfromValue\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));\n\n\n$collectionAlt2\n \n=\n \nnew\n \nDomainCollection\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));", 
            "title": "Collections"
        }, 
        {
            "location": "/ddd/collections/#collections", 
            "text": "A domain collection is bound to  MsgPhp\\Domain\\DomainCollectionInterface . Its main purpose is is to aggregate objects\nbound together by a root entity.  The technical implementation is generic and may hold any type of elements from any iterable value.", 
            "title": "Collections"
        }, 
        {
            "location": "/ddd/collections/#implementations", 
            "text": "MsgPhp\\Domain\\DomainCollection  Generic collection    MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection  Doctrine collection  Requires  doctrine/collections", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/collections/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/collections/#static-fromvalueiterable-value-domaincollectioninterface", 
            "text": "Factorizes a new collection from a primitive iterable value.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   DomainCollection :: fromValue ( null );   // allowed; empty collection  $collection   =   new   DomainCollection ( null );   // not allowed  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);   // allowed", 
            "title": "static fromValue(?iterable $value): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#isempty-bool", 
            "text": "Tells if a collection is considered empty, i.e. contains zero elements.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([]);  $collection - isEmpty ();   // true  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - isEmpty ();   // false", 
            "title": "isEmpty(): bool"
        }, 
        {
            "location": "/ddd/collections/#containselement-bool", 
            "text": "Tells if a collection contains the given element. Comparison is done strictly.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - contains ( 2 );   // true  $collection - contains ( 2 );   // false", 
            "title": "contains($element): bool"
        }, 
        {
            "location": "/ddd/collections/#containskeykey-bool", 
            "text": "Tells if a collection contains an element at the given key/index.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - containsKey ( 2 );   // true  $collection - containsKey ( 3 );   // false", 
            "title": "containsKey($key): bool"
        }, 
        {
            "location": "/ddd/collections/#first", 
            "text": "Returns the first element, or  false  if the collection is empty.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - first ();   // int(1)", 
            "title": "first()"
        }, 
        {
            "location": "/ddd/collections/#last", 
            "text": "Returns the last element, or  false  if the collection is empty.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - last ();   // int(3)", 
            "title": "last()"
        }, 
        {
            "location": "/ddd/collections/#getkey", 
            "text": "Returns the element at the given key/index, or  null  if the collection is empty.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $collection - get ( 1 );   // int(2)", 
            "title": "get($key)"
        }, 
        {
            "location": "/ddd/collections/#filtercallable-filter-domaincollectioninterface", 
            "text": "Returns a  new  collection containing only elements for which  $filter  returns  true . Keys are preserved.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $twoOrHigher   =   $collection - filter ( function   ( int   $element ) :   bool   { \n     return   $element   =   2 ;  });", 
            "title": "filter(callable $filter): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#sliceint-offset-int-limit-0-domaincollectioninterface", 
            "text": "Returns a  new  collection containing a slice of elements. By default the slice has no limit, implied by integer  0 . Keys are preserved.  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $onlyTwo   =   $collection - slice ( 1 ,   1 );  $twoAndThree   =   $collection - slice ( 1 );", 
            "title": "slice(int $offset, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#mapcallable-mapper-array", 
            "text": "Returns a map with each collection element as returned by  $mapper .  ?php  use   MsgPhp\\Domain\\DomainCollection ;  $collection   =   new   DomainCollection ([ 1 ,   2 ,   3 ]);  $timesTwo   =   $collection - map ( function   ( int   $element ) :   int   { \n     return   $element   *   2 ;  });", 
            "title": "map(callable $mapper): array"
        }, 
        {
            "location": "/ddd/collections/#doctrine-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection ;  use   Doctrine\\Common\\Collections\\ArrayCollection ;  $collection   =   DomainCollection :: fromValue ([ 1 ,   2 ,   3 ]);  $collectionAlt   =   DomainCollection :: fromValue ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));  $collectionAlt2   =   new   DomainCollection ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));", 
            "title": "Doctrine example"
        }, 
        {
            "location": "/ddd/factory/object/", 
            "text": "Object factory\n\n\nA domain object factory is bound to \nMsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface\n. Its purpose is to initialize\nany domain object based on a class name and context.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\ChainObjectFactory\n\n\nHolds many object factories. It returns a domain object from the first supporting factory.\n\n\nMsgPhp\\Domain\\Factory\\ClassMappingObjectFactory\n\n\nDecorates any object factory. It resolves the actual class name to use from a provided mapping or, if unknown, it uses\nthe original provided class name.\n\n\nMsgPhp\\Domain\\Factory\\DomainObjectFactory\n\n\nGeneric object factory. Initializes the given class name by reading its constructor arguments. Argument values are\nresolved from the provided context. By convention a camel cased argument name (e.g. \n$myArgument\n) matches a\ncorresponding underscored context key (e.g. \n['my_argument' =\n 'value']\n). If the context key is numeric its value will\nbe provided to a corresponding argument at index N. In case an exact match exists (e.g. \n['myArgument' =\n 'value']\n) it\nwill always be used instead.\n\n\nAny sub class of \nMsgPhp\\Domain\\DomainIdInterface\n or \nMsgPhp\\Domain\\DomainCollectionInterface\n will be initialized\nfrom \n$class::fromValue()\n by default, otherwise initialization happens regulary (i.e. \nnew $class(...$args)\n).\n\n\nNested objects (e.g. \nMyObject $myArgument\n) might be provided as nested context (thus array). The current factory will\nbe used to initialize the object as argument value. Another (decorating) factory can be set using \n\nDomainObjectFactory::setNestedFactory(DomainObjectFactoryInterface $factory)\n.\n\n\nAPI\n\n\ncreate(string $class, array $context = []): object\n\n\nFactorizes a new domain object by class name. Optionally a context can be provided for the factory to act upon.\n\n\nChain example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\ChainObjectFactory\n;\n\n\n\n$firstFactory\n \n=\n \n...\n;\n\n\n$secondFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nChainObjectFactory\n([\n$firstFactory\n,\n \n$secondFactory\n]);\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nSomeObject\n::\nclass\n,\n \n[\nkey\n \n=\n \nvalue\n]);\n\n\n\n\n\n\nClass mapping example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\ClassMappingObjectFactory\n;\n\n\n\ninterface\n \nKnownInterface\n \n{\n \n}\n\n\nclass\n \nSubject\n \nimplements\n \nKnownInterface\n \n{\n \n}\n\n\n\n$realFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nClassMappingObjectFactory\n([\nKnownInterface\n::\nclass\n \n=\n \nSubject\n::\nclass\n],\n \n$realFactory\n);\n\n\n\n/** @var Subject $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nKnownInterface\n::\nclass\n);\n\n\n\n\n\n\nGeneric example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainObjectFactory\n;\n\n\n\nclass\n \nSome\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nint\n \n$a\n,\n \n?\nint\n \n$b\n,\n \n?\nint\n \n$c\n)\n\n    \n{\n \n}\n\n\n}\n\n\n\nclass\n \nSubject\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nstring\n \n$argument\n,\n \nSome\n \n$some\n,\n \nSubject\n \n$otherSubject\n \n=\n \nnull\n)\n\n    \n{\n \n}\n\n\n}\n\n\n\n$factory\n \n=\n \nnew\n \nDomainObjectFactory\n();\n\n\n\n/** @var Subject $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nSubject\n::\nclass\n,\n \n[\n\n    \nargument\n \n=\n  \nvalue\n,\n\n    \nsome\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \nother_subject\n \n=\n \n[\n\n        \nargument\n \n=\n \nother_value\n,\n\n        \nsome\n \n=\n \n[\na\n \n=\n \n1\n],\n\n    \n],\n\n\n]);", 
            "title": "Object factory"
        }, 
        {
            "location": "/ddd/factory/object/#object-factory", 
            "text": "A domain object factory is bound to  MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface . Its purpose is to initialize\nany domain object based on a class name and context.", 
            "title": "Object factory"
        }, 
        {
            "location": "/ddd/factory/object/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactorychainobjectfactory", 
            "text": "Holds many object factories. It returns a domain object from the first supporting factory.", 
            "title": "MsgPhp\\Domain\\Factory\\ChainObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactoryclassmappingobjectfactory", 
            "text": "Decorates any object factory. It resolves the actual class name to use from a provided mapping or, if unknown, it uses\nthe original provided class name.", 
            "title": "MsgPhp\\Domain\\Factory\\ClassMappingObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactorydomainobjectfactory", 
            "text": "Generic object factory. Initializes the given class name by reading its constructor arguments. Argument values are\nresolved from the provided context. By convention a camel cased argument name (e.g.  $myArgument ) matches a\ncorresponding underscored context key (e.g.  ['my_argument' =  'value'] ). If the context key is numeric its value will\nbe provided to a corresponding argument at index N. In case an exact match exists (e.g.  ['myArgument' =  'value'] ) it\nwill always be used instead.  Any sub class of  MsgPhp\\Domain\\DomainIdInterface  or  MsgPhp\\Domain\\DomainCollectionInterface  will be initialized\nfrom  $class::fromValue()  by default, otherwise initialization happens regulary (i.e.  new $class(...$args) ).  Nested objects (e.g.  MyObject $myArgument ) might be provided as nested context (thus array). The current factory will\nbe used to initialize the object as argument value. Another (decorating) factory can be set using  DomainObjectFactory::setNestedFactory(DomainObjectFactoryInterface $factory) .", 
            "title": "MsgPhp\\Domain\\Factory\\DomainObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/factory/object/#createstring-class-array-context-object", 
            "text": "Factorizes a new domain object by class name. Optionally a context can be provided for the factory to act upon.", 
            "title": "create(string $class, array $context = []): object"
        }, 
        {
            "location": "/ddd/factory/object/#chain-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ChainObjectFactory ;  $firstFactory   =   ... ;  $secondFactory   =   ... ;  $factory   =   new   ChainObjectFactory ([ $firstFactory ,   $secondFactory ]);  $object   =   $factory - create ( SomeObject :: class ,   [ key   =   value ]);", 
            "title": "Chain example"
        }, 
        {
            "location": "/ddd/factory/object/#class-mapping-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ClassMappingObjectFactory ;  interface   KnownInterface   {   }  class   Subject   implements   KnownInterface   {   }  $realFactory   =   ... ;  $factory   =   new   ClassMappingObjectFactory ([ KnownInterface :: class   =   Subject :: class ],   $realFactory );  /** @var Subject $object */  $object   =   $factory - create ( KnownInterface :: class );", 
            "title": "Class mapping example"
        }, 
        {
            "location": "/ddd/factory/object/#generic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainObjectFactory ;  class   Some  { \n     public   function   __construct ( int   $a ,   ? int   $b ,   ? int   $c ) \n     {   }  }  class   Subject  { \n     public   function   __construct ( string   $argument ,   Some   $some ,   Subject   $otherSubject   =   null ) \n     {   }  }  $factory   =   new   DomainObjectFactory ();  /** @var Subject $object */  $object   =   $factory - create ( Subject :: class ,   [ \n     argument   =    value , \n     some   =   [ 1 ,   2 ,   3 ], \n     other_subject   =   [ \n         argument   =   other_value , \n         some   =   [ a   =   1 ], \n     ],  ]);", 
            "title": "Generic example"
        }, 
        {
            "location": "/ddd/factory/entity-aware/", 
            "text": "Entity aware factory\n\n\nAn entity aware factory is a domain object factory, bound to \nMsgPhp\\Domain\\Factory\\EntityAwareFactoryInterface\n.\nBesides initializing any domain object via \ncreate()\n it's also capable to initialize an entity identifier / reference\nobject.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\EntityAwareFactory\n\n\nGeneric entity factory and decorates any object factory. Additionally it must be provided with an entity to identifier\nclass mapping.\n\n\nAPI\n\n\ncreate(string $class, array $context = []): object\n\n\nInherited from \nMsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface::create()\n.\n\n\n\n\nreference(string $class, $id): object\n\n\nReturns a reference for a known existing entity object.\n\n\n\n\nidentify(string $class, $value): DomainIdInterface\n\n\nReturns an identifier for the given entity class from a known primitive value.\n\n\n\n\nnextIdentifier(string $class): DomainIdInterface\n\n\nReturns the next identifier for the given entity class. Depending on the implementation its value might be considered\nempty if it's not capable to calculate one upfront.\n\n\nGeneric example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\EntityAwareFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n \nas\n \nDomainUuid\n;\n\n\n\n$realFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nEntityAwareFactory\n(\n$realFactory\n,\n \n[\n\n    \nMyEntity\n::\nclass\n \n=\n \nDomainId\n::\nclass\n,\n\n    \nMyOtherEntity\n::\nclass\n \n=\n \nDomainUuid\n::\nclass\n,\n\n\n]);\n\n\n\n/** @var DomainId $entityId */\n\n\n$entityId\n \n=\n \n$factory\n-\nidentify\n(\nMyEntity\n::\nclass\n,\n \n1\n);\n\n\n$factory\n-\nnextIdentifier\n(\nMyEntity\n::\nclass\n)\n-\nisEmpty\n();\n \n// true\n\n\n\n/** @var DomainUuid $entityId */\n\n\n$entityId\n \n=\n \n$factory\n-\nidentify\n(\nMyOtherEntity\n::\nclass\n,\n \ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n$factory\n-\nnextIdentifier\n(\nMyOtherEntity\n::\nclass\n)\n-\nisEmpty\n();\n \n// false\n\n\n\n\n\n\nEntity reference example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\EntityAwareFactory\n;\n\n\n\nclass\n \nMyCompositeEntity\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\n$idA\n,\n \n$idB\n)\n\n    \n{\n \n}\n\n\n}\n\n\n\nclass\n \nSome\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nMyCompositeEntity\n \n$entity\n)\n\n    \n{\n \n}\n\n\n}\n\n\n\n$realFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nEntityAwareFactory\n(\n$realFactory\n,\n \n[],\n \nfunction\n \n(\nstring\n \n$class\n,\n \n$id\n)\n \n{\n\n    \nif\n \n(\nMyCompositeEntity\n::\nclass\n \n===\n \n$class\n \n \nis_array\n(\n$id\n))\n \n{\n\n        \nreturn\n \nnew\n \n$class\n(\n$id\n[\nidA\n]\n \n??\n \nnull\n,\n \n$id\n[\nidB\n]\n \n??\n \nnull\n);\n\n    \n}\n\n\n    \nreturn\n \nnew\n \n$class\n(\n$id\n);\n\n\n});\n\n\n\n/** @var Some $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nSome\n::\nclass\n,\n \n[\n\n    \nentity\n \n=\n \n$factory\n-\nreference\n(\nMyCompositeEntity\n::\nclass\n,\n \n[\nidA\n \n=\n \n1\n,\n \nidB\n \n=\n \n2\n]),\n\n\n]);", 
            "title": "Entity aware factory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#entity-aware-factory", 
            "text": "An entity aware factory is a domain object factory, bound to  MsgPhp\\Domain\\Factory\\EntityAwareFactoryInterface .\nBesides initializing any domain object via  create()  it's also capable to initialize an entity identifier / reference\nobject.", 
            "title": "Entity aware factory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#msgphpdomainfactoryentityawarefactory", 
            "text": "Generic entity factory and decorates any object factory. Additionally it must be provided with an entity to identifier\nclass mapping.", 
            "title": "MsgPhp\\Domain\\Factory\\EntityAwareFactory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#createstring-class-array-context-object", 
            "text": "Inherited from  MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface::create() .", 
            "title": "create(string $class, array $context = []): object"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#referencestring-class-id-object", 
            "text": "Returns a reference for a known existing entity object.", 
            "title": "reference(string $class, $id): object"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#identifystring-class-value-domainidinterface", 
            "text": "Returns an identifier for the given entity class from a known primitive value.", 
            "title": "identify(string $class, $value): DomainIdInterface"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#nextidentifierstring-class-domainidinterface", 
            "text": "Returns the next identifier for the given entity class. Depending on the implementation its value might be considered\nempty if it's not capable to calculate one upfront.", 
            "title": "nextIdentifier(string $class): DomainIdInterface"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#generic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\EntityAwareFactory ;  use   MsgPhp\\Domain\\DomainId ;  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId   as   DomainUuid ;  $realFactory   =   ... ;  $factory   =   new   EntityAwareFactory ( $realFactory ,   [ \n     MyEntity :: class   =   DomainId :: class , \n     MyOtherEntity :: class   =   DomainUuid :: class ,  ]);  /** @var DomainId $entityId */  $entityId   =   $factory - identify ( MyEntity :: class ,   1 );  $factory - nextIdentifier ( MyEntity :: class ) - isEmpty ();   // true  /** @var DomainUuid $entityId */  $entityId   =   $factory - identify ( MyOtherEntity :: class ,   cf3d2f85-6c86-44d1-8634-af51c91a9a74 );  $factory - nextIdentifier ( MyOtherEntity :: class ) - isEmpty ();   // false", 
            "title": "Generic example"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#entity-reference-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\EntityAwareFactory ;  class   MyCompositeEntity  { \n     public   function   __construct ( $idA ,   $idB ) \n     {   }  }  class   Some  { \n     public   function   __construct ( MyCompositeEntity   $entity ) \n     {   }  }  $realFactory   =   ... ;  $factory   =   new   EntityAwareFactory ( $realFactory ,   [],   function   ( string   $class ,   $id )   { \n     if   ( MyCompositeEntity :: class   ===   $class     is_array ( $id ))   { \n         return   new   $class ( $id [ idA ]   ??   null ,   $id [ idB ]   ??   null ); \n     } \n\n     return   new   $class ( $id );  });  /** @var Some $object */  $object   =   $factory - create ( Some :: class ,   [ \n     entity   =   $factory - reference ( MyCompositeEntity :: class ,   [ idA   =   1 ,   idB   =   2 ]),  ]);", 
            "title": "Entity reference example"
        }, 
        {
            "location": "/ddd/factory/static/", 
            "text": "Static factory\n\n\nA static factory is a utility class, it cannot be initialized as a new instance using \nnew ...();\n. Its purpose is to\nfactorize a known implementation for a given class.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\DomainIdFactory\n\n\nFactorize an \nidentifier\n from any primitive value.\n\n\n\n\nstatic create($value): DomainIdInterface\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainIdFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n \nas\n \nDomainUuid\n;\n\n\n\n/** @var DomainId $id */\n\n\n$id\n \n=\n \nDomainIdFactory\n::\ncreate\n(\n1\n);\n\n\n\n/** @var DomainUuid $uuid */\n\n\n$uuid\n \n=\n \nDomainIdFactory\n::\ncreate\n(\ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n\n\n\n\nMsgPhp\\Domain\\Factory\\DomainCollectionFactory\n\n\nFactorizes a \ncollection\n from any primitive iterable value.\n\n\n\n\nstatic create(?iterable $value): DomainCollectionInterface\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainCollectionFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n \nas\n \nDoctrineDomainCollection\n;\n\n\nuse\n \nDoctrine\\Common\\Collections\\ArrayCollection\n;\n\n\n\n/** @var DomainCollection $collection */\n\n\n$collection\n \n=\n \nDomainCollectionFactory\n::\ncreate\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\n/** @var DoctrineDomainCollection $doctrineCollection */\n\n\n$doctrineCollection\n \n=\n \nDomainCollectionFactory\n::\ncreate\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));", 
            "title": "Static factory"
        }, 
        {
            "location": "/ddd/factory/static/#static-factory", 
            "text": "A static factory is a utility class, it cannot be initialized as a new instance using  new ...(); . Its purpose is to\nfactorize a known implementation for a given class.", 
            "title": "Static factory"
        }, 
        {
            "location": "/ddd/factory/static/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/static/#msgphpdomainfactorydomainidfactory", 
            "text": "Factorize an  identifier  from any primitive value.   static create($value): DomainIdInterface", 
            "title": "MsgPhp\\Domain\\Factory\\DomainIdFactory"
        }, 
        {
            "location": "/ddd/factory/static/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainIdFactory ;  use   MsgPhp\\Domain\\DomainId ;  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId   as   DomainUuid ;  /** @var DomainId $id */  $id   =   DomainIdFactory :: create ( 1 );  /** @var DomainUuid $uuid */  $uuid   =   DomainIdFactory :: create ( cf3d2f85-6c86-44d1-8634-af51c91a9a74 );", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/static/#msgphpdomainfactorydomaincollectionfactory", 
            "text": "Factorizes a  collection  from any primitive iterable value.   static create(?iterable $value): DomainCollectionInterface", 
            "title": "MsgPhp\\Domain\\Factory\\DomainCollectionFactory"
        }, 
        {
            "location": "/ddd/factory/static/#basic-example_1", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainCollectionFactory ;  use   MsgPhp\\Domain\\DomainCollection ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection   as   DoctrineDomainCollection ;  use   Doctrine\\Common\\Collections\\ArrayCollection ;  /** @var DomainCollection $collection */  $collection   =   DomainCollectionFactory :: create ([ 1 ,   2 ,   3 ]);  /** @var DoctrineDomainCollection $doctrineCollection */  $doctrineCollection   =   DomainCollectionFactory :: create ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/repositories/", 
            "text": "Repositories\n\n\nA repository is not interface bound by default. Instead you can leverage various trait objects to rapidly create one, \ndepending on the type of infrastructure needed. By design they follow the same API although there might be subtle\ndifferences per implementation.\n\n\nNote default (interface bound) repositories are provided per domain layer.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Infra\\InMemory\\DomainEntityRepositoryTrait\n\n\nIn-memory persistence\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n\n\nDoctrine persistence\n\n\nRequires \ndoctrine/orm\n\n\n\n\n\n\n\n\nAPI\n\n\n\n\nExposed \nprivate\n as a trait. You can decide to \nchange method visibility\n\non a per case basis.\n\n\n\n\ndoFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface\n\n\nFinds all entities available.\n\n\n\n\ndoFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface\n\n\nFinds all entities matching all specified fields.\n\n\n?php\n\n\n$this\n-\ndoFindAllByFields\n([\nfield\n \n=\n \nnull\n]);\n\n\n$this\n-\ndoFindAllByFields\n([\nfield\n \n=\n \nvalue\n]);\n\n\n$this\n-\ndoFindAllByFields\n([\nfield\n \n=\n \n[\none\n,\n \nof\n,\n \nthese\n]);\n\n\n\n\n\n\n\n\ndoFind($id): object\n\n\nFinds a single entity by its identity.\n\n\n\n\ndoFindByFields(array $fields): object\n\n\nFinds the first entity matching all specified fields.\n\n\n\n\ndoExists($id): bool\n\n\nVerify if an entity exists by its identity.\n\n\n\n\ndoExistsByFields(array $fields): bool\n\n\nVerify if an entity exists matching all specified fields.\n\n\n\n\ndoSave(object $entity): void\n\n\nPersist an entity in the identity map. The entity will be available on any subsequent query.\n\n\n\n\ndoDelete(object $entity): void\n\n\nRemove an entity from the identity map. The entity will be unavailable on any subsequent query.\n\n\nGeneric Doctrine repository example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n;\n\n\nuse\n \nDoctrine\\ORM\\EntityManagerInterface\n;\n\n\n\nclass\n \nMyGenericRepository\n\n\n{\n\n    \nuse\n \nDomainEntityRepositoryTrait\n \n{\n\n        \ndoFind\n \nas\n \npublic\n \nfind\n;\n\n    \n}\n\n\n}\n\n\n\n/** @var EntityManagerInterface $em */\n\n\n$em\n \n=\n \n...\n;\n\n\n\n$repository\n \n=\n \nnew\n \nMyGenericRepository\n(\nMyEntity\n::\nclass\n,\n \n$em\n);\n \n\n\n/** @var MyEntity $entity */\n\n\n$entity\n \n=\n \n$repository\n-\nfind\n(\n1\n);", 
            "title": "Repositories"
        }, 
        {
            "location": "/ddd/repositories/#repositories", 
            "text": "A repository is not interface bound by default. Instead you can leverage various trait objects to rapidly create one, \ndepending on the type of infrastructure needed. By design they follow the same API although there might be subtle\ndifferences per implementation.  Note default (interface bound) repositories are provided per domain layer.", 
            "title": "Repositories"
        }, 
        {
            "location": "/ddd/repositories/#implementations", 
            "text": "MsgPhp\\Domain\\Infra\\InMemory\\DomainEntityRepositoryTrait  In-memory persistence    MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait  Doctrine persistence  Requires  doctrine/orm", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/repositories/#api", 
            "text": "Exposed  private  as a trait. You can decide to  change method visibility \non a per case basis.", 
            "title": "API"
        }, 
        {
            "location": "/ddd/repositories/#dofindallint-offset-0-int-limit-0-domaincollectioninterface", 
            "text": "Finds all entities available.", 
            "title": "doFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/repositories/#dofindallbyfieldsarray-fields-int-offset-0-int-limit-0-domaincollectioninterface", 
            "text": "Finds all entities matching all specified fields.  ?php  $this - doFindAllByFields ([ field   =   null ]);  $this - doFindAllByFields ([ field   =   value ]);  $this - doFindAllByFields ([ field   =   [ one ,   of ,   these ]);", 
            "title": "doFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/repositories/#dofindid-object", 
            "text": "Finds a single entity by its identity.", 
            "title": "doFind($id): object"
        }, 
        {
            "location": "/ddd/repositories/#dofindbyfieldsarray-fields-object", 
            "text": "Finds the first entity matching all specified fields.", 
            "title": "doFindByFields(array $fields): object"
        }, 
        {
            "location": "/ddd/repositories/#doexistsid-bool", 
            "text": "Verify if an entity exists by its identity.", 
            "title": "doExists($id): bool"
        }, 
        {
            "location": "/ddd/repositories/#doexistsbyfieldsarray-fields-bool", 
            "text": "Verify if an entity exists matching all specified fields.", 
            "title": "doExistsByFields(array $fields): bool"
        }, 
        {
            "location": "/ddd/repositories/#dosaveobject-entity-void", 
            "text": "Persist an entity in the identity map. The entity will be available on any subsequent query.", 
            "title": "doSave(object $entity): void"
        }, 
        {
            "location": "/ddd/repositories/#dodeleteobject-entity-void", 
            "text": "Remove an entity from the identity map. The entity will be unavailable on any subsequent query.", 
            "title": "doDelete(object $entity): void"
        }, 
        {
            "location": "/ddd/repositories/#generic-doctrine-repository-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait ;  use   Doctrine\\ORM\\EntityManagerInterface ;  class   MyGenericRepository  { \n     use   DomainEntityRepositoryTrait   { \n         doFind   as   public   find ; \n     }  }  /** @var EntityManagerInterface $em */  $em   =   ... ;  $repository   =   new   MyGenericRepository ( MyEntity :: class ,   $em );   /** @var MyEntity $entity */  $entity   =   $repository - find ( 1 );", 
            "title": "Generic Doctrine repository example"
        }, 
        {
            "location": "/ddd/entities/", 
            "text": "Entities\n\n\nEntity objects are provided per domain layer and usually follow a \nPOPO\n\ndesign.\n\n\nTo simplify the creation of entities the base domain layer provides common fields and features in the form of PHP\ntraits. Entity fields can be compared to a read-operation, whereas entity features represent a write-operation.\n\n\nThey are defined in a dedicated namespace for discovery, respectively \nMsgphp\\Domain\\Entiy\\Field\\\n and\n\nMsgPhp\\Domain\\Entity\\Features\\\n.\n\n\nCommon entity fields\n\n\nCreatedAtField\n\n\nA datetime value representing the entity was initially created at.\n\n\n\n\ngetCreatedAt(): \\DateTimeInterface\n\n\nRequired to be set initially\n\n\n\n\n\n\n\n\nEnabledField\n\n\nA boolean value representing the entity should be considered enabled yes or no.\n\n\n\n\nisEnabled(): bool\n\n\nfalse\n by default\n\n\n\n\n\n\n\n\nLastUpdatedAtField\n\n\nA datetime value representing the entity was last updated at.\n\n\n\n\ngetLastUpdatedAt(): \\DateTimeInterface\n\n\nRequired to be set initially\n\n\n\n\n\n\n\n\nCommon entity features\n\n\nCanBeConfirmed\n\n\nProvides ability to confirm an entity. When used an entity is considered initially unconfirmed.\n\n\n\n\ngetConfirmationToken(): ?string\n\n\nRequired to be set initially\n\n\n\n\n\n\ngetConfirmedAt(): ?\\DateTimeInterface\n \n\n\nisConfirmed(): bool\n \n\n\nconfirm(): void\n \n\n\nconfirmationToken\n is unset\n\n\nconfirmatedAt\n is set to current datetime\n\n\n\n\n\n\n\n\nCanBeEnabled\n\n\nProvides ability to toggle an entity availability state.\n\n\n\n\nInherits from \nEnabledField\n\n\nenable(): void\n\n\ndisable(): void", 
            "title": "Entities"
        }, 
        {
            "location": "/ddd/entities/#entities", 
            "text": "Entity objects are provided per domain layer and usually follow a  POPO \ndesign.  To simplify the creation of entities the base domain layer provides common fields and features in the form of PHP\ntraits. Entity fields can be compared to a read-operation, whereas entity features represent a write-operation.  They are defined in a dedicated namespace for discovery, respectively  Msgphp\\Domain\\Entiy\\Field\\  and MsgPhp\\Domain\\Entity\\Features\\ .", 
            "title": "Entities"
        }, 
        {
            "location": "/ddd/entities/#common-entity-fields", 
            "text": "", 
            "title": "Common entity fields"
        }, 
        {
            "location": "/ddd/entities/#createdatfield", 
            "text": "A datetime value representing the entity was initially created at.   getCreatedAt(): \\DateTimeInterface  Required to be set initially", 
            "title": "CreatedAtField"
        }, 
        {
            "location": "/ddd/entities/#enabledfield", 
            "text": "A boolean value representing the entity should be considered enabled yes or no.   isEnabled(): bool  false  by default", 
            "title": "EnabledField"
        }, 
        {
            "location": "/ddd/entities/#lastupdatedatfield", 
            "text": "A datetime value representing the entity was last updated at.   getLastUpdatedAt(): \\DateTimeInterface  Required to be set initially", 
            "title": "LastUpdatedAtField"
        }, 
        {
            "location": "/ddd/entities/#common-entity-features", 
            "text": "", 
            "title": "Common entity features"
        }, 
        {
            "location": "/ddd/entities/#canbeconfirmed", 
            "text": "Provides ability to confirm an entity. When used an entity is considered initially unconfirmed.   getConfirmationToken(): ?string  Required to be set initially    getConfirmedAt(): ?\\DateTimeInterface    isConfirmed(): bool    confirm(): void    confirmationToken  is unset  confirmatedAt  is set to current datetime", 
            "title": "CanBeConfirmed"
        }, 
        {
            "location": "/ddd/entities/#canbeenabled", 
            "text": "Provides ability to toggle an entity availability state.   Inherits from  EnabledField  enable(): void  disable(): void", 
            "title": "CanBeEnabled"
        }, 
        {
            "location": "/event-sourcing/events/", 
            "text": "Events\n\n\nA domain event is bound to \nMsgPhp\\Domain\\Event\\DomainEventInterface\n. Its purpose is to identify concrete domain events\nand represent something that happens. When handled it might lead to an application state change.\n\n\nImplementations\n\n\nDomain events provided and handled by default \nentity features\n:\n\n\n\n\nMsgPhp\\Domain\\Event\\ConfirmEvent\n\n\nMsgPhp\\Domain\\Event\\DisableEvent\n\n\nMsgPhp\\Domain\\Event\\EnableEvent", 
            "title": "Events"
        }, 
        {
            "location": "/event-sourcing/events/#events", 
            "text": "A domain event is bound to  MsgPhp\\Domain\\Event\\DomainEventInterface . Its purpose is to identify concrete domain events\nand represent something that happens. When handled it might lead to an application state change.", 
            "title": "Events"
        }, 
        {
            "location": "/event-sourcing/events/#implementations", 
            "text": "Domain events provided and handled by default  entity features :   MsgPhp\\Domain\\Event\\ConfirmEvent  MsgPhp\\Domain\\Event\\DisableEvent  MsgPhp\\Domain\\Event\\EnableEvent", 
            "title": "Implementations"
        }, 
        {
            "location": "/event-sourcing/event-handlers/", 
            "text": "Event handlers\n\n\nA domain event handler is bound to \nMsgPhp\\Domain\\Event\\DomainEventHandlerInterface\n. Its purpose is to handle\n\ndomain events\n. By convention a trait implementation is provided to map concrete events to corresponding\nhandling methods.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Event\\DomainEventHandlerTrait\n\n\nMaps events to \nhandle\nClassName_Without_Event_Suffix\nEvent()\n methods\n\n\n\n\n\n\n\n\nAPI\n\n\nhandleEvent(DomainEventInterface $event): bool\n\n\nHandles the given domain event for a known subject. A boolean return value tells a domain event is actually handled yes\nor no.\n\n\nGeneric example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Event\\DomainEventHandlerInterface\n;\n\n\nuse\n \nMsgPhp\\Domain\\Event\\DomainEventHandlerTrait\n;\n\n\n\nclass\n \nMyEvent\n\n\n{\n\n    \npublic\n \n$newValue\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n(\n$value\n)\n\n    \n{\n\n        \n$this\n-\nnewValue\n \n=\n \n$value\n;\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyEntity\n \nimplements\n \nDomainEventHandlerInterface\n\n\n{\n\n    \nuse\n \nDomainEventHandlerTrait\n;\n\n\n    \npublic\n \n$value\n;\n\n\n    \nprivate\n \nfunction\n \nhandleMyEvent\n(\nMyEvent\n \n$event\n)\n:\n \nbool\n\n    \n{\n\n        \nif\n \n(\n$this\n-\nvalue\n \n===\n \n$event\n-\nnewValue\n)\n \n{\n\n            \nreturn\n \nfalse\n;\n\n        \n}\n\n\n        \n$this\n-\nvalue\n \n=\n \n$event\n-\nnewValue\n;\n\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n\n\n}\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\nif\n \n(\n$entity\n-\nhandleEvent\n(\nnew\n \nMyEvent\n(\nvalue\n)))\n \n{\n\n    \n// do something\n\n\n}", 
            "title": "Event handlers"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#event-handlers", 
            "text": "A domain event handler is bound to  MsgPhp\\Domain\\Event\\DomainEventHandlerInterface . Its purpose is to handle domain events . By convention a trait implementation is provided to map concrete events to corresponding\nhandling methods.", 
            "title": "Event handlers"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#implementations", 
            "text": "MsgPhp\\Domain\\Event\\DomainEventHandlerTrait  Maps events to  handle ClassName_Without_Event_Suffix Event()  methods", 
            "title": "Implementations"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#handleeventdomaineventinterface-event-bool", 
            "text": "Handles the given domain event for a known subject. A boolean return value tells a domain event is actually handled yes\nor no.", 
            "title": "handleEvent(DomainEventInterface $event): bool"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#generic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Event\\DomainEventHandlerInterface ;  use   MsgPhp\\Domain\\Event\\DomainEventHandlerTrait ;  class   MyEvent  { \n     public   $newValue ; \n\n     public   function   __construct ( $value ) \n     { \n         $this - newValue   =   $value ; \n     }  }  class   MyEntity   implements   DomainEventHandlerInterface  { \n     use   DomainEventHandlerTrait ; \n\n     public   $value ; \n\n     private   function   handleMyEvent ( MyEvent   $event ) :   bool \n     { \n         if   ( $this - value   ===   $event - newValue )   { \n             return   false ; \n         } \n\n         $this - value   =   $event - newValue ; \n\n         return   true ; \n     }  }  $entity   =   new   MyEntity ();  if   ( $entity - handleEvent ( new   MyEvent ( value )))   { \n     // do something  }", 
            "title": "Generic example"
        }, 
        {
            "location": "/message-driven/message-bus/", 
            "text": "Message bus\n\n\nA domain message bus is bound to \nMsgPhp\\Domain\\Message\\DomainMessageBusInterface\n. Its purpose is to dispatch any type\nof message object and helps you to use \nCQRS\n and \nevent sourcing\n.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Infra\\SimpleBus\\DomainMessageBus\n\n\nRequires \nsimple-bus/message-bus\n\n\n\n\n\n\n\n\nAPI\n\n\ndispatch(object $message): mixed\n\n\nDispatches the given message object. The bus can return a value coming from handlers, but is not required to do so.", 
            "title": "Message bus"
        }, 
        {
            "location": "/message-driven/message-bus/#message-bus", 
            "text": "A domain message bus is bound to  MsgPhp\\Domain\\Message\\DomainMessageBusInterface . Its purpose is to dispatch any type\nof message object and helps you to use  CQRS  and  event sourcing .", 
            "title": "Message bus"
        }, 
        {
            "location": "/message-driven/message-bus/#implementations", 
            "text": "MsgPhp\\Domain\\Infra\\SimpleBus\\DomainMessageBus  Requires  simple-bus/message-bus", 
            "title": "Implementations"
        }, 
        {
            "location": "/message-driven/message-bus/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/message-driven/message-bus/#dispatchobject-message-mixed", 
            "text": "Dispatches the given message object. The bus can return a value coming from handlers, but is not required to do so.", 
            "title": "dispatch(object $message): mixed"
        }, 
        {
            "location": "/message-driven/message-dispatcher/", 
            "text": "Message dispatcher\n\n\nThe domain message dispatcher is a utility trait. Its purpose is to dispatch a message, factorized by a\n\nobject factory\n, using any \nmessage bus\n.\n\n\nAPI\n\n\n\n\nExposed \nprivate\n as a trait. You can decide to \nchange method visibility\n\non a per case basis.\n\n\n\n\ndispatch(string $class, array $context = []): mixed\n\n\nDispatches the given message class. The dispatcher can return a value coming from handlers, but is not required to do\nso.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Message\\MessageDispatchingTrait\n;\n\n\n\nclass\n \nMyClass\n\n\n{\n\n    \nuse\n \nMessageDispatchingTrait\n;\n\n\n    \npublic\n \nfunction\n \ndoSomething\n()\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\ndispatch\n(\nSomeMessage\n::\nclass\n,\n \n[\narg\n \n=\n \nvalue\n]);\n\n    \n}\n\n\n}", 
            "title": "Message dispatcher"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#message-dispatcher", 
            "text": "The domain message dispatcher is a utility trait. Its purpose is to dispatch a message, factorized by a object factory , using any  message bus .", 
            "title": "Message dispatcher"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#api", 
            "text": "Exposed  private  as a trait. You can decide to  change method visibility \non a per case basis.", 
            "title": "API"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#dispatchstring-class-array-context-mixed", 
            "text": "Dispatches the given message class. The dispatcher can return a value coming from handlers, but is not required to do\nso.", 
            "title": "dispatch(string $class, array $context = []): mixed"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Message\\MessageDispatchingTrait ;  class   MyClass  { \n     use   MessageDispatchingTrait ; \n\n     public   function   doSomething () :   void \n     { \n         $this - dispatch ( SomeMessage :: class ,   [ arg   =   value ]); \n     }  }", 
            "title": "Basic example"
        }, 
        {
            "location": "/message-driven/cqrs/", 
            "text": "Command Query Responsibility Segregation\n\n\nCommands are domain objects and provided per domain layer. They usually follow a \nPOPO\n\ndesign. Its purpose is to describe an action to be taken. For commands being messages they can be dispatched using any\n\nmessage bus\n.\n\n\nCommand handlers\n\n\nThe message bus resolves a command handler, which in turn handles the command. Thus performs the requested action.\nUsually a command handler is designed, but not limited, to handle one specific command message.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait\n\n\nHandles a command message by sourcing a domain event.\n\n\n\n\nhandle(object $command, callable $onHandled = null): void\n\n\nIf the domain event is handled \n$onHandled\n will be invoked (if given), receiving the handler as first argument\n\n\n\n\n\n\nabstract getDomainEvent(object $command): DomainEventInterface\n\n\nThe \ndomain event\n to be handled\n\n\n\n\n\n\nabstract getDomainEventHandler(object $command): DomainEventHandlerInterface\n\n\nThe \ndomain event handler\n handling the domain event\n\n\n\n\n\n\n\n\nGeneric example\n\n\n?php\n\n\n\nclass\n \nMyCommand\n \n{\n \n}\n\n\nclass\n \nMyCommandHandler\n\n\n{\n\n    \npublic\n \nfunction\n \n__invoke\n(\nMyCommand\n \n$command\n)\n:\n \nvoid\n\n    \n{\n\n        \n// do something\n\n    \n}\n\n\n}\n\n\n\n$bus\n-\ndispatch\n(\nnew\n \nMyCommand\n());\n\n\n\n\n\n\nEvent sourcing example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait\n;\n \n\nuse\n \nMsgPhp\\Domain\\Event\\\n{\nDomainEventHandlerInterface\n,\n \nDomainEventInterface\n};\n \n\n\nclass\n \nMyCommand\n \n{\n \n}\n\n\nclass\n \nMyCommandHandler\n\n\n{\n\n    \nuse\n \nEventSourcingCommandHandlerTrait\n;\n\n\n    \npublic\n \nfunction\n \n__invoke\n(\nMyCommand\n \n$command\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\ndoHandle\n(\n$command\n,\n \nfunction\n \n(\nMyEntity\n \n$entity\n)\n:\n \nvoid\n \n{\n\n            \n// do something\n\n        \n});\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \ngetDomainEvent\n(\nMyCommand\n \n$command\n)\n:\n \nDomainEventInterface\n\n    \n{\n\n        \nreturn\n \nnew\n \nMyDomainEvent\n();\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \ngetDomainEventHandler\n(\nMyCommand\n \n$command\n)\n:\n \nDomainEventHandlerInterface\n\n    \n{\n\n        \nreturn\n \nnew\n \nMyEntity\n();\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyDomainEvent\n \nimplements\n \nDomainEventInterface\n \n{\n \n}\n\n\nclass\n \nMyEntity\n \nimplements\n \nDomainEventHandlerInterface\n\n\n{\n\n    \npublic\n \nfunction\n \nhandleEvent\n(\nDomainEventInterface\n \n$event\n)\n:\n \nbool\n\n    \n{\n\n        \nif\n \n(\n$event\n \ninstanceof\n \nMyDomainEvent\n)\n \n{\n\n            \n// do something\n\n\n            \nreturn\n \ntrue\n;\n\n        \n}\n\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n}\n\n\n\n$bus\n-\ndispatch\n(\nnew\n \nMyCommand\n());", 
            "title": "CQRS"
        }, 
        {
            "location": "/message-driven/cqrs/#command-query-responsibility-segregation", 
            "text": "Commands are domain objects and provided per domain layer. They usually follow a  POPO \ndesign. Its purpose is to describe an action to be taken. For commands being messages they can be dispatched using any message bus .", 
            "title": "Command Query Responsibility Segregation"
        }, 
        {
            "location": "/message-driven/cqrs/#command-handlers", 
            "text": "The message bus resolves a command handler, which in turn handles the command. Thus performs the requested action.\nUsually a command handler is designed, but not limited, to handle one specific command message.", 
            "title": "Command handlers"
        }, 
        {
            "location": "/message-driven/cqrs/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/message-driven/cqrs/#msgphpdomaincommandeventsourcingcommandhandlertrait", 
            "text": "Handles a command message by sourcing a domain event.   handle(object $command, callable $onHandled = null): void  If the domain event is handled  $onHandled  will be invoked (if given), receiving the handler as first argument    abstract getDomainEvent(object $command): DomainEventInterface  The  domain event  to be handled    abstract getDomainEventHandler(object $command): DomainEventHandlerInterface  The  domain event handler  handling the domain event", 
            "title": "MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait"
        }, 
        {
            "location": "/message-driven/cqrs/#generic-example", 
            "text": "?php  class   MyCommand   {   }  class   MyCommandHandler  { \n     public   function   __invoke ( MyCommand   $command ) :   void \n     { \n         // do something \n     }  }  $bus - dispatch ( new   MyCommand ());", 
            "title": "Generic example"
        }, 
        {
            "location": "/message-driven/cqrs/#event-sourcing-example", 
            "text": "?php  use   MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait ;   use   MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface ,   DomainEventInterface };   class   MyCommand   {   }  class   MyCommandHandler  { \n     use   EventSourcingCommandHandlerTrait ; \n\n     public   function   __invoke ( MyCommand   $command ) :   void \n     { \n         $this - doHandle ( $command ,   function   ( MyEntity   $entity ) :   void   { \n             // do something \n         }); \n     } \n\n     protected   function   getDomainEvent ( MyCommand   $command ) :   DomainEventInterface \n     { \n         return   new   MyDomainEvent (); \n     } \n\n     protected   function   getDomainEventHandler ( MyCommand   $command ) :   DomainEventHandlerInterface \n     { \n         return   new   MyEntity (); \n     }  }  class   MyDomainEvent   implements   DomainEventInterface   {   }  class   MyEntity   implements   DomainEventHandlerInterface  { \n     public   function   handleEvent ( DomainEventInterface   $event ) :   bool \n     { \n         if   ( $event   instanceof   MyDomainEvent )   { \n             // do something \n\n             return   true ; \n         } \n\n         return   false ; \n     }  }  $bus - dispatch ( new   MyCommand ());", 
            "title": "Event sourcing example"
        }
    ]
}