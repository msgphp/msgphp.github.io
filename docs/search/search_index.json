{
    "docs": [
        {
            "location": "/", 
            "text": "MsgPHP Documentation\n\n\n\n\nMsgPHP\n is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.\n\n\n\n\n\n\nNews\n\n\n\n\n2018-02-18\n Added initial \ninfrastructure\n chapter\n\n\n2018-02-12\n Added \ndomain identities\n chapter\n\n\n2018-01-27\n Added initial \nmessage driven\n chapter\n\n\n2018-01-26\n Added initial \nevent sourcing\n chapter\n\n\n2018-01-25\n Added initial project \ncode conventions\n\n\n2018-01-18\n Initial documentation setup. Work in progress as of today.", 
            "title": "Home"
        }, 
        {
            "location": "/#msgphp-documentation", 
            "text": "MsgPHP  is a project that aims to provide (common) message based domain layers for your application. It has a low development time overhead and avoids being overly opinionated.", 
            "title": "MsgPHP Documentation"
        }, 
        {
            "location": "/#news", 
            "text": "2018-02-18  Added initial  infrastructure  chapter  2018-02-12  Added  domain identities  chapter  2018-01-27  Added initial  message driven  chapter  2018-01-26  Added initial  event sourcing  chapter  2018-01-25  Added initial project  code conventions  2018-01-18  Initial documentation setup. Work in progress as of today.", 
            "title": "News"
        }, 
        {
            "location": "/code-conventions/", 
            "text": "Code conventions\n\n\nA brief description of code conventions this project follows.\n\n\nGeneral principles\n\n\n\n\nNo \nSOLID\n violations, yet be pragmatic\n\n\nReduce \nlines of code\n where possible\n\n\nReduce coupling (\nLoD\n)\n\n\nFavor latest stable PHP7 features\n\n\nChecks must pass (code style, static analysis \n unit tests)\n\n\nAdd PHPDoc / comments if needed for clarification or static analysis\n\n\n\n\nCode style\n\n\n\n\nFollows PSR2 and Symfony style\n\n\nuse\n statements are declared in alpha-order\n\n\nuse\n statements for \nMsgPhp\\\n namespace are grouped by deepest common namespace\n\n\n\n\n?php\n\n\n\n// wrong\n\n\nuse\n \nMsgPhp\\SomeB\n;\n\n\nuse\n \nMsgPhp\\SomeA\n;\n\n\nuse\n \nMsgPhp\\Some\\SomeC\n;\n\n\nuse\n \nOther\\SomeOtherB\n;\n\n\nuse\n \nOther\\Some\\SomeOtherC\n;\n\n\nuse\n \nOther\\SomeOtherA\n;\n\n\n\n// right\n\n\nuse\n \nMsgPhp\\Some\\SomeC\n;\n\n\nuse\n \nMsgPhp\\\n{\nSomeA\n,\n \nSomeB\n};\n\n\nuse\n \nOther\\Some\\SomeOtherC\n;\n\n\nuse\n \nOther\\SomeOtherA\n;\n\n\nuse\n \nOther\\SomeOtherB\n;\n\n\n\n\n\n\nStatic analysis\n\n\n\n\nFollows PHPStan level max\n\n\nExclude / ignore rules are discussed per case/topic\n\n\n\n\nPHP 7.x forward compatibility\n\n\n\n\nIntended object values are type hinted (\n@param object $value\n and \n@return object\n)\n\n\n\n\nUnit tests\n\n\n\n\nAll of the above, \nin general\n, applies to unit tests as well", 
            "title": "Code conventions"
        }, 
        {
            "location": "/code-conventions/#code-conventions", 
            "text": "A brief description of code conventions this project follows.", 
            "title": "Code conventions"
        }, 
        {
            "location": "/code-conventions/#general-principles", 
            "text": "No  SOLID  violations, yet be pragmatic  Reduce  lines of code  where possible  Reduce coupling ( LoD )  Favor latest stable PHP7 features  Checks must pass (code style, static analysis   unit tests)  Add PHPDoc / comments if needed for clarification or static analysis", 
            "title": "General principles"
        }, 
        {
            "location": "/code-conventions/#code-style", 
            "text": "Follows PSR2 and Symfony style  use  statements are declared in alpha-order  use  statements for  MsgPhp\\  namespace are grouped by deepest common namespace   ?php  // wrong  use   MsgPhp\\SomeB ;  use   MsgPhp\\SomeA ;  use   MsgPhp\\Some\\SomeC ;  use   Other\\SomeOtherB ;  use   Other\\Some\\SomeOtherC ;  use   Other\\SomeOtherA ;  // right  use   MsgPhp\\Some\\SomeC ;  use   MsgPhp\\ { SomeA ,   SomeB };  use   Other\\Some\\SomeOtherC ;  use   Other\\SomeOtherA ;  use   Other\\SomeOtherB ;", 
            "title": "Code style"
        }, 
        {
            "location": "/code-conventions/#static-analysis", 
            "text": "Follows PHPStan level max  Exclude / ignore rules are discussed per case/topic", 
            "title": "Static analysis"
        }, 
        {
            "location": "/code-conventions/#php-7x-forward-compatibility", 
            "text": "Intended object values are type hinted ( @param object $value  and  @return object )", 
            "title": "PHP 7.x forward compatibility"
        }, 
        {
            "location": "/code-conventions/#unit-tests", 
            "text": "All of the above,  in general , applies to unit tests as well", 
            "title": "Unit tests"
        }, 
        {
            "location": "/ddd/identifiers/", 
            "text": "Identifiers\n\n\nA domain identifier is a value object and bound to \nMsgPhp\\Domain\\DomainIdInterface\n. Its purpose is to utilize a\nprimitive identifier value.\n\n\nAPI\n\n\nExtends\n\n\n\n\n\\Serializable\n\n\n\\JsonSerializable\n\n\n\n\n\n\nstatic fromValue($value): DomainIdInterface\n\n\nFactorizes a new identifier from its primitive value. Using \nnull\n might imply an empty identifier.\n\n\n\n\nisEmpty(): bool\n\n\nTells if an identifier value is considered empty, thus has no known primitive value.\n\n\n\n\nequals(DomainIdInterface $id): bool\n\n\nTells if an identifier equals another identifier.\n\n\n\n\ntoString(): string\n / \n__toString(): string\n\n\nReturns the identifier its primitive string value. If the identifier is empty (see \nisEmpty()\n) an empty string (\n\"\"\n) \nshould be returned.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\DomainId\n\n\nA first class citizen domain identifier. It leverages \nstring|null\n as underlying data type.\n\n\n\n\n__construct(string $id = null)\n\n\n$id\n: The primitive identifier value. In case of \nnull\n an empty identifier is implied.\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nOtherDomainId\n \nextends\n \nDomainId\n\n\n{\n\n\n}\n\n\n\n$emptyId\n \n=\n \nnew\n \nDomainId\n();\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\n1\n);\n\n\n\n// --- USAGE ---\n\n\n\n$emptyId\n-\nisEmpty\n();\n \n// true\n\n\n$id\n-\nisEmpty\n();\n \n// false\n\n\n\n$emptyId\n-\nequals\n(\n$emptyId\n);\n \n// true\n\n\n$emptyId\n-\nequals\n(\nnew\n \nDomainId\n());\n \n// false\n\n\n$id\n-\nequals\n(\nnew\n \nDomainId\n(\n1\n));\n \n// true\n\n\n$id\n-\nequals\n(\nnew\n \nOtherDomainId\n(\n1\n));\n \n// false due type varying\n\n\n\n$emptyId\n-\ntoString\n();\n \n// \n\n\n(\nstring\n)\n \n$id\n;\n \n// \n1\n\n\n\n$emptyStringId\n \n=\n \nnew\n \nDomainId\n(\n);\n\n\n$emptyStringId\n-\nisEmpty\n()\n \n?\n \nnull\n \n:\n \n$emptyStringId\n-\ntoString\n();\n \n// \n\n\n$emptyId\n-\nisEmpty\n()\n \n?\n \nnull\n \n:\n \n$emptyId\n-\ntoString\n();\n \n// null\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n\n\nDomain identifier based on UUID values.\n\n\n\n\nRead more", 
            "title": "Identifiers"
        }, 
        {
            "location": "/ddd/identifiers/#identifiers", 
            "text": "A domain identifier is a value object and bound to  MsgPhp\\Domain\\DomainIdInterface . Its purpose is to utilize a\nprimitive identifier value.", 
            "title": "Identifiers"
        }, 
        {
            "location": "/ddd/identifiers/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identifiers/#extends", 
            "text": "\\Serializable  \\JsonSerializable", 
            "title": "Extends"
        }, 
        {
            "location": "/ddd/identifiers/#static-fromvaluevalue-domainidinterface", 
            "text": "Factorizes a new identifier from its primitive value. Using  null  might imply an empty identifier.", 
            "title": "static fromValue($value): DomainIdInterface"
        }, 
        {
            "location": "/ddd/identifiers/#isempty-bool", 
            "text": "Tells if an identifier value is considered empty, thus has no known primitive value.", 
            "title": "isEmpty(): bool"
        }, 
        {
            "location": "/ddd/identifiers/#equalsdomainidinterface-id-bool", 
            "text": "Tells if an identifier equals another identifier.", 
            "title": "equals(DomainIdInterface $id): bool"
        }, 
        {
            "location": "/ddd/identifiers/#tostring-string-__tostring-string", 
            "text": "Returns the identifier its primitive string value. If the identifier is empty (see  isEmpty() ) an empty string ( \"\" ) \nshould be returned.", 
            "title": "toString(): string / __toString(): string"
        }, 
        {
            "location": "/ddd/identifiers/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/identifiers/#msgphpdomaindomainid", 
            "text": "A first class citizen domain identifier. It leverages  string|null  as underlying data type.   __construct(string $id = null)  $id : The primitive identifier value. In case of  null  an empty identifier is implied.", 
            "title": "MsgPhp\\Domain\\DomainId"
        }, 
        {
            "location": "/ddd/identifiers/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\DomainId ;  // --- SETUP ---  class   OtherDomainId   extends   DomainId  {  }  $emptyId   =   new   DomainId ();  $id   =   new   DomainId ( 1 );  // --- USAGE ---  $emptyId - isEmpty ();   // true  $id - isEmpty ();   // false  $emptyId - equals ( $emptyId );   // true  $emptyId - equals ( new   DomainId ());   // false  $id - equals ( new   DomainId ( 1 ));   // true  $id - equals ( new   OtherDomainId ( 1 ));   // false due type varying  $emptyId - toString ();   //   ( string )   $id ;   //  1  $emptyStringId   =   new   DomainId ( );  $emptyStringId - isEmpty ()   ?   null   :   $emptyStringId - toString ();   //   $emptyId - isEmpty ()   ?   null   :   $emptyId - toString ();   // null", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/identifiers/#msgphpdomaininfrauuiddomainid", 
            "text": "Domain identifier based on UUID values.   Read more", 
            "title": "MsgPhp\\Domain\\Infra\\Uuid\\DomainId"
        }, 
        {
            "location": "/ddd/identities/", 
            "text": "Identities\n\n\nA domain identity is a composite value (\narray\n) of one or more individual identifier values, indexed by an identifier\nfield name. Its usage is to uniquely identify a domain object, thus qualifying it an entity object.\n\n\nIdentifier values can be of any type; a \ndomain identifier\n, another (foreign) entity object, or any\nprimitive value.\n\n\nMsgPhp\\Domain\\DomainIdentityHelper\n is a domain a helper service. Its purpose is to ease working with the\n\nidentity mapping\n.\n\n\nAPI\n\n\nisIdentifier($value): bool\n\n\nTells if \n$value\n is a known identifier value. This is either a \ndomain identifier\n object or an entity\nobject.\n\n\n\n\nisEmptyIdentifier($value): bool\n\n\nTells if \n$value\n is a known empty identifier value. It returns \ntrue\n if the specified value is either \nnull\n, an empty\n\ndomain identifier\n or an entity object without its identity set.\n\n\n\n\nnormalizeIdentifier($value)\n\n\nReturns the primitive identifier value of \n$value\n. Empty identifier values (see \nisEmptyIdentifier()\n) are normalized\nas \nnull\n, a \ndomain identifier\n as string value and an entity object as normalized identity value.\nA value of any other type is returned as is.\n\n\n\n\ngetIdentifiers(object $object): array\n\n\nReturns the actual identifier values of \n$object\n.\n\n\n\n\ngetIdentifierFieldNames(string $class): array\n\n\nReturns the identifier field names for \n$class\n. Any instance should have an identity composed of these field values.\nSee also \nDomainIdentityMappingInterface::getIdentifierFieldNames()\n.\n\n\n\n\nisIdentity(string $class, $value): bool\n\n\nTells if \n$value\n is a valid identity for type \n$class\n. An identity value is considered valid if an entity object uses\na single identifier value as identity and \n$value\n is a non empty identifier (see \nisEmptyIdentifier()\n).\n\n\nIn case of one or more identifier values, given in the form of an array, its keys must exactly match the available\nidentifier field names and its values must contain no empty identifiers.\n\n\n\n\ntoIdentity(string $class, $value): array\n\n\nReturns a composite identity value for \n$class\n from \n$value\n.\n\n\n\n\ngetIdentity(object $object): array\n\n\nReturns the actual, non empty, identifier values of \n$object\n. Each identifier value is keyed by its corresponding\nidentifier field name. See also \nDomainIdentityMappingInterface::getIdentity()\n.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\\n{\nDomainId\n,\n \nDomainIdentityHelper\n};\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \npublic\n \n$id\n;\n\n\n}\n\n\n\nclass\n \nMyCompositeEntity\n\n\n{\n\n    \npublic\n \n$name\n;\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\n$entity\n-\nid\n \n=\n \nnew\n \nDomainId\n(\n1\n);\n\n\n\n$compositeEntity\n \n=\n \nnew\n \nMyCompositeEntity\n();\n\n\n$compositeEntity\n-\nname\n \n=\n \n...\n;\n\n\n$compositeEntity\n-\nyear\n \n=\n \n...\n;\n\n\n\n$helper\n \n=\n \nnew\n \nDomainIdentityHelper\n(\nnew\n \nDomainIdentityMapping\n([\n\n   \nMyEntity\n::\nclass\n \n=\n \nid\n,\n\n   \nMyCompositeEntity\n::\nclass\n \n=\n \n[\ncar\n,\n \nyear\n],\n\n\n]));\n\n\n\n// --- USAGE ---\n\n\n\n$helper\n-\nisIdentity\n(\n1\n);\n \n// false\n\n\n$helper\n-\nisIdentity\n(\nnew\n \nDomainId\n(\n1\n));\n \n// true\n\n\n$helper\n-\nisIdentity\n(\n$compositeEntity\n);\n \n// true\n\n\n\n$helper\n-\nnormalizeIdentifier\n(\nnew\n \nDomainId\n());\n \n// null\n\n\n$helper\n-\nnormalizeIdentifier\n(\nnew\n \nDomainId\n(\n1\n));\n \n// \n1\n\n\n$helper\n-\nnormalizeIdentifier\n(\n1\n);\n \n// \n1\n\n\n$helper\n-\nnormalizeIdentifier\n(\n$entity\n);\n \n// \n1\n\n\n$helper\n-\nnormalizeIdentifier\n(\n$compositeEntity\n);\n \n// [\ncar\n =\n ..., \nyear\n =\n ....]\n\n\n\n$helper\n-\ngetIdentifiers\n(\n$compositeEntity\n);\n \n// [\ncar\n, \nyear\n]\n\n\n$helper\n-\ngetIdentifiers\n(\n$entity\n);\n \n// [\nid\n]\n\n\n\n$helper\n-\nisIdentity\n(\nMyEntity\n::\nclass\n,\n \n1\n);\n \n// true\n\n\n$helper\n-\nisIdentity\n(\nMyCompositeEntity\n::\nclass\n,\n \n1\n);\n \n// false\n\n\n$helper\n-\nisIdentity\n(\nMyCompositeEntity\n::\nclass\n,\n \n[\ncar\n \n=\n \n...\n]);\n \n// false\n\n\n$helper\n-\nisIdentity\n(\nMyCompositeEntity\n::\nclass\n,\n \n[\ncar\n \n=\n \n...\n,\n \nyear\n \n=\n \n...\n]);\n \n// true\n\n\n\n$helper\n-\ntoIdentity\n(\nMyEntity\n::\nclass\n,\n \n1\n);\n \n// [\nid\n =\n 1]", 
            "title": "Identities"
        }, 
        {
            "location": "/ddd/identities/#identities", 
            "text": "A domain identity is a composite value ( array ) of one or more individual identifier values, indexed by an identifier\nfield name. Its usage is to uniquely identify a domain object, thus qualifying it an entity object.  Identifier values can be of any type; a  domain identifier , another (foreign) entity object, or any\nprimitive value.  MsgPhp\\Domain\\DomainIdentityHelper  is a domain a helper service. Its purpose is to ease working with the identity mapping .", 
            "title": "Identities"
        }, 
        {
            "location": "/ddd/identities/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identities/#isidentifiervalue-bool", 
            "text": "Tells if  $value  is a known identifier value. This is either a  domain identifier  object or an entity\nobject.", 
            "title": "isIdentifier($value): bool"
        }, 
        {
            "location": "/ddd/identities/#isemptyidentifiervalue-bool", 
            "text": "Tells if  $value  is a known empty identifier value. It returns  true  if the specified value is either  null , an empty domain identifier  or an entity object without its identity set.", 
            "title": "isEmptyIdentifier($value): bool"
        }, 
        {
            "location": "/ddd/identities/#normalizeidentifiervalue", 
            "text": "Returns the primitive identifier value of  $value . Empty identifier values (see  isEmptyIdentifier() ) are normalized\nas  null , a  domain identifier  as string value and an entity object as normalized identity value.\nA value of any other type is returned as is.", 
            "title": "normalizeIdentifier($value)"
        }, 
        {
            "location": "/ddd/identities/#getidentifiersobject-object-array", 
            "text": "Returns the actual identifier values of  $object .", 
            "title": "getIdentifiers(object $object): array"
        }, 
        {
            "location": "/ddd/identities/#getidentifierfieldnamesstring-class-array", 
            "text": "Returns the identifier field names for  $class . Any instance should have an identity composed of these field values.\nSee also  DomainIdentityMappingInterface::getIdentifierFieldNames() .", 
            "title": "getIdentifierFieldNames(string $class): array"
        }, 
        {
            "location": "/ddd/identities/#isidentitystring-class-value-bool", 
            "text": "Tells if  $value  is a valid identity for type  $class . An identity value is considered valid if an entity object uses\na single identifier value as identity and  $value  is a non empty identifier (see  isEmptyIdentifier() ).  In case of one or more identifier values, given in the form of an array, its keys must exactly match the available\nidentifier field names and its values must contain no empty identifiers.", 
            "title": "isIdentity(string $class, $value): bool"
        }, 
        {
            "location": "/ddd/identities/#toidentitystring-class-value-array", 
            "text": "Returns a composite identity value for  $class  from  $value .", 
            "title": "toIdentity(string $class, $value): array"
        }, 
        {
            "location": "/ddd/identities/#getidentityobject-object-array", 
            "text": "Returns the actual, non empty, identifier values of  $object . Each identifier value is keyed by its corresponding\nidentifier field name. See also  DomainIdentityMappingInterface::getIdentity() .", 
            "title": "getIdentity(object $object): array"
        }, 
        {
            "location": "/ddd/identities/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\ { DomainId ,   DomainIdentityHelper };  use   MsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping ;  // --- SETUP ---  class   MyEntity  { \n     public   $id ;  }  class   MyCompositeEntity  { \n     public   $name ; \n     public   $year ;  }  $entity   =   new   MyEntity ();  $entity - id   =   new   DomainId ( 1 );  $compositeEntity   =   new   MyCompositeEntity ();  $compositeEntity - name   =   ... ;  $compositeEntity - year   =   ... ;  $helper   =   new   DomainIdentityHelper ( new   DomainIdentityMapping ([ \n    MyEntity :: class   =   id , \n    MyCompositeEntity :: class   =   [ car ,   year ],  ]));  // --- USAGE ---  $helper - isIdentity ( 1 );   // false  $helper - isIdentity ( new   DomainId ( 1 ));   // true  $helper - isIdentity ( $compositeEntity );   // true  $helper - normalizeIdentifier ( new   DomainId ());   // null  $helper - normalizeIdentifier ( new   DomainId ( 1 ));   //  1  $helper - normalizeIdentifier ( 1 );   //  1  $helper - normalizeIdentifier ( $entity );   //  1  $helper - normalizeIdentifier ( $compositeEntity );   // [ car  =  ...,  year  =  ....]  $helper - getIdentifiers ( $compositeEntity );   // [ car ,  year ]  $helper - getIdentifiers ( $entity );   // [ id ]  $helper - isIdentity ( MyEntity :: class ,   1 );   // true  $helper - isIdentity ( MyCompositeEntity :: class ,   1 );   // false  $helper - isIdentity ( MyCompositeEntity :: class ,   [ car   =   ... ]);   // false  $helper - isIdentity ( MyCompositeEntity :: class ,   [ car   =   ... ,   year   =   ... ]);   // true  $helper - toIdentity ( MyEntity :: class ,   1 );   // [ id  =  1]", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/identity-mapping/", 
            "text": "Identity mapping\n\n\nAn identity mapping is a domain service and is bound to \nMsgPhp\\Domain\\DomainIdentityMappingInterface\n. It tells about\nthe identifier metadata for a known domain object.\n\n\nAPI\n\n\ngetIdentifierFieldNames(string $class): array\n\n\nReturns the identifier field names for \n$class\n. Any instance should have an identity composed of these field values.\n\n\n\n\ngetIdentity(object $object): array\n\n\nReturns the actual, non empty, identifier values of \n$object\n. Each identifier value is keyed by its corresponding\nidentifier field name.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping\n\n\nIdentity mapping based on a known in-memory mapping.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \npublic\n \n$id\n;\n\n\n}\n\n\n\nclass\n \nMyCompositeEntity\n\n\n{\n\n    \npublic\n \n$name\n;\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\n$entity\n-\nid\n \n=\n \n...\n;\n\n\n\n$compositeEntity\n \n=\n \nnew\n \nMyCompositeEntity\n();\n\n\n$compositeEntity\n-\nname\n \n=\n \n...\n;\n\n\n$compositeEntity\n-\nyear\n \n=\n \n...\n;\n\n\n\n$mapping\n \n=\n \nnew\n \nDomainIdentityMapping\n([\n\n    \nMyEntity\n::\nclass\n \n=\n \nid\n,\n\n    \nMyCompositeEntity\n::\nclass\n \n=\n \n[\ncar\n,\n \nyear\n],\n\n\n]);\n\n\n\n// --- USAGE ---\n\n\n\n$mapping\n-\ngetIdentifierFieldNames\n(\nMyEntity\n::\nclass\n);\n \n// [\nid\n]\n\n\n$mapping\n-\ngetIdentifierFieldNames\n(\nMyCompositeEntity\n::\nclass\n);\n \n// [\ncar\n, \nyear\n]\n\n\n\n$mapping\n-\ngetIdentity\n(\n$entity\n);\n \n// [\nid\n =\n ...]\n\n\n$mapping\n-\ngetIdentity\n(\n$entity\n);\n \n// [\ncar\n =\n ..., \nyear\n =\n ...]\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n\n\nIdentity mapping based on Doctrine's identity map.\n\n\n\n\nRead more", 
            "title": "Identity mapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#identity-mapping", 
            "text": "An identity mapping is a domain service and is bound to  MsgPhp\\Domain\\DomainIdentityMappingInterface . It tells about\nthe identifier metadata for a known domain object.", 
            "title": "Identity mapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/identity-mapping/#getidentifierfieldnamesstring-class-array", 
            "text": "Returns the identifier field names for  $class . Any instance should have an identity composed of these field values.", 
            "title": "getIdentifierFieldNames(string $class): array"
        }, 
        {
            "location": "/ddd/identity-mapping/#getidentityobject-object-array", 
            "text": "Returns the actual, non empty, identifier values of  $object . Each identifier value is keyed by its corresponding\nidentifier field name.", 
            "title": "getIdentity(object $object): array"
        }, 
        {
            "location": "/ddd/identity-mapping/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/identity-mapping/#msgphpdomaininfrainmemorydomainidentitymapping", 
            "text": "Identity mapping based on a known in-memory mapping.", 
            "title": "MsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping"
        }, 
        {
            "location": "/ddd/identity-mapping/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\InMemory\\DomainIdentityMapping ;  // --- SETUP ---  class   MyEntity  { \n     public   $id ;  }  class   MyCompositeEntity  { \n     public   $name ; \n     public   $year ;  }  $entity   =   new   MyEntity ();  $entity - id   =   ... ;  $compositeEntity   =   new   MyCompositeEntity ();  $compositeEntity - name   =   ... ;  $compositeEntity - year   =   ... ;  $mapping   =   new   DomainIdentityMapping ([ \n     MyEntity :: class   =   id , \n     MyCompositeEntity :: class   =   [ car ,   year ],  ]);  // --- USAGE ---  $mapping - getIdentifierFieldNames ( MyEntity :: class );   // [ id ]  $mapping - getIdentifierFieldNames ( MyCompositeEntity :: class );   // [ car ,  year ]  $mapping - getIdentity ( $entity );   // [ id  =  ...]  $mapping - getIdentity ( $entity );   // [ car  =  ...,  year  =  ...]", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/identity-mapping/#msgphpdomaininfradoctrinedomainidentitymapping", 
            "text": "Identity mapping based on Doctrine's identity map.   Read more", 
            "title": "MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping"
        }, 
        {
            "location": "/ddd/collections/", 
            "text": "Collections\n\n\nA domain collection is a traversable and bound to \nMsgPhp\\Domain\\DomainCollectionInterface\n. Its purpose is to utilize\na primitive traversable value. It may hold any type of element values.\n\n\nAPI\n\n\nExtends\n\n\n\n\n\\Countable\n\n\n\\IteratorAggregate\n\n\n\n\n\n\nstatic fromValue(?iterable $value): DomainCollectionInterface\n\n\nFactorizes a new collection from its primitive value. Using \nnull\n implies an empty collection.\n\n\n\n\nisEmpty(): bool\n\n\nTells if a collection is considered empty, i.e. contains zero elements.\n\n\n\n\ncontains($element): bool\n\n\nTells if a collection contains the given element. Comparison is done strictly.\n\n\n\n\ncontainsKey($key): bool\n\n\nTells if a collection contains an element at the given key/index.\n\n\n\n\nfirst()\n\n\nReturns the first element or \nfalse\n if the collection is empty.\n\n\n\n\nlast()\n\n\nReturns the last element or \nfalse\n if the collection is empty.\n\n\n\n\nget($key)\n\n\nReturns the element at the given key/index or \nnull\n if the collection is empty.\n\n\n\n\nfilter(callable $filter): DomainCollectionInterface\n\n\nReturns a \nnew\n collection containing only elements for which \n$filter\n returns \ntrue\n. Keys are preserved.\n\n\n\n\nslice(int $offset, int $limit = 0): DomainCollectionInterface\n\n\nReturns a \nnew\n collection containing a slice of elements. By default the slice has no limit, implied by integer \n0\n.\nKeys are preserved.\n\n\n\n\nmap(callable $mapper): array\n\n\nReturns a map with each collection element as returned by \n$mapper\n.s\n\n\nImplementations\n\n\nMsgPhp\\Domain\\DomainCollection\n\n\nA first class citizen domain collection. It leverages \niterable\n as underlying data type. Lazy support is built-in for\ntype \n\\Traversable\n. Meaning the minimal no. of elements are traversed, i.e. until the first element in case of\n\nisEmpty()\n. Note type \n\\Generator\n can only start traversing once.\n\n\n\n\n__construct(iterable $elements)\n\n\n$elements\n: The elements this collection contains\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\n\n// --- SETUP ---\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n([\na\n,\n \nb\n,\n \nc\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \nkey\n \n=\n \nvalue\n]);\n\n\n\n// --- USAGE ---\n\n\n\n$collection\n-\nisEmpty\n();\n \n// false\n\n\ncount\n(\n$collection\n);\n \n// int(7)\n\n\n\n$collection\n-\ncontains\n(\n2\n);\n \n// true\n\n\n$collection\n-\ncontains\n(\n2\n);\n \n// false\n\n\n\n$collection\n-\ncontainsKey\n(\n0\n);\n \n// true\n\n\n$collection\n-\ncontainsKey\n(\n0\n);\n \n// true\n\n\n\n$collection\n-\nfirst\n();\n \n// \na\n\n\n$collection\n-\nlast\n();\n \n// int(3)\n\n\n\n$collection\n-\nget\n(\n0\n);\n \n// \na\n\n\n$collection\n-\nget\n(\n3\n);\n \n// int(1)\n\n\n$collection\n-\nget\n(\nkey\n);\n \n// \nvalue\n\n\n\n$onlyInts\n \n=\n \n$collection\n-\nfilter\n(\nfunction\n \n(\n$value\n)\n:\n \nbool\n \n{\n\n    \nreturn\n \nis_int\n(\n$value\n);\n\n\n});\n\n\n\n$firstTwoInts\n \n=\n \n$onlyInts\n-\nslice\n(\n0\n,\n \n2\n);\n\n\n\n$firstTwoIntsPlussed\n \n=\n \n$firstTwoInts\n-\nmap\n(\nfunction\n \n(\nint\n \n$value\n)\n:\n \nint\n \n{\n\n    \nreturn\n \n++\n$value\n;\n\n\n});\n \n// [2, 4]\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n\n\nDomain collection based on \nDoctrine Collections\n.\n\n\n\n\nRead more", 
            "title": "Collections"
        }, 
        {
            "location": "/ddd/collections/#collections", 
            "text": "A domain collection is a traversable and bound to  MsgPhp\\Domain\\DomainCollectionInterface . Its purpose is to utilize\na primitive traversable value. It may hold any type of element values.", 
            "title": "Collections"
        }, 
        {
            "location": "/ddd/collections/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/collections/#extends", 
            "text": "\\Countable  \\IteratorAggregate", 
            "title": "Extends"
        }, 
        {
            "location": "/ddd/collections/#static-fromvalueiterable-value-domaincollectioninterface", 
            "text": "Factorizes a new collection from its primitive value. Using  null  implies an empty collection.", 
            "title": "static fromValue(?iterable $value): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#isempty-bool", 
            "text": "Tells if a collection is considered empty, i.e. contains zero elements.", 
            "title": "isEmpty(): bool"
        }, 
        {
            "location": "/ddd/collections/#containselement-bool", 
            "text": "Tells if a collection contains the given element. Comparison is done strictly.", 
            "title": "contains($element): bool"
        }, 
        {
            "location": "/ddd/collections/#containskeykey-bool", 
            "text": "Tells if a collection contains an element at the given key/index.", 
            "title": "containsKey($key): bool"
        }, 
        {
            "location": "/ddd/collections/#first", 
            "text": "Returns the first element or  false  if the collection is empty.", 
            "title": "first()"
        }, 
        {
            "location": "/ddd/collections/#last", 
            "text": "Returns the last element or  false  if the collection is empty.", 
            "title": "last()"
        }, 
        {
            "location": "/ddd/collections/#getkey", 
            "text": "Returns the element at the given key/index or  null  if the collection is empty.", 
            "title": "get($key)"
        }, 
        {
            "location": "/ddd/collections/#filtercallable-filter-domaincollectioninterface", 
            "text": "Returns a  new  collection containing only elements for which  $filter  returns  true . Keys are preserved.", 
            "title": "filter(callable $filter): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#sliceint-offset-int-limit-0-domaincollectioninterface", 
            "text": "Returns a  new  collection containing a slice of elements. By default the slice has no limit, implied by integer  0 .\nKeys are preserved.", 
            "title": "slice(int $offset, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/collections/#mapcallable-mapper-array", 
            "text": "Returns a map with each collection element as returned by  $mapper .s", 
            "title": "map(callable $mapper): array"
        }, 
        {
            "location": "/ddd/collections/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/collections/#msgphpdomaindomaincollection", 
            "text": "A first class citizen domain collection. It leverages  iterable  as underlying data type. Lazy support is built-in for\ntype  \\Traversable . Meaning the minimal no. of elements are traversed, i.e. until the first element in case of isEmpty() . Note type  \\Generator  can only start traversing once.   __construct(iterable $elements)  $elements : The elements this collection contains", 
            "title": "MsgPhp\\Domain\\DomainCollection"
        }, 
        {
            "location": "/ddd/collections/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\DomainCollection ;  // --- SETUP ---  $collection   =   new   DomainCollection ([ a ,   b ,   c ,   1 ,   2 ,   3 ,   key   =   value ]);  // --- USAGE ---  $collection - isEmpty ();   // false  count ( $collection );   // int(7)  $collection - contains ( 2 );   // true  $collection - contains ( 2 );   // false  $collection - containsKey ( 0 );   // true  $collection - containsKey ( 0 );   // true  $collection - first ();   //  a  $collection - last ();   // int(3)  $collection - get ( 0 );   //  a  $collection - get ( 3 );   // int(1)  $collection - get ( key );   //  value  $onlyInts   =   $collection - filter ( function   ( $value ) :   bool   { \n     return   is_int ( $value );  });  $firstTwoInts   =   $onlyInts - slice ( 0 ,   2 );  $firstTwoIntsPlussed   =   $firstTwoInts - map ( function   ( int   $value ) :   int   { \n     return   ++ $value ;  });   // [2, 4]", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/collections/#msgphpdomaininfradoctrinedomaincollection", 
            "text": "Domain collection based on  Doctrine Collections .   Read more", 
            "title": "MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection"
        }, 
        {
            "location": "/ddd/factory/object/", 
            "text": "Object factory\n\n\nA domain object factory is bound to \nMsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface\n. Its purpose is to initialize\nany domain object based on a class name and context.\n\n\nAPI\n\n\ncreate(string $class, array $context = []): object\n\n\nFactorizes a new domain object by class name. Optionally a context can be provided for the factory to act upon.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\ChainObjectFactory\n\n\nHolds many object factories. It returns a domain object from the first supporting factory.\n\n\nMsgPhp\\Domain\\Factory\\ClassMappingObjectFactory\n\n\nDecorates any object factory. It resolves the actual class name to use from a provided mapping or, if unknown, it uses\nthe original provided class name.\n\n\nMsgPhp\\Domain\\Factory\\DomainObjectFactory\n\n\nGeneric object factory. Initializes the given class name by reading its constructor arguments. Argument values are\nresolved from the provided context. By convention a camel cased argument name (e.g. \n$myArgument\n) matches a\ncorresponding underscored context key (e.g. \n['my_argument' =\n 'value']\n). If the context key is numeric its value will\nbe provided to a corresponding argument at index N. In case an exact match exists (e.g. \n['myArgument' =\n 'value']\n) it\nwill always be used instead.\n\n\nAny sub class of \nMsgPhp\\Domain\\DomainIdInterface\n or \nMsgPhp\\Domain\\DomainCollectionInterface\n will be initialized\nfrom \n$class::fromValue()\n by default, otherwise initialization happens regulary (i.e. \nnew $class(...$args)\n).\n\n\nNested objects (e.g. \nMyObject $myArgument\n) might be provided as nested context (thus array). The current factory will\nbe used to initialize the object as argument value. Another (decorating) factory can be set using \n\nDomainObjectFactory::setNestedFactory(DomainObjectFactoryInterface $factory)\n.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainObjectFactory\n;\n\n\n\nclass\n \nSome\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nint\n \n$a\n,\n \n?\nint\n \n$b\n,\n \n?\nint\n \n$c\n)\n\n    \n{\n\n    \n}\n\n\n}\n\n\n\nclass\n \nSubject\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nstring\n \n$argument\n,\n \nSome\n \n$some\n,\n \nSubject\n \n$otherSubject\n \n=\n \nnull\n)\n\n    \n{\n\n    \n}\n\n\n}\n\n\n\n$factory\n \n=\n \nnew\n \nDomainObjectFactory\n();\n\n\n\n/** @var Subject $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nSubject\n::\nclass\n,\n \n[\n\n    \nargument\n \n=\n  \nvalue\n,\n\n    \nsome\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \nother_subject\n \n=\n \n[\n\n        \nargument\n \n=\n \nother_value\n,\n\n        \nsome\n \n=\n \n[\na\n \n=\n \n1\n],\n\n    \n],\n\n\n]);\n\n\n\n\n\n\nChain example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\ChainObjectFactory\n;\n\n\n\n$firstFactory\n \n=\n \n...\n;\n\n\n$secondFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nChainObjectFactory\n([\n$firstFactory\n,\n \n$secondFactory\n]);\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nSomeObject\n::\nclass\n,\n \n[\nkey\n \n=\n \nvalue\n]);\n\n\n\n\n\n\nClass mapping example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\ClassMappingObjectFactory\n;\n\n\n\ninterface\n \nKnownInterface\n\n\n{\n\n\n}\n\n\n\nclass\n \nSubject\n \nimplements\n \nKnownInterface\n\n\n{\n\n\n}\n\n\n\n$realFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nClassMappingObjectFactory\n([\nKnownInterface\n::\nclass\n \n=\n \nSubject\n::\nclass\n],\n \n$realFactory\n);\n\n\n\n/** @var Subject $object */\n\n\n$object\n \n=\n \n$factory\n-\ncreate\n(\nKnownInterface\n::\nclass\n);", 
            "title": "Object factory"
        }, 
        {
            "location": "/ddd/factory/object/#object-factory", 
            "text": "A domain object factory is bound to  MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface . Its purpose is to initialize\nany domain object based on a class name and context.", 
            "title": "Object factory"
        }, 
        {
            "location": "/ddd/factory/object/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/factory/object/#createstring-class-array-context-object", 
            "text": "Factorizes a new domain object by class name. Optionally a context can be provided for the factory to act upon.", 
            "title": "create(string $class, array $context = []): object"
        }, 
        {
            "location": "/ddd/factory/object/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactorychainobjectfactory", 
            "text": "Holds many object factories. It returns a domain object from the first supporting factory.", 
            "title": "MsgPhp\\Domain\\Factory\\ChainObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactoryclassmappingobjectfactory", 
            "text": "Decorates any object factory. It resolves the actual class name to use from a provided mapping or, if unknown, it uses\nthe original provided class name.", 
            "title": "MsgPhp\\Domain\\Factory\\ClassMappingObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#msgphpdomainfactorydomainobjectfactory", 
            "text": "Generic object factory. Initializes the given class name by reading its constructor arguments. Argument values are\nresolved from the provided context. By convention a camel cased argument name (e.g.  $myArgument ) matches a\ncorresponding underscored context key (e.g.  ['my_argument' =  'value'] ). If the context key is numeric its value will\nbe provided to a corresponding argument at index N. In case an exact match exists (e.g.  ['myArgument' =  'value'] ) it\nwill always be used instead.  Any sub class of  MsgPhp\\Domain\\DomainIdInterface  or  MsgPhp\\Domain\\DomainCollectionInterface  will be initialized\nfrom  $class::fromValue()  by default, otherwise initialization happens regulary (i.e.  new $class(...$args) ).  Nested objects (e.g.  MyObject $myArgument ) might be provided as nested context (thus array). The current factory will\nbe used to initialize the object as argument value. Another (decorating) factory can be set using  DomainObjectFactory::setNestedFactory(DomainObjectFactoryInterface $factory) .", 
            "title": "MsgPhp\\Domain\\Factory\\DomainObjectFactory"
        }, 
        {
            "location": "/ddd/factory/object/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainObjectFactory ;  class   Some  { \n     public   function   __construct ( int   $a ,   ? int   $b ,   ? int   $c ) \n     { \n     }  }  class   Subject  { \n     public   function   __construct ( string   $argument ,   Some   $some ,   Subject   $otherSubject   =   null ) \n     { \n     }  }  $factory   =   new   DomainObjectFactory ();  /** @var Subject $object */  $object   =   $factory - create ( Subject :: class ,   [ \n     argument   =    value , \n     some   =   [ 1 ,   2 ,   3 ], \n     other_subject   =   [ \n         argument   =   other_value , \n         some   =   [ a   =   1 ], \n     ],  ]);", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/object/#chain-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ChainObjectFactory ;  $firstFactory   =   ... ;  $secondFactory   =   ... ;  $factory   =   new   ChainObjectFactory ([ $firstFactory ,   $secondFactory ]);  $object   =   $factory - create ( SomeObject :: class ,   [ key   =   value ]);", 
            "title": "Chain example"
        }, 
        {
            "location": "/ddd/factory/object/#class-mapping-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\ClassMappingObjectFactory ;  interface   KnownInterface  {  }  class   Subject   implements   KnownInterface  {  }  $realFactory   =   ... ;  $factory   =   new   ClassMappingObjectFactory ([ KnownInterface :: class   =   Subject :: class ],   $realFactory );  /** @var Subject $object */  $object   =   $factory - create ( KnownInterface :: class );", 
            "title": "Class mapping example"
        }, 
        {
            "location": "/ddd/factory/entity-aware/", 
            "text": "Entity aware factory\n\n\nAn entity aware factory is a domain object factory, bound to \nMsgPhp\\Domain\\Factory\\EntityAwareFactoryInterface\n.\nBesides initializing any domain object via \ncreate()\n it's also capable to initialize an entity identifier / reference\nobject.\n\n\nAPI\n\n\ncreate(string $class, array $context = []): object\n\n\nInherited from \nMsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface::create()\n.\n\n\n\n\nreference(string $class, $id): object\n\n\nReturns a reference for a known existing entity object.\n\n\n\n\nidentify(string $class, $value): DomainIdInterface\n\n\nReturns an identifier for the given entity class from a known primitive value.\n\n\n\n\nnextIdentifier(string $class): DomainIdInterface\n\n\nReturns the next identifier for the given entity class. Depending on the implementation its value might be considered\nempty if it's not capable to calculate one upfront.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\EntityAwareFactory\n\n\nGeneric entity factory and decorates any object factory. Additionally it must be provided with an entity to identifier\nclass mapping.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\EntityAwareFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n \nas\n \nDomainUuid\n;\n\n\n\n$realFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nEntityAwareFactory\n(\n$realFactory\n,\n \n[\n\n    \nMyEntity\n::\nclass\n \n=\n \nDomainId\n::\nclass\n,\n\n    \nMyOtherEntity\n::\nclass\n \n=\n \nDomainUuid\n::\nclass\n,\n\n\n]);\n\n\n\n/** @var DomainId $entityId */\n\n\n$entityId\n \n=\n \n$factory\n-\nidentify\n(\nMyEntity\n::\nclass\n,\n \n1\n);\n\n\n$factory\n-\nnextIdentifier\n(\nMyEntity\n::\nclass\n)\n-\nisEmpty\n();\n \n// true\n\n\n\n/** @var DomainUuid $entityId */\n\n\n$entityId\n \n=\n \n$factory\n-\nidentify\n(\nMyOtherEntity\n::\nclass\n,\n \ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n$factory\n-\nnextIdentifier\n(\nMyOtherEntity\n::\nclass\n)\n-\nisEmpty\n();\n \n// false\n\n\n\n\n\n\nEntity reference example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\EntityAwareFactory\n;\n\n\n\nclass\n \nMyEntity\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\n$id\n)\n\n    \n{\n\n    \n}\n\n\n}\n\n\n\n$realFactory\n \n=\n \n...\n;\n\n\n\n$factory\n \n=\n \nnew\n \nEntityAwareFactory\n(\n$realFactory\n,\n \n[],\n \nfunction\n \n(\nstring\n \n$class\n,\n \n$id\n)\n \n{\n\n    \nreturn\n \nnew\n \n$class\n(\n$id\n);\n\n\n});\n\n\n\n/** @var MyEntity $ref */\n\n\n$ref\n \n=\n \n$factory\n-\nreference\n(\nMyEntity\n::\nclass\n,\n \n1\n);", 
            "title": "Entity aware factory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#entity-aware-factory", 
            "text": "An entity aware factory is a domain object factory, bound to  MsgPhp\\Domain\\Factory\\EntityAwareFactoryInterface .\nBesides initializing any domain object via  create()  it's also capable to initialize an entity identifier / reference\nobject.", 
            "title": "Entity aware factory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#createstring-class-array-context-object", 
            "text": "Inherited from  MsgPhp\\Domain\\Factory\\DomainObjectFactoryInterface::create() .", 
            "title": "create(string $class, array $context = []): object"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#referencestring-class-id-object", 
            "text": "Returns a reference for a known existing entity object.", 
            "title": "reference(string $class, $id): object"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#identifystring-class-value-domainidinterface", 
            "text": "Returns an identifier for the given entity class from a known primitive value.", 
            "title": "identify(string $class, $value): DomainIdInterface"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#nextidentifierstring-class-domainidinterface", 
            "text": "Returns the next identifier for the given entity class. Depending on the implementation its value might be considered\nempty if it's not capable to calculate one upfront.", 
            "title": "nextIdentifier(string $class): DomainIdInterface"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#msgphpdomainfactoryentityawarefactory", 
            "text": "Generic entity factory and decorates any object factory. Additionally it must be provided with an entity to identifier\nclass mapping.", 
            "title": "MsgPhp\\Domain\\Factory\\EntityAwareFactory"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\EntityAwareFactory ;  use   MsgPhp\\Domain\\DomainId ;  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId   as   DomainUuid ;  $realFactory   =   ... ;  $factory   =   new   EntityAwareFactory ( $realFactory ,   [ \n     MyEntity :: class   =   DomainId :: class , \n     MyOtherEntity :: class   =   DomainUuid :: class ,  ]);  /** @var DomainId $entityId */  $entityId   =   $factory - identify ( MyEntity :: class ,   1 );  $factory - nextIdentifier ( MyEntity :: class ) - isEmpty ();   // true  /** @var DomainUuid $entityId */  $entityId   =   $factory - identify ( MyOtherEntity :: class ,   cf3d2f85-6c86-44d1-8634-af51c91a9a74 );  $factory - nextIdentifier ( MyOtherEntity :: class ) - isEmpty ();   // false", 
            "title": "Basic example"
        }, 
        {
            "location": "/ddd/factory/entity-aware/#entity-reference-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\EntityAwareFactory ;  class   MyEntity  { \n     public   function   __construct ( $id ) \n     { \n     }  }  $realFactory   =   ... ;  $factory   =   new   EntityAwareFactory ( $realFactory ,   [],   function   ( string   $class ,   $id )   { \n     return   new   $class ( $id );  });  /** @var MyEntity $ref */  $ref   =   $factory - reference ( MyEntity :: class ,   1 );", 
            "title": "Entity reference example"
        }, 
        {
            "location": "/ddd/factory/static/", 
            "text": "Static factory\n\n\nA static factory is a utility class, it cannot be initialized as a new instance using \nnew ...();\n. Its purpose is to\nfactorize a known implementation for a given class.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Factory\\DomainIdFactory\n\n\nFactorize an \nidentifier\n from any primitive value.\n\n\n\n\nstatic create($value): DomainIdInterface\n\n\n\n\nMsgPhp\\Domain\\Factory\\DomainCollectionFactory\n\n\nFactorizes a \ncollection\n from any primitive iterable value.\n\n\n\n\nstatic create(?iterable $value): DomainCollectionInterface\n\n\n\n\nIdentifier factory example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainIdFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainId\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n \nas\n \nDomainUuid\n;\n\n\n\n/** @var DomainId $id */\n\n\n$id\n \n=\n \nDomainIdFactory\n::\ncreate\n(\n1\n);\n\n\n\n/** @var DomainUuid $uuid */\n\n\n$uuid\n \n=\n \nDomainIdFactory\n::\ncreate\n(\ncf3d2f85-6c86-44d1-8634-af51c91a9a74\n);\n\n\n\n\n\n\nCollection factory example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Factory\\DomainCollectionFactory\n;\n\n\nuse\n \nMsgPhp\\Domain\\DomainCollection\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n \nas\n \nDoctrineDomainCollection\n;\n\n\nuse\n \nDoctrine\\Common\\Collections\\ArrayCollection\n;\n\n\n\n/** @var DomainCollection $collection */\n\n\n$collection\n \n=\n \nDomainCollectionFactory\n::\ncreate\n([\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\n/** @var DoctrineDomainCollection $doctrineCollection */\n\n\n$doctrineCollection\n \n=\n \nDomainCollectionFactory\n::\ncreate\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));", 
            "title": "Static factory"
        }, 
        {
            "location": "/ddd/factory/static/#static-factory", 
            "text": "A static factory is a utility class, it cannot be initialized as a new instance using  new ...(); . Its purpose is to\nfactorize a known implementation for a given class.", 
            "title": "Static factory"
        }, 
        {
            "location": "/ddd/factory/static/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/factory/static/#msgphpdomainfactorydomainidfactory", 
            "text": "Factorize an  identifier  from any primitive value.   static create($value): DomainIdInterface", 
            "title": "MsgPhp\\Domain\\Factory\\DomainIdFactory"
        }, 
        {
            "location": "/ddd/factory/static/#msgphpdomainfactorydomaincollectionfactory", 
            "text": "Factorizes a  collection  from any primitive iterable value.   static create(?iterable $value): DomainCollectionInterface", 
            "title": "MsgPhp\\Domain\\Factory\\DomainCollectionFactory"
        }, 
        {
            "location": "/ddd/factory/static/#identifier-factory-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainIdFactory ;  use   MsgPhp\\Domain\\DomainId ;  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId   as   DomainUuid ;  /** @var DomainId $id */  $id   =   DomainIdFactory :: create ( 1 );  /** @var DomainUuid $uuid */  $uuid   =   DomainIdFactory :: create ( cf3d2f85-6c86-44d1-8634-af51c91a9a74 );", 
            "title": "Identifier factory example"
        }, 
        {
            "location": "/ddd/factory/static/#collection-factory-example", 
            "text": "?php  use   MsgPhp\\Domain\\Factory\\DomainCollectionFactory ;  use   MsgPhp\\Domain\\DomainCollection ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection   as   DoctrineDomainCollection ;  use   Doctrine\\Common\\Collections\\ArrayCollection ;  /** @var DomainCollection $collection */  $collection   =   DomainCollectionFactory :: create ([ 1 ,   2 ,   3 ]);  /** @var DoctrineDomainCollection $doctrineCollection */  $doctrineCollection   =   DomainCollectionFactory :: create ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));", 
            "title": "Collection factory example"
        }, 
        {
            "location": "/ddd/repositories/", 
            "text": "Repositories\n\n\nA repository is not interface bound by default. Instead you can leverage various trait objects to rapidly create one, \ndepending on the type of infrastructure needed. By design they follow the same API although there might be subtle\ndifferences per implementation.\n\n\nNote default (interface bound) repositories are provided per domain layer.\n\n\nAPI\n\n\n\n\nExposed \nprivate\n as a trait. You can decide to \nchange method visibility\n\non a per case basis.\n\n\n\n\ndoFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface\n\n\nFind all entities available.\n\n\n\n\ndoFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface\n\n\nFind all entities matching all specified fields. Supported field values should be \nnull\n, \nscalar\n, \narray\n (one of)\nand \nobject\n (foreign entity or \nidentifier\n).\n\n\n\n\ndoFind($id): object\n\n\nFind a single entity by its identity. Supported identity values should be \nscalar\n, \narray\n (composite \nidentity\n)\nand \nobject\n (foreign entity or \nidentifier\n).\n\n\n\n\ndoFindByFields(array $fields): object\n\n\nFind the first entity matching all specified fields. See \ndoFindAllByFields()\n for supported field values.\n\n\n\n\ndoExists($id): bool\n\n\nVerify if an entity exists by its identity. See \ndoFind()\n for supported identity values.\n\n\n\n\ndoExistsByFields(array $fields): bool\n\n\nVerify if an entity exists matching all specified fields. See \ndoFindAllByFields()\n for supported field values.\n\n\n\n\ndoSave(object $entity): void\n\n\nPersist an entity in the identity map. The entity will be available on any subsequent query.\n\n\n\n\ndoDelete(object $entity): void\n\n\nRemove an entity from the identity map. The entity will be unavailable on any subsequent query.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Infra\\InMemory\\DomainEntityRepositoryTrait\n\n\nIn-memory persistence\n\n\n\n\n\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n\n\nDoctrine persistence\n\n\nRequires \ndoctrine/orm\n\n\n\n\n\n\n\n\nGeneric Doctrine repository example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait\n;\n\n\nuse\n \nDoctrine\\ORM\\EntityManagerInterface\n;\n\n\n\nclass\n \nMyGenericRepository\n\n\n{\n\n    \nuse\n \nDomainEntityRepositoryTrait\n \n{\n\n        \ndoFind\n \nas\n \npublic\n \nfind\n;\n\n    \n}\n\n\n}\n\n\n\n/** @var EntityManagerInterface $em */\n\n\n$em\n \n=\n \n...\n;\n\n\n\n$repository\n \n=\n \nnew\n \nMyGenericRepository\n(\nMyEntity\n::\nclass\n,\n \n$em\n);\n \n\n\n/** @var MyEntity $entity */\n\n\n$entity\n \n=\n \n$repository\n-\nfind\n(\n1\n);", 
            "title": "Repositories"
        }, 
        {
            "location": "/ddd/repositories/#repositories", 
            "text": "A repository is not interface bound by default. Instead you can leverage various trait objects to rapidly create one, \ndepending on the type of infrastructure needed. By design they follow the same API although there might be subtle\ndifferences per implementation.  Note default (interface bound) repositories are provided per domain layer.", 
            "title": "Repositories"
        }, 
        {
            "location": "/ddd/repositories/#api", 
            "text": "Exposed  private  as a trait. You can decide to  change method visibility \non a per case basis.", 
            "title": "API"
        }, 
        {
            "location": "/ddd/repositories/#dofindallint-offset-0-int-limit-0-domaincollectioninterface", 
            "text": "Find all entities available.", 
            "title": "doFindAll(int $offset = 0, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/repositories/#dofindallbyfieldsarray-fields-int-offset-0-int-limit-0-domaincollectioninterface", 
            "text": "Find all entities matching all specified fields. Supported field values should be  null ,  scalar ,  array  (one of)\nand  object  (foreign entity or  identifier ).", 
            "title": "doFindAllByFields(array $fields, int $offset = 0, int $limit = 0): DomainCollectionInterface"
        }, 
        {
            "location": "/ddd/repositories/#dofindid-object", 
            "text": "Find a single entity by its identity. Supported identity values should be  scalar ,  array  (composite  identity )\nand  object  (foreign entity or  identifier ).", 
            "title": "doFind($id): object"
        }, 
        {
            "location": "/ddd/repositories/#dofindbyfieldsarray-fields-object", 
            "text": "Find the first entity matching all specified fields. See  doFindAllByFields()  for supported field values.", 
            "title": "doFindByFields(array $fields): object"
        }, 
        {
            "location": "/ddd/repositories/#doexistsid-bool", 
            "text": "Verify if an entity exists by its identity. See  doFind()  for supported identity values.", 
            "title": "doExists($id): bool"
        }, 
        {
            "location": "/ddd/repositories/#doexistsbyfieldsarray-fields-bool", 
            "text": "Verify if an entity exists matching all specified fields. See  doFindAllByFields()  for supported field values.", 
            "title": "doExistsByFields(array $fields): bool"
        }, 
        {
            "location": "/ddd/repositories/#dosaveobject-entity-void", 
            "text": "Persist an entity in the identity map. The entity will be available on any subsequent query.", 
            "title": "doSave(object $entity): void"
        }, 
        {
            "location": "/ddd/repositories/#dodeleteobject-entity-void", 
            "text": "Remove an entity from the identity map. The entity will be unavailable on any subsequent query.", 
            "title": "doDelete(object $entity): void"
        }, 
        {
            "location": "/ddd/repositories/#implementations", 
            "text": "MsgPhp\\Domain\\Infra\\InMemory\\DomainEntityRepositoryTrait  In-memory persistence    MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait  Doctrine persistence  Requires  doctrine/orm", 
            "title": "Implementations"
        }, 
        {
            "location": "/ddd/repositories/#generic-doctrine-repository-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainEntityRepositoryTrait ;  use   Doctrine\\ORM\\EntityManagerInterface ;  class   MyGenericRepository  { \n     use   DomainEntityRepositoryTrait   { \n         doFind   as   public   find ; \n     }  }  /** @var EntityManagerInterface $em */  $em   =   ... ;  $repository   =   new   MyGenericRepository ( MyEntity :: class ,   $em );   /** @var MyEntity $entity */  $entity   =   $repository - find ( 1 );", 
            "title": "Generic Doctrine repository example"
        }, 
        {
            "location": "/ddd/entities/", 
            "text": "Entities\n\n\nEntity objects are provided per domain layer and usually follow a \nPOPO\n\ndesign.\n\n\nTo simplify entity definitions common fields and features are provided in the form of PHP \ntraits\n.\nEntity fields can be compared to a read-operation, whereas entity features represent a write-operation.\n\n\nThey are defined in a dedicated namespace for discovery, respectively \nMsgphp\\Domain\\Entity\\Fields\\\n and\n\nMsgPhp\\Domain\\Entity\\Features\\\n. Additionally more specific fields and features can be provided per domain layer.\n\n\nCommon entity fields\n\n\nCreatedAtField\n\n\nA datetime value representing the entity was initially created at.\n\n\n\n\ngetCreatedAt(): \\DateTimeInterface\n\n\nRequired to be set initially\n\n\n\n\n\n\n\n\nEnabledField\n\n\nA boolean value representing the entity its availability state.\n\n\n\n\nisEnabled(): bool\n\n\nfalse\n by default\n\n\n\n\n\n\n\n\nLastUpdatedAtField\n\n\nA datetime value representing the entity was last updated at.\n\n\n\n\ngetLastUpdatedAt(): \\DateTimeInterface\n\n\nRequired to be set initially\n\n\n\n\n\n\n\n\nCommon entity features\n\n\nCanBeConfirmed\n\n\nProvides ability to confirm an entity.\n\n\n\n\ngetConfirmationToken(): ?string\n\n\nRequired to be set initially\n\n\n\n\n\n\ngetConfirmedAt(): ?\\DateTimeInterface\n \n\n\nisConfirmed(): bool\n \n\n\nconfirm(): void\n \n\n\nconfirmationToken\n is unset\n\n\nconfirmatedAt\n is set to the current datetime\n\n\n\n\n\n\n\n\nCanBeEnabled\n\n\nProvides ability to toggle an entity its availability state.\n\n\n\n\nInherits from \nEnabledField\n\n\nenable(): void\n\n\ndisable(): void", 
            "title": "Entities"
        }, 
        {
            "location": "/ddd/entities/#entities", 
            "text": "Entity objects are provided per domain layer and usually follow a  POPO \ndesign.  To simplify entity definitions common fields and features are provided in the form of PHP  traits .\nEntity fields can be compared to a read-operation, whereas entity features represent a write-operation.  They are defined in a dedicated namespace for discovery, respectively  Msgphp\\Domain\\Entity\\Fields\\  and MsgPhp\\Domain\\Entity\\Features\\ . Additionally more specific fields and features can be provided per domain layer.", 
            "title": "Entities"
        }, 
        {
            "location": "/ddd/entities/#common-entity-fields", 
            "text": "", 
            "title": "Common entity fields"
        }, 
        {
            "location": "/ddd/entities/#createdatfield", 
            "text": "A datetime value representing the entity was initially created at.   getCreatedAt(): \\DateTimeInterface  Required to be set initially", 
            "title": "CreatedAtField"
        }, 
        {
            "location": "/ddd/entities/#enabledfield", 
            "text": "A boolean value representing the entity its availability state.   isEnabled(): bool  false  by default", 
            "title": "EnabledField"
        }, 
        {
            "location": "/ddd/entities/#lastupdatedatfield", 
            "text": "A datetime value representing the entity was last updated at.   getLastUpdatedAt(): \\DateTimeInterface  Required to be set initially", 
            "title": "LastUpdatedAtField"
        }, 
        {
            "location": "/ddd/entities/#common-entity-features", 
            "text": "", 
            "title": "Common entity features"
        }, 
        {
            "location": "/ddd/entities/#canbeconfirmed", 
            "text": "Provides ability to confirm an entity.   getConfirmationToken(): ?string  Required to be set initially    getConfirmedAt(): ?\\DateTimeInterface    isConfirmed(): bool    confirm(): void    confirmationToken  is unset  confirmatedAt  is set to the current datetime", 
            "title": "CanBeConfirmed"
        }, 
        {
            "location": "/ddd/entities/#canbeenabled", 
            "text": "Provides ability to toggle an entity its availability state.   Inherits from  EnabledField  enable(): void  disable(): void", 
            "title": "CanBeEnabled"
        }, 
        {
            "location": "/event-sourcing/events/", 
            "text": "Events\n\n\nA domain event is bound to \nMsgPhp\\Domain\\Event\\DomainEventInterface\n. Its purpose is to identify concrete domain events\nand represent something that happens. When handled it might lead to an application state change.\n\n\nImplementations\n\n\nDomain events provided and handled by default \nentity features\n:\n\n\n\n\nMsgPhp\\Domain\\Event\\ConfirmEvent\n\n\nHandled by \nMsgPhp\\Domain\\Entity\\Features\\CanBeConfirmed::handleConfirmEvent()\n\n\n\n\n\n\nMsgPhp\\Domain\\Event\\DisableEvent\n\n\nHandled by \nMsgPhp\\Domain\\Entity\\Features\\CanBeEnabled::handleDisableEvent()\n\n\n\n\n\n\nMsgPhp\\Domain\\Event\\EnableEvent\n\n\nHandled by \nMsgPhp\\Domain\\Entity\\Features\\CanBeEnabled::handleEnableEvent()", 
            "title": "Events"
        }, 
        {
            "location": "/event-sourcing/events/#events", 
            "text": "A domain event is bound to  MsgPhp\\Domain\\Event\\DomainEventInterface . Its purpose is to identify concrete domain events\nand represent something that happens. When handled it might lead to an application state change.", 
            "title": "Events"
        }, 
        {
            "location": "/event-sourcing/events/#implementations", 
            "text": "Domain events provided and handled by default  entity features :   MsgPhp\\Domain\\Event\\ConfirmEvent  Handled by  MsgPhp\\Domain\\Entity\\Features\\CanBeConfirmed::handleConfirmEvent()    MsgPhp\\Domain\\Event\\DisableEvent  Handled by  MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled::handleDisableEvent()    MsgPhp\\Domain\\Event\\EnableEvent  Handled by  MsgPhp\\Domain\\Entity\\Features\\CanBeEnabled::handleEnableEvent()", 
            "title": "Implementations"
        }, 
        {
            "location": "/event-sourcing/event-handlers/", 
            "text": "Event handlers\n\n\nA domain event handler is bound to \nMsgPhp\\Domain\\Event\\DomainEventHandlerInterface\n. Its purpose is to handle\n\ndomain events\n. By convention a trait implementation is provided to map concrete events to corresponding\nhandling methods.\n\n\nAPI\n\n\nhandleEvent(DomainEventInterface $event): bool\n\n\nHandles the given domain event for a known subject. A boolean return value tells if the domain event is actually handled\nyes or no.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Event\\DomainEventHandlerTrait\n\n\nMaps events to \nhandle\nEvent_Class_Name_Without_Event_Suffix\nEvent()\n methods\n\n\nHandles default \nevents\n out-of-the-box\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Event\\DomainEventHandlerInterface\n;\n\n\nuse\n \nMsgPhp\\Domain\\Event\\DomainEventHandlerTrait\n;\n\n\n\nclass\n \nMyEvent\n\n\n{\n\n    \npublic\n \n$newValue\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n(\n$value\n)\n\n    \n{\n\n        \n$this\n-\nnewValue\n \n=\n \n$value\n;\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyEntity\n \nimplements\n \nDomainEventHandlerInterface\n\n\n{\n\n    \nuse\n \nDomainEventHandlerTrait\n;\n\n\n    \npublic\n \n$value\n;\n\n\n    \nprivate\n \nfunction\n \nhandleMyEvent\n(\nMyEvent\n \n$event\n)\n:\n \nbool\n\n    \n{\n\n        \nif\n \n(\n$this\n-\nvalue\n \n===\n \n$event\n-\nnewValue\n)\n \n{\n\n            \nreturn\n \nfalse\n;\n\n        \n}\n\n\n        \n$this\n-\nvalue\n \n=\n \n$event\n-\nnewValue\n;\n\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n\n\n}\n\n\n\n$entity\n \n=\n \nnew\n \nMyEntity\n();\n\n\nif\n \n(\n$entity\n-\nhandleEvent\n(\nnew\n \nMyEvent\n(\nvalue\n)))\n \n{\n\n    \n// do something\n\n\n}", 
            "title": "Event handlers"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#event-handlers", 
            "text": "A domain event handler is bound to  MsgPhp\\Domain\\Event\\DomainEventHandlerInterface . Its purpose is to handle domain events . By convention a trait implementation is provided to map concrete events to corresponding\nhandling methods.", 
            "title": "Event handlers"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#handleeventdomaineventinterface-event-bool", 
            "text": "Handles the given domain event for a known subject. A boolean return value tells if the domain event is actually handled\nyes or no.", 
            "title": "handleEvent(DomainEventInterface $event): bool"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#implementations", 
            "text": "MsgPhp\\Domain\\Event\\DomainEventHandlerTrait  Maps events to  handle Event_Class_Name_Without_Event_Suffix Event()  methods  Handles default  events  out-of-the-box", 
            "title": "Implementations"
        }, 
        {
            "location": "/event-sourcing/event-handlers/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Event\\DomainEventHandlerInterface ;  use   MsgPhp\\Domain\\Event\\DomainEventHandlerTrait ;  class   MyEvent  { \n     public   $newValue ; \n\n     public   function   __construct ( $value ) \n     { \n         $this - newValue   =   $value ; \n     }  }  class   MyEntity   implements   DomainEventHandlerInterface  { \n     use   DomainEventHandlerTrait ; \n\n     public   $value ; \n\n     private   function   handleMyEvent ( MyEvent   $event ) :   bool \n     { \n         if   ( $this - value   ===   $event - newValue )   { \n             return   false ; \n         } \n\n         $this - value   =   $event - newValue ; \n\n         return   true ; \n     }  }  $entity   =   new   MyEntity ();  if   ( $entity - handleEvent ( new   MyEvent ( value )))   { \n     // do something  }", 
            "title": "Basic example"
        }, 
        {
            "location": "/message-driven/message-bus/", 
            "text": "Message bus\n\n\nA domain message bus is bound to \nMsgPhp\\Domain\\Message\\DomainMessageBusInterface\n. Its purpose is to dispatch any type\nof message object and helps you to use \nCQRS\n and \nevent sourcing\n.\n\n\nAPI\n\n\ndispatch(object $message): mixed\n\n\nDispatches the given message object. The bus can return a value coming from handlers, but is not required to do so.\n\n\nImplementations\n\n\n\n\nMsgPhp\\Domain\\Infra\\SimpleBus\\DomainMessageBus\n\n\nRequires \nsimple-bus/message-bus", 
            "title": "Message bus"
        }, 
        {
            "location": "/message-driven/message-bus/#message-bus", 
            "text": "A domain message bus is bound to  MsgPhp\\Domain\\Message\\DomainMessageBusInterface . Its purpose is to dispatch any type\nof message object and helps you to use  CQRS  and  event sourcing .", 
            "title": "Message bus"
        }, 
        {
            "location": "/message-driven/message-bus/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/message-driven/message-bus/#dispatchobject-message-mixed", 
            "text": "Dispatches the given message object. The bus can return a value coming from handlers, but is not required to do so.", 
            "title": "dispatch(object $message): mixed"
        }, 
        {
            "location": "/message-driven/message-bus/#implementations", 
            "text": "MsgPhp\\Domain\\Infra\\SimpleBus\\DomainMessageBus  Requires  simple-bus/message-bus", 
            "title": "Implementations"
        }, 
        {
            "location": "/message-driven/message-dispatcher/", 
            "text": "Message dispatcher\n\n\nThe domain message dispatcher is a utility trait. Its purpose is to dispatch a factorized message object using a\n\nobject factory\n and a \nmessage bus\n.\n\n\nAPI\n\n\n\n\nExposed \nprivate\n as a trait. You can decide to \nchange method visibility\n\non a per case basis.\n\n\n\n\ndispatch(string $class, array $context = []): mixed\n\n\nDispatches a message object factorized from \n$class\n and \n$context\n. The dispatcher can return a value coming from\nhandlers, but is not required to do so.\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Message\\MessageDispatchingTrait\n;\n\n\n\nclass\n \nMyMessage\n\n\n{\n\n    \npublic\n \n$argument\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n(\nstring\n \n$argument\n)\n\n    \n{\n\n        \n$this\n-\nargument\n \n=\n \n$argument\n;\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyClass\n\n\n{\n\n    \nuse\n \nMessageDispatchingTrait\n;\n\n\n    \npublic\n \nfunction\n \ndoSomething\n()\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\ndispatch\n(\nMyMessage\n::\nclass\n,\n \n[\nargument\n \n=\n \nvalue\n]);\n\n    \n}\n\n\n}", 
            "title": "Message dispatcher"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#message-dispatcher", 
            "text": "The domain message dispatcher is a utility trait. Its purpose is to dispatch a factorized message object using a object factory  and a  message bus .", 
            "title": "Message dispatcher"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#api", 
            "text": "Exposed  private  as a trait. You can decide to  change method visibility \non a per case basis.", 
            "title": "API"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#dispatchstring-class-array-context-mixed", 
            "text": "Dispatches a message object factorized from  $class  and  $context . The dispatcher can return a value coming from\nhandlers, but is not required to do so.", 
            "title": "dispatch(string $class, array $context = []): mixed"
        }, 
        {
            "location": "/message-driven/message-dispatcher/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Message\\MessageDispatchingTrait ;  class   MyMessage  { \n     public   $argument ; \n\n     public   function   __construct ( string   $argument ) \n     { \n         $this - argument   =   $argument ; \n     }  }  class   MyClass  { \n     use   MessageDispatchingTrait ; \n\n     public   function   doSomething () :   void \n     { \n         $this - dispatch ( MyMessage :: class ,   [ argument   =   value ]); \n     }  }", 
            "title": "Basic example"
        }, 
        {
            "location": "/message-driven/cqrs/", 
            "text": "Command Query Responsibility Segregation\n\n\nCommands are domain objects and provided per domain layer. They usually follow a \nPOPO\n\ndesign. Its purpose is to describe an action to be taken. For commands being messages they can be dispatched using any\n\nmessage bus\n.\n\n\nCommand handlers\n\n\nThe message bus resolves a command handler, which in turn handles the command. Thus performs the requested action.\nUsually a command handler is designed, but not limited, to handle one specific command message.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait\n\n\nHandles a command message by sourcing a domain event.\n\n\n\n\nhandle(object $command, callable $onHandled = null): void\n\n\nIf the domain event is handled \n$onHandled\n will be invoked (if given), receiving the handler as first argument\n\n\n\n\n\n\nabstract getDomainEvent(object $command): DomainEventInterface\n\n\nThe \ndomain event\n to be handled\n\n\n\n\n\n\nabstract getDomainEventHandler(object $command): DomainEventHandlerInterface\n\n\nThe \ndomain event handler\n handling the domain event\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nclass\n \nMyCommand\n\n\n{\n\n\n}\n\n\n\nclass\n \nMyCommandHandler\n\n\n{\n\n    \npublic\n \nfunction\n \n__invoke\n(\nMyCommand\n \n$command\n)\n:\n \nvoid\n\n    \n{\n\n        \n// handle $command\n\n    \n}\n\n\n}\n\n\n\n$bus\n-\ndispatch\n(\nnew\n \nMyCommand\n());\n\n\n\n\n\n\nEvent sourcing example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait\n;\n \n\nuse\n \nMsgPhp\\Domain\\Event\\\n{\nDomainEventHandlerInterface\n,\n \nDomainEventInterface\n};\n \n\n\nclass\n \nMyCommand\n\n\n{\n\n\n}\n\n\n\nclass\n \nMyCommandHandler\n\n\n{\n\n    \nuse\n \nEventSourcingCommandHandlerTrait\n;\n\n\n    \npublic\n \nfunction\n \n__invoke\n(\nMyCommand\n \n$command\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\nhandle\n(\n$command\n,\n \nfunction\n \n(\nMyEntity\n \n$entity\n)\n:\n \nvoid\n \n{\n\n            \n// do something when $command is handled\n\n        \n});\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \ngetDomainEvent\n(\nMyCommand\n \n$command\n)\n:\n \nDomainEventInterface\n\n    \n{\n\n        \nreturn\n \nnew\n \nMyDomainEvent\n();\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \ngetDomainEventHandler\n(\nMyCommand\n \n$command\n)\n:\n \nDomainEventHandlerInterface\n\n    \n{\n\n        \nreturn\n \nnew\n \nMyEntity\n();\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyDomainEvent\n \nimplements\n \nDomainEventInterface\n\n\n{\n\n\n}\n\n\n\nclass\n \nMyEntity\n \nimplements\n \nDomainEventHandlerInterface\n\n\n{\n\n    \npublic\n \nfunction\n \nhandleEvent\n(\nDomainEventInterface\n \n$event\n)\n:\n \nbool\n\n    \n{\n\n        \nif\n \n(\n$event\n \ninstanceof\n \nMyDomainEvent\n)\n \n{\n\n            \n// do something\n\n\n            \nreturn\n \ntrue\n;\n\n        \n}\n\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n}\n\n\n\n$bus\n-\ndispatch\n(\nnew\n \nMyCommand\n());", 
            "title": "CQRS"
        }, 
        {
            "location": "/message-driven/cqrs/#command-query-responsibility-segregation", 
            "text": "Commands are domain objects and provided per domain layer. They usually follow a  POPO \ndesign. Its purpose is to describe an action to be taken. For commands being messages they can be dispatched using any message bus .", 
            "title": "Command Query Responsibility Segregation"
        }, 
        {
            "location": "/message-driven/cqrs/#command-handlers", 
            "text": "The message bus resolves a command handler, which in turn handles the command. Thus performs the requested action.\nUsually a command handler is designed, but not limited, to handle one specific command message.", 
            "title": "Command handlers"
        }, 
        {
            "location": "/message-driven/cqrs/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/message-driven/cqrs/#msgphpdomaincommandeventsourcingcommandhandlertrait", 
            "text": "Handles a command message by sourcing a domain event.   handle(object $command, callable $onHandled = null): void  If the domain event is handled  $onHandled  will be invoked (if given), receiving the handler as first argument    abstract getDomainEvent(object $command): DomainEventInterface  The  domain event  to be handled    abstract getDomainEventHandler(object $command): DomainEventHandlerInterface  The  domain event handler  handling the domain event", 
            "title": "MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait"
        }, 
        {
            "location": "/message-driven/cqrs/#basic-example", 
            "text": "?php  class   MyCommand  {  }  class   MyCommandHandler  { \n     public   function   __invoke ( MyCommand   $command ) :   void \n     { \n         // handle $command \n     }  }  $bus - dispatch ( new   MyCommand ());", 
            "title": "Basic example"
        }, 
        {
            "location": "/message-driven/cqrs/#event-sourcing-example", 
            "text": "?php  use   MsgPhp\\Domain\\Command\\EventSourcingCommandHandlerTrait ;   use   MsgPhp\\Domain\\Event\\ { DomainEventHandlerInterface ,   DomainEventInterface };   class   MyCommand  {  }  class   MyCommandHandler  { \n     use   EventSourcingCommandHandlerTrait ; \n\n     public   function   __invoke ( MyCommand   $command ) :   void \n     { \n         $this - handle ( $command ,   function   ( MyEntity   $entity ) :   void   { \n             // do something when $command is handled \n         }); \n     } \n\n     protected   function   getDomainEvent ( MyCommand   $command ) :   DomainEventInterface \n     { \n         return   new   MyDomainEvent (); \n     } \n\n     protected   function   getDomainEventHandler ( MyCommand   $command ) :   DomainEventHandlerInterface \n     { \n         return   new   MyEntity (); \n     }  }  class   MyDomainEvent   implements   DomainEventInterface  {  }  class   MyEntity   implements   DomainEventHandlerInterface  { \n     public   function   handleEvent ( DomainEventInterface   $event ) :   bool \n     { \n         if   ( $event   instanceof   MyDomainEvent )   { \n             // do something \n\n             return   true ; \n         } \n\n         return   false ; \n     }  }  $bus - dispatch ( new   MyCommand ());", 
            "title": "Event sourcing example"
        }, 
        {
            "location": "/infrastructure/uuid/", 
            "text": "Universally Unique Identifier\n\n\nAn overview of available infrastructural code when working with \nUUID's\n.\n\n\n\n\nRequires \nramsey/uuid\n\n\n\n\nDomain identifier\n\n\nA UUID tailored \ndomain identifier\n is provided by \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n. It\nleverages type \nRamsey\\Uuid\\UuidInterface\n as underlying data type.\n\n\n\n\n__construct(UuidInterface $uuid = null)\n\n\n$uuid\n: The underlying UUID. In case of \nnull\n a UUID version 4 value is generated upfront. Meaning the\n  identifier will never be considered empty.\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Uuid\\DomainId\n;\n\n\nuse\n \nRamsey\\Uuid\\Uuid\n;\n\n\n\n// --- SETUP ---\n\n\n\n$id\n \n=\n \nnew\n \nDomainId\n();\n \n// a new UUID version 4 value\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\nUuid\n::\nuuid1\n());\n \n// UUID version 1 value\n\n\n$id\n \n=\n \nnew\n \nDomainId\n(\nUuid\n::\nfromString\n(\n00000000-0000-0000-0000-000000000000\n));\n \n// Nil UUID value\n\n\n\n// static\n\n\n\n$id\n \n=\n \nDomainId\n::\nfromValue\n(\n00000000-0000-0000-0000-000000000000\n);", 
            "title": "UUID"
        }, 
        {
            "location": "/infrastructure/uuid/#universally-unique-identifier", 
            "text": "An overview of available infrastructural code when working with  UUID's .   Requires  ramsey/uuid", 
            "title": "Universally Unique Identifier"
        }, 
        {
            "location": "/infrastructure/uuid/#domain-identifier", 
            "text": "A UUID tailored  domain identifier  is provided by  MsgPhp\\Domain\\Infra\\Uuid\\DomainId . It\nleverages type  Ramsey\\Uuid\\UuidInterface  as underlying data type.   __construct(UuidInterface $uuid = null)  $uuid : The underlying UUID. In case of  null  a UUID version 4 value is generated upfront. Meaning the\n  identifier will never be considered empty.", 
            "title": "Domain identifier"
        }, 
        {
            "location": "/infrastructure/uuid/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Uuid\\DomainId ;  use   Ramsey\\Uuid\\Uuid ;  // --- SETUP ---  $id   =   new   DomainId ();   // a new UUID version 4 value  $id   =   new   DomainId ( Uuid :: uuid1 ());   // UUID version 1 value  $id   =   new   DomainId ( Uuid :: fromString ( 00000000-0000-0000-0000-000000000000 ));   // Nil UUID value  // static  $id   =   DomainId :: fromValue ( 00000000-0000-0000-0000-000000000000 );", 
            "title": "Basic example"
        }, 
        {
            "location": "/infrastructure/doctrine-collections/", 
            "text": "Doctrine Collections\n\n\nAn overview of available infrastructural code when using \nDoctrine Collections\n.\n\n\n\n\nRequires \ndoctrine/collections\n\n\n\n\nDomain collection\n\n\nA Doctrine tailored \ndomain collection\n is provided by \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n.\nIt leverages type \nDoctrine\\Common\\Collections\\Collection\n as underlying data type.\n\n\n\n\n__construct(Collection $collection)\n\n\n$collection\n: The underlying collection\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nDoctrine\\Common\\Collections\\ArrayCollection\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection\n;\n\n\n\n// --- SETUP ---\n\n\n\n$collection\n \n=\n \nnew\n \nDomainCollection\n(\nnew\n \nArrayCollection\n([\n1\n,\n \n2\n,\n \n3\n]));\n\n\n\n// static\n\n\n\n$collection\n \n=\n \nDomainCollection\n::\nfromValue\n([\n1\n,\n \n2\n,\n \n3\n]);", 
            "title": "Collections"
        }, 
        {
            "location": "/infrastructure/doctrine-collections/#doctrine-collections", 
            "text": "An overview of available infrastructural code when using  Doctrine Collections .   Requires  doctrine/collections", 
            "title": "Doctrine Collections"
        }, 
        {
            "location": "/infrastructure/doctrine-collections/#domain-collection", 
            "text": "A Doctrine tailored  domain collection  is provided by  MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection .\nIt leverages type  Doctrine\\Common\\Collections\\Collection  as underlying data type.   __construct(Collection $collection)  $collection : The underlying collection", 
            "title": "Domain collection"
        }, 
        {
            "location": "/infrastructure/doctrine-collections/#basic-example", 
            "text": "?php  use   Doctrine\\Common\\Collections\\ArrayCollection ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainCollection ;  // --- SETUP ---  $collection   =   new   DomainCollection ( new   ArrayCollection ([ 1 ,   2 ,   3 ]));  // static  $collection   =   DomainCollection :: fromValue ([ 1 ,   2 ,   3 ]);", 
            "title": "Basic example"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/", 
            "text": "Doctrine Object Relational Mapper\n\n\nAn overview of available infrastructural code when using \nDoctrine Object Relational Mapper\n.\n\n\n\n\nRequires \ndoctrine/orm\n\n\n\n\nDomain identity mapping\n\n\nA Doctrine tailored \ndomain identity mapping\n is provided by\n\nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n. It uses Doctrine's entity manager, bound to\n\nDoctrine\\ORM\\EntityManagerInterface\n, as underlying mapping.\n\n\n\n\n__construct(EntityManagerInterface $em)\n\n\n$em\n: The entity manager to use\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nDoctrine\\ORM\\EntityManagerInterface\n;\n\n\nuse\n \nDoctrine\\ORM\\Mapping\n \nas\n \nORM\n;\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping\n;\n\n\n\n// --- SETUP ---\n\n\n\n/** @ORM\\Entity() */\n\n\nclass\n \nMyCompositeEntity\n\n\n{\n\n    \n/** @ORM\\Id @ORM\\Column(type=\nstring\n) */\n\n    \npublic\n \n$name\n;\n\n\n    \n/** @ORM\\Id @ORM\\Column(type=\ninteger\n) */\n\n    \npublic\n \n$year\n;\n\n\n}\n\n\n\n$compositeEntity\n \n=\n \nnew\n \nMyCompositeEntity\n();\n\n\n$compositeEntity\n-\nname\n \n=\n \n...\n;\n\n\n$compositeEntity\n-\nyear\n \n=\n \n...\n;\n\n\n\n/** @var EntityManagerInterface $em */\n\n\n$em\n \n=\n \n...\n;\n\n\n$mapping\n \n=\n \nnew\n \nDomainIdentityMapping\n(\n$em\n);", 
            "title": "ORM"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#doctrine-object-relational-mapper", 
            "text": "An overview of available infrastructural code when using  Doctrine Object Relational Mapper .   Requires  doctrine/orm", 
            "title": "Doctrine Object Relational Mapper"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#domain-identity-mapping", 
            "text": "A Doctrine tailored  domain identity mapping  is provided by MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping . It uses Doctrine's entity manager, bound to Doctrine\\ORM\\EntityManagerInterface , as underlying mapping.   __construct(EntityManagerInterface $em)  $em : The entity manager to use", 
            "title": "Domain identity mapping"
        }, 
        {
            "location": "/infrastructure/doctrine-orm/#basic-example", 
            "text": "?php  use   Doctrine\\ORM\\EntityManagerInterface ;  use   Doctrine\\ORM\\Mapping   as   ORM ;  use   MsgPhp\\Domain\\Infra\\Doctrine\\DomainIdentityMapping ;  // --- SETUP ---  /** @ORM\\Entity() */  class   MyCompositeEntity  { \n     /** @ORM\\Id @ORM\\Column(type= string ) */ \n     public   $name ; \n\n     /** @ORM\\Id @ORM\\Column(type= integer ) */ \n     public   $year ;  }  $compositeEntity   =   new   MyCompositeEntity ();  $compositeEntity - name   =   ... ;  $compositeEntity - year   =   ... ;  /** @var EntityManagerInterface $em */  $em   =   ... ;  $mapping   =   new   DomainIdentityMapping ( $em );", 
            "title": "Basic example"
        }, 
        {
            "location": "/infrastructure/symfony-console/", 
            "text": "Symfony Console\n\n\nAn overview of available infrastructural code when using \nSymfony Console\n.\n\n\n\n\nRequires \nsymfony/console\n\n\n\n\nContext builder\n\n\nA context builder is bound to \nMsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ContextBuilderInterface\n. Its purpose is to\n(interactively) built an arbitrary array value, i.e. the context, from a CLI command. Its value can be used as e.g. a\ncontext provided to an \nobject factory\n.\n\n\n\n\nBlog post: \nInitializing objects with CLI and the power of Symfony Console\n\n\n\n\nAPI\n\n\nconfigure(InputDefinition $definition): void\n\n\nConfigure a command input definition. See also \nInputDefinition\n.\n\n\n\n\ngetContext(InputInterface $input, StyleInterface $io): array\n\n\nResolve the actual context from the console IO. See also \nInputInterface\n\nand \nStyleInterface\n.\n\n\nImplementations\n\n\nMsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ClassContextBuilder\n\n\nBuild a context value from any class method signature. It configures the CLI signature by mapping required class method\narguments to command arguments, whereas optional ones are mapped to command options.\n\n\nBy default any command argument / option will be optional. If the actual class method argument is required and no value\nis given it will be asked interactively. If interaction is not possible an exception will be thrown instead.\n\n\n\n\n__construct(string $class, string $method, iterable $elementProviders = [], array $classMapping = [], int $flags = 0)\n\n\n$class / $method\n: The class method to resolve\n\n\n$elementProviders\n: Available context element providers (see \nProviding context elements\n)\n\n\n$classMapping\n: Global class mapping which resolves \n$class\n or any nested class name from type info. Usually used\n  to map interfaces to concretes.\n\n\n$flags\n: A bit mask value to toggle various flags\n\n\nClassContextBuilder::ALWAYS_OPTIONAL\n: Always map class method argument to command options\n\n\nClassContextBuilder::NO_DEFAULTS\n: Leave out default values when calling \ngetContext()\n\n\n\n\n\n\n\n\n\n\n\n\nProviding context elements\n\n\nPer-element configuration can be provided by implementing a \nMsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ContextElementProviderInterface\n.\n\n\n\n\ngetElement(string $class, string $method, string $argument): ?ContextElement\n\n\nResolve a \nContextElement\n\n  from a class/method/argument combination\n\n\n\n\n\n\n\n\nBasic example\n\n\n?php\n\n\n\nuse\n \nMsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\\n{\nClassContextBuilder\n,\n \nContextElement\n,\n \nContextElementProviderInterface\n};\n\n\nuse\n \nSymfony\\Component\\Console\\Command\\Command\n;\n\n\nuse\n \nSymfony\\Component\\Console\\Input\\InputInterface\n;\n\n\nuse\n \nSymfony\\Component\\Console\\Output\\OutputInterface\n;\n\n\nuse\n \nSymfony\\Component\\Console\\Style\\SymfonyStyle\n;\n\n\n\n// --- SETUP ---\n\n\n\nclass\n \nMyClass\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\nstring\n \n$argument\n)\n\n    \n{\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyContextElementProvider\n \nimplements\n \nContextElementProviderInterface\n\n\n{\n\n    \npublic\n \nfunction\n \ngetElement\n(\nstring\n \n$class\n,\n \nstring\n \n$method\n,\n \nstring\n \n$argument\n)\n:\n \n?\nContextElement\n\n    \n{\n\n        \nreturn\n \nnew\n \nContextElement\n(\nstrtoupper\n(\n$argument\n));\n\n    \n}\n\n\n}\n\n\n\nclass\n \nMyCommand\n \nextends\n \nCommand\n\n\n{\n\n    \nprivate\n \n$contextBuilder\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\ncontextBuilder\n \n=\n \nnew\n \nClassContextBuilder\n(\nMyClass\n::\nclass\n,\n \n__construct\n,\n \n[\nnew\n \nMyContextElementProvider\n()]);\n\n\n        \nparent\n::\n__construct\n();\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \nconfigure\n()\n:\n \nvoid\n\n    \n{\n\n       \n$this\n-\nsetName\n(\nmy-command\n);\n\n       \n$this\n-\ncontextBuilder\n-\nconfigure\n(\n$this\n-\ngetDefinition\n());\n\n\n       \n// The CLI usage is now:\n\n       \n// bin/console my-command [argument]\n\n    \n}\n\n\n    \nprotected\n \nfunction\n \nexecute\n(\nInputInterface\n \n$input\n,\nOutputInterface\n \n$output\n)\n:\n \nint\n\n    \n{\n\n        \n$io\n \n=\n \nnew\n \nSymfonyStyle\n(\n$input\n,\n \n$output\n);\n\n        \n$context\n \n=\n \n$this\n-\ncontextBuilder\n-\ngetContext\n(\n$input\n,\n \n$io\n);\n \n// [\nargument\n =\n \nVALUE\n]\n\n        \n$object\n \n=\n \nnew\n \nMyClass\n(\n...\narray_values\n(\n$context\n));\n\n\n        \n// do something\n\n\n        \nreturn\n \n0\n;\n\n    \n}\n\n\n}\n\n\n\n// --- USAGE ---\n\n\n\n// $ bin/console my-command", 
            "title": "Console"
        }, 
        {
            "location": "/infrastructure/symfony-console/#symfony-console", 
            "text": "An overview of available infrastructural code when using  Symfony Console .   Requires  symfony/console", 
            "title": "Symfony Console"
        }, 
        {
            "location": "/infrastructure/symfony-console/#context-builder", 
            "text": "A context builder is bound to  MsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ContextBuilderInterface . Its purpose is to\n(interactively) built an arbitrary array value, i.e. the context, from a CLI command. Its value can be used as e.g. a\ncontext provided to an  object factory .   Blog post:  Initializing objects with CLI and the power of Symfony Console", 
            "title": "Context builder"
        }, 
        {
            "location": "/infrastructure/symfony-console/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/infrastructure/symfony-console/#configureinputdefinition-definition-void", 
            "text": "Configure a command input definition. See also  InputDefinition .", 
            "title": "configure(InputDefinition $definition): void"
        }, 
        {
            "location": "/infrastructure/symfony-console/#getcontextinputinterface-input-styleinterface-io-array", 
            "text": "Resolve the actual context from the console IO. See also  InputInterface \nand  StyleInterface .", 
            "title": "getContext(InputInterface $input, StyleInterface $io): array"
        }, 
        {
            "location": "/infrastructure/symfony-console/#implementations", 
            "text": "", 
            "title": "Implementations"
        }, 
        {
            "location": "/infrastructure/symfony-console/#msgphpdomaininfraconsolecontextbuilderclasscontextbuilder", 
            "text": "Build a context value from any class method signature. It configures the CLI signature by mapping required class method\narguments to command arguments, whereas optional ones are mapped to command options.  By default any command argument / option will be optional. If the actual class method argument is required and no value\nis given it will be asked interactively. If interaction is not possible an exception will be thrown instead.   __construct(string $class, string $method, iterable $elementProviders = [], array $classMapping = [], int $flags = 0)  $class / $method : The class method to resolve  $elementProviders : Available context element providers (see  Providing context elements )  $classMapping : Global class mapping which resolves  $class  or any nested class name from type info. Usually used\n  to map interfaces to concretes.  $flags : A bit mask value to toggle various flags  ClassContextBuilder::ALWAYS_OPTIONAL : Always map class method argument to command options  ClassContextBuilder::NO_DEFAULTS : Leave out default values when calling  getContext()", 
            "title": "MsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ClassContextBuilder"
        }, 
        {
            "location": "/infrastructure/symfony-console/#providing-context-elements", 
            "text": "Per-element configuration can be provided by implementing a  MsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ContextElementProviderInterface .   getElement(string $class, string $method, string $argument): ?ContextElement  Resolve a  ContextElement \n  from a class/method/argument combination", 
            "title": "Providing context elements"
        }, 
        {
            "location": "/infrastructure/symfony-console/#basic-example", 
            "text": "?php  use   MsgPhp\\Domain\\Infra\\Console\\ContextBuilder\\ { ClassContextBuilder ,   ContextElement ,   ContextElementProviderInterface };  use   Symfony\\Component\\Console\\Command\\Command ;  use   Symfony\\Component\\Console\\Input\\InputInterface ;  use   Symfony\\Component\\Console\\Output\\OutputInterface ;  use   Symfony\\Component\\Console\\Style\\SymfonyStyle ;  // --- SETUP ---  class   MyClass  { \n     public   function   __construct ( string   $argument ) \n     { \n     }  }  class   MyContextElementProvider   implements   ContextElementProviderInterface  { \n     public   function   getElement ( string   $class ,   string   $method ,   string   $argument ) :   ? ContextElement \n     { \n         return   new   ContextElement ( strtoupper ( $argument )); \n     }  }  class   MyCommand   extends   Command  { \n     private   $contextBuilder ; \n\n     public   function   __construct () \n     { \n         $this - contextBuilder   =   new   ClassContextBuilder ( MyClass :: class ,   __construct ,   [ new   MyContextElementProvider ()]); \n\n         parent :: __construct (); \n     } \n\n     protected   function   configure () :   void \n     { \n        $this - setName ( my-command ); \n        $this - contextBuilder - configure ( $this - getDefinition ()); \n\n        // The CLI usage is now: \n        // bin/console my-command [argument] \n     } \n\n     protected   function   execute ( InputInterface   $input , OutputInterface   $output ) :   int \n     { \n         $io   =   new   SymfonyStyle ( $input ,   $output ); \n         $context   =   $this - contextBuilder - getContext ( $input ,   $io );   // [ argument  =   VALUE ] \n         $object   =   new   MyClass ( ... array_values ( $context )); \n\n         // do something \n\n         return   0 ; \n     }  }  // --- USAGE ---  // $ bin/console my-command", 
            "title": "Basic example"
        }
    ]
}